
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.auxs.anntools &#8212; HydPy 4.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.anntools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.anntools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module implements rudimentary artificial neural network tools</span>
<span class="sd">required for some models implemented in the *HydPy* framework.</span>

<span class="sd">The relevant models apply some of the neural network features during</span>
<span class="sd">simulation runs, which is why we implement these features in the Cython</span>
<span class="sd">extension module |annutils|.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">import</span> <span class="nn">hydpy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">parametertools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">propertytools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">timetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">variabletools</span>
<span class="kn">from</span> <span class="nn">hydpy.cythons.autogen</span> <span class="kn">import</span> <span class="n">annutils</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">pyplot</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">OptionalImport</span><span class="p">(</span><span class="s2">&quot;pyplot&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;matplotlib.pyplot&quot;</span><span class="p">],</span> <span class="nb">locals</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">_ANNArrayProperty</span><span class="p">(</span>
    <span class="n">propertytools</span><span class="o">.</span><span class="n">DependentProperty</span><span class="p">[</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">):</span>

    <span class="n">__obj2cann</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protected</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">protected</span><span class="o">=</span><span class="n">protected</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fdel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">add_cann</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cann</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log the given Cython based ANN for the given object.&quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__obj2cann</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">cann</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;shape_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">cann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__obj2cann</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__fget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__obj2cann</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;activation&quot;</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">cann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="n">descr</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)))</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                    <span class="s2">&quot;While trying to set the </span><span class="si">%s</span><span class="s2"> of the &quot;</span>
                    <span class="s2">&quot;artificial neural network </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__fdel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">cann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__obj2cann</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;activation&quot;</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">cann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>


<div class="viewcode-block" id="BaseANN"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.BaseANN">[docs]</a><span class="k">class</span> <span class="nc">BaseANN</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base for implementing artificial neural networks classes.&quot;&quot;&quot;</span>

    <span class="n">XLABEL</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">YLABEL</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">subclasscounter</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">Variable</span><span class="o">.</span><span class="n">__hydpy__subclasscounter__</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">variabletools</span><span class="o">.</span><span class="n">Variable</span><span class="o">.</span><span class="n">__hydpy__subclasscounter__</span> <span class="o">=</span> <span class="n">subclasscounter</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__hydpy__subclasscounter__</span> <span class="o">=</span> <span class="n">subclasscounter</span>

    <span class="k">def</span> <span class="nf">_update_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;XLABEL&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlabel</span><span class="p">:</span>
            <span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;YLABEL&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span><span class="p">:</span>
            <span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span></div>


<div class="viewcode-block" id="ANN"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN">[docs]</a><span class="k">class</span> <span class="nc">ANN</span><span class="p">(</span><span class="n">BaseANN</span><span class="p">):</span>
    <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
    <span class="sd">&quot;&quot;&quot;Multi-layer feed-forward artificial neural network.</span>

<span class="sd">    By default, class |anntools.ANN| uses the logistic function</span>
<span class="sd">    :math:`f(x) = \\frac{1}{1+exp(-x)}` to calculate the activation of</span>
<span class="sd">    the neurons of the hidden layer.  Alternatively, one can select the</span>
<span class="sd">    identity function :math:`f(x) = x` or a variant of the logistic</span>
<span class="sd">    function for filtering specific inputs.  See property</span>
<span class="sd">    |anntools.ANN.activation| for more information on how to do this.</span>

<span class="sd">    Usually, one applies class |anntools.ANN| for the derivation of very</span>
<span class="sd">    complex control parameters.  Its original purpose was to allow for</span>
<span class="sd">    defining arbitrary continuous relationships between the water stored</span>
<span class="sd">    in a dam and the associated water stage (see model |dam_v001|).</span>
<span class="sd">    However, for testing purposes class |anntools.ANN| can also be applied</span>
<span class="sd">    directly, as shown in the following examples.</span>

<span class="sd">    Firstly, define the most simple artificial neural network consisting of</span>
<span class="sd">    only one input node, one hidden neuron, and one output node, and pass</span>
<span class="sd">    some arbitrary network parameters:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import ANN, nan</span>
<span class="sd">    &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">    &gt;&gt;&gt; ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...     weights_input=4.0, weights_output=3.0,</span>
<span class="sd">    ...     intercepts_hidden=-16.0, intercepts_output=-1.0)</span>

<span class="sd">    The following loop subsequently sets the values 0 to 8 as input values,</span>
<span class="sd">    performs the calculation, and prints out the final output.  As to be</span>
<span class="sd">    expected, the results show the shape of the logistic function:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; for input_ in range(9):</span>
<span class="sd">    ...     ann.inputs[0] = input_</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     round_([input_, ann.outputs[0]])</span>
<span class="sd">    0, -1.0</span>
<span class="sd">    1, -0.999982</span>
<span class="sd">    2, -0.998994</span>
<span class="sd">    3, -0.946041</span>
<span class="sd">    4, 0.5</span>
<span class="sd">    5, 1.946041</span>
<span class="sd">    6, 1.998994</span>
<span class="sd">    7, 1.999982</span>
<span class="sd">    8, 2.0</span>

<span class="sd">    One can also directly plot the resulting graph:</span>

<span class="sd">    &gt;&gt;&gt; ann.plot(0.0, 8.0)</span>

<span class="sd">    You can use the `pyplot` API of `matplotlib` to modify the figure</span>
<span class="sd">    or to save it to disk (or print it to the screen, in case the</span>
<span class="sd">    interactive mode of `matplotlib` is disabled):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import save_autofig</span>
<span class="sd">    &gt;&gt;&gt; save_autofig(&quot;ANN_plot.png&quot;)</span>

<span class="sd">    .. image:: ANN_plot.png</span>

<span class="sd">    Some models might require the derivative of certain outputs with respect</span>
<span class="sd">    to individual inputs.  One example is application model the |dam_v006|,</span>
<span class="sd">    which uses class |anntools.ANN| to model the relationship between water</span>
<span class="sd">    storage and stage of a lake.  During a simulation run , it additionally</span>
<span class="sd">    needs to know the area of the water surface, which is the derivative of</span>
<span class="sd">    storage with respect to stage.  For such purposes, class |anntools.ANN|</span>
<span class="sd">    provides method |anntools.ANN.calculate_derivatives|.  In the following</span>
<span class="sd">    example, we apply this method and compare its results with finite</span>
<span class="sd">    difference approximations:</span>

<span class="sd">    &gt;&gt;&gt; d_input = 1e-8</span>
<span class="sd">    &gt;&gt;&gt; for input_ in range(9):</span>
<span class="sd">    ...     ann.inputs[0] = input_-d_input/2.0</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     value0 = ann.outputs[0]</span>
<span class="sd">    ...     ann.inputs[0] = input_+d_input/2.0</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     value1 = ann.outputs[0]</span>
<span class="sd">    ...     derivative = (value1-value0)/d_input</span>
<span class="sd">    ...     ann.inputs[0] = input_</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     ann.calculate_derivatives(0)</span>
<span class="sd">    ...     round_([input_, derivative, ann.output_derivatives[0]])</span>
<span class="sd">    0, 0.000001, 0.000001</span>
<span class="sd">    1, 0.000074, 0.000074</span>
<span class="sd">    2, 0.004023, 0.004023</span>
<span class="sd">    3, 0.211952, 0.211952</span>
<span class="sd">    4, 3.0, 3.0</span>
<span class="sd">    5, 0.211952, 0.211952</span>
<span class="sd">    6, 0.004023, 0.004023</span>
<span class="sd">    7, 0.000074, 0.000074</span>
<span class="sd">    8, 0.000001, 0.000001</span>

<span class="sd">    Note the following two potential pitfalls (both due to improving the</span>
<span class="sd">    computational efficiency of method |anntools.ANN.calculate_derivatives|):</span>
<span class="sd">    First, for networks with more than one hidden layer, you must call</span>
<span class="sd">    |anntools.ANN.calculate_values| before calling</span>
<span class="sd">    |anntools.ANN.calculate_derivatives|.  Second, method</span>
<span class="sd">    |anntools.ANN.calculate_derivatives| calculates the derivatives</span>
<span class="sd">    with respect to a single input only, to be selected by the `idx_input`</span>
<span class="sd">    argument.  However, it works fine to call method</span>
<span class="sd">    |anntools.ANN.calculate_values| ones and to call</span>
<span class="sd">    |anntools.ANN.calculate_derivatives| multiple times afterwards. Then</span>
<span class="sd">    you can subsequently pass different index values to calculate the</span>
<span class="sd">    derivatives with respect to multiple inputs.</span>

<span class="sd">    The following example shows that everything works well for more complex</span>
<span class="sd">    single layer networks also (we checked the results manually using a</span>
<span class="sd">    spreadsheet program):</span>

<span class="sd">    &gt;&gt;&gt; ann.nmb_inputs = 3</span>
<span class="sd">    &gt;&gt;&gt; ann.nmb_neurons = (4,)</span>
<span class="sd">    &gt;&gt;&gt; ann.nmb_outputs = 2</span>
<span class="sd">    &gt;&gt;&gt; ann.weights_input = [[ 0.2, -0.1, -1.7,  0.6],</span>
<span class="sd">    ...                      [ 0.9,  0.2,  0.8,  0.0],</span>
<span class="sd">    ...                      [-0.5, -1.0,  2.3, -0.4]]</span>
<span class="sd">    &gt;&gt;&gt; ann.weights_output = [[ 0.0,  2.0],</span>
<span class="sd">    ...                       [-0.5,  1.0],</span>
<span class="sd">    ...                       [ 0.4,  2.4],</span>
<span class="sd">    ...                       [ 0.8, -0.9]]</span>
<span class="sd">    &gt;&gt;&gt; ann.intercepts_hidden = [ 0.9,  0.0, -0.4, -0.2]</span>
<span class="sd">    &gt;&gt;&gt; ann.intercepts_output = [ 1.3, -2.0]</span>
<span class="sd">    &gt;&gt;&gt; ann.inputs = [-0.1,  1.3,  1.6]</span>
<span class="sd">    &gt;&gt;&gt; ann.calculate_values()</span>
<span class="sd">    &gt;&gt;&gt; round_(ann.outputs)</span>
<span class="sd">    1.822222, 1.876983</span>

<span class="sd">    We again validate the calculated derivatives by comparison with numerical</span>
<span class="sd">    approximations:</span>

<span class="sd">    &gt;&gt;&gt; for idx_input in range(3):</span>
<span class="sd">    ...     ann.calculate_derivatives(idx_input)</span>
<span class="sd">    ...     round_(ann.output_derivatives)</span>
<span class="sd">    0.099449, -0.103039</span>
<span class="sd">    -0.01303, 0.365739</span>
<span class="sd">    0.027041, -0.203965</span>

<span class="sd">    &gt;&gt;&gt; d_input = 1e-8</span>
<span class="sd">    &gt;&gt;&gt; for idx_input in range(3):</span>
<span class="sd">    ...     input_ = ann.inputs[idx_input]</span>
<span class="sd">    ...     ann.inputs[idx_input] = input_-d_input/2.0</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     values0 = ann.outputs.copy()</span>
<span class="sd">    ...     ann.inputs[idx_input] = input_+d_input/2.0</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     values1 = ann.outputs.copy()</span>
<span class="sd">    ...     ann.inputs[idx_input] = input_</span>
<span class="sd">    ...     round_((values1-values0)/d_input)</span>
<span class="sd">    0.099449, -0.103039</span>
<span class="sd">    -0.01303, 0.365739</span>
<span class="sd">    0.027041, -0.203965</span>

<span class="sd">    The next example shows how to solve the XOR problem with a two-layer</span>
<span class="sd">    network.  As usual, `1` stands for `True` and `0` stands for `False`.</span>

<span class="sd">    We define a network with two inputs (`I1` and `I2`), two neurons in</span>
<span class="sd">    the first hidden layer (`H11` and `H12`), one neuron in the second</span>
<span class="sd">    hidden layer (`H2`), and a single output (`O1`):</span>

<span class="sd">    &gt;&gt;&gt; ann.nmb_inputs = 2</span>
<span class="sd">    &gt;&gt;&gt; ann.nmb_neurons = (2, 1)</span>
<span class="sd">    &gt;&gt;&gt; ann.nmb_outputs = 1</span>

<span class="sd">    The value of `O1` shall be identical with the activation of `H2`:</span>

<span class="sd">    &gt;&gt;&gt; ann.weights_output = 1.0</span>
<span class="sd">    &gt;&gt;&gt; ann.intercepts_output = 0.0</span>

<span class="sd">    We set all intercepts of the neurons of the hidden layer to 750</span>
<span class="sd">    (and initialise unnecessary matrix entries with &quot;nan&quot; to avoid</span>
<span class="sd">    confusion). Therefore, an input of 500 or 1000 results in an</span>
<span class="sd">    activation state of approximately zero or one, respectively. :</span>

<span class="sd">    &gt;&gt;&gt; ann.intercepts_hidden = [[-750.0, -750.0],</span>
<span class="sd">    ...                          [-750.0, nan]]</span>

<span class="sd">    The weighting factor between both inputs and `H11` is 1000.</span>
<span class="sd">    Hence, one `True` input is sufficient to activate `H1`.  In contrast,</span>
<span class="sd">    the weighting factor between both inputs and `H12` is 500.</span>
<span class="sd">    Hence, two `True` inputs are required to activate `H12`:</span>

<span class="sd">    &gt;&gt;&gt; ann.weights_input= [[1000.0, 500.0],</span>
<span class="sd">    ...                     [1000.0, 500.0]]</span>

<span class="sd">    The weighting factor between `H11` and `H2` is 1000.  Hence, in</span>
<span class="sd">    principle, `H11` can activate `H2`.  However, the weighting factor</span>
<span class="sd">    between `H12` and `H2` is -1000.  Hence, `H12` prevents `H2` from</span>
<span class="sd">    becoming activated even when `H11` is activated:</span>

<span class="sd">    &gt;&gt;&gt; ann.weights_hidden= [[[1000.0],</span>
<span class="sd">    ...                      [-1000.0]]]</span>

<span class="sd">    To recapitulate, `H11` determines if at least one input is `True`,</span>
<span class="sd">    `H12` determines if both inputs are `True`, and `H2` determines if</span>
<span class="sd">    precisely  one input is `True`, which is the solution for the XOR-problem:</span>

<span class="sd">    &gt;&gt;&gt; ann</span>
<span class="sd">    ann(</span>
<span class="sd">        nmb_inputs=2,</span>
<span class="sd">        nmb_neurons=(2, 1),</span>
<span class="sd">        weights_input=[[1000.0, 500.0],</span>
<span class="sd">                       [1000.0, 500.0]],</span>
<span class="sd">        weights_hidden=[[[1000.0],</span>
<span class="sd">                         [-1000.0]]],</span>
<span class="sd">        weights_output=[[1.0]],</span>
<span class="sd">        intercepts_hidden=[[-750.0, -750.0],</span>
<span class="sd">                           [-750.0, nan]],</span>
<span class="sd">        intercepts_output=[0.0],</span>
<span class="sd">    )</span>

<span class="sd">    The following calculation confirms the proper configuration of our network:</span>

<span class="sd">    &gt;&gt;&gt; for inputs in ((0.0, 0.0),</span>
<span class="sd">    ...                (1.0, 0.0),</span>
<span class="sd">    ...                (0.0, 1.0),</span>
<span class="sd">    ...                (1.0, 1.0)):</span>
<span class="sd">    ...    ann.inputs = inputs</span>
<span class="sd">    ...    ann.calculate_values()</span>
<span class="sd">    ...    round_([inputs[0], inputs[1], ann.outputs[0]])</span>
<span class="sd">    0.0, 0.0, 0.0</span>
<span class="sd">    1.0, 0.0, 1.0</span>
<span class="sd">    0.0, 1.0, 1.0</span>
<span class="sd">    1.0, 1.0, 0.0</span>

<span class="sd">    To elaborate on the last calculation, we show the corresponding</span>
<span class="sd">    activations of the hidden neurons. As both inputs are `True`, both</span>
<span class="sd">    `H12` (upper left value) and `H22` (upper right value) are activated,</span>
<span class="sd">    but `H2` (lower left value) is not:</span>

<span class="sd">    &gt;&gt;&gt; ann.neurons</span>
<span class="sd">    array([[ 1.,  1.],</span>
<span class="sd">           [ 0.,  0.]])</span>

<span class="sd">    Due to sharp response function, the derivatives with respect to both</span>
<span class="sd">    inputs are approximately zero:</span>

<span class="sd">    &gt;&gt;&gt; for inputs in ((0.0, 0.0),</span>
<span class="sd">    ...                (1.0, 0.0),</span>
<span class="sd">    ...                (0.0, 1.0),</span>
<span class="sd">    ...                (1.0, 1.0)):</span>
<span class="sd">    ...    ann.inputs = inputs</span>
<span class="sd">    ...    ann.calculate_values()</span>
<span class="sd">    ...    ann.calculate_derivatives(0)</span>
<span class="sd">    ...    round_([inputs[0], inputs[1], ann.output_derivatives[0]])</span>
<span class="sd">    0.0, 0.0, 0.0</span>
<span class="sd">    1.0, 0.0, 0.0</span>
<span class="sd">    0.0, 1.0, 0.0</span>
<span class="sd">    1.0, 1.0, 0.0</span>

<span class="sd">    To better validate the calculation of derivatives for multi-layer</span>
<span class="sd">    networks, we decrease the weights (and, accordingly, the intercepts)</span>
<span class="sd">    of our network, making its response more smooth:</span>

<span class="sd">    &gt;&gt;&gt; ann(nmb_inputs=2,</span>
<span class="sd">    ...     nmb_neurons=(2, 1),</span>
<span class="sd">    ...     nmb_outputs=1,</span>
<span class="sd">    ...     weights_input=[[10.0, 5.0],</span>
<span class="sd">    ...                    [10.0, 5.0]],</span>
<span class="sd">    ...     weights_hidden=[[[10.0],</span>
<span class="sd">    ...                      [-10.0]]],</span>
<span class="sd">    ...     weights_output=[[1.0]],</span>
<span class="sd">    ...     intercepts_hidden=[[-7.5, -7.5],</span>
<span class="sd">    ...                        [-7.5, nan]],</span>
<span class="sd">    ...     intercepts_output=[0.0])</span>

<span class="sd">    The results of method |anntools.ANN.calculate_derivatives| again agree</span>
<span class="sd">    with those of the finite difference approximation:</span>

<span class="sd">    &gt;&gt;&gt; for inputs in ((0.0, 0.0),</span>
<span class="sd">    ...                (1.0, 0.0),</span>
<span class="sd">    ...                (0.0, 1.0),</span>
<span class="sd">    ...                (1.0, 1.0)):</span>
<span class="sd">    ...     ann.inputs = inputs</span>
<span class="sd">    ...     ann.calculate_values()</span>
<span class="sd">    ...     ann.calculate_derivatives(0)</span>
<span class="sd">    ...     derivative1 = ann.output_derivatives[0]</span>
<span class="sd">    ...     ann.calculate_derivatives(1)</span>
<span class="sd">    ...     derivative2 = ann.output_derivatives[0]</span>
<span class="sd">    ...     round_([inputs[0], inputs[1], derivative1, derivative2])</span>
<span class="sd">    0.0, 0.0, 0.000015, 0.000015</span>
<span class="sd">    1.0, 0.0, 0.694609, 0.694609</span>
<span class="sd">    0.0, 1.0, 0.694609, 0.694609</span>
<span class="sd">    1.0, 1.0, -0.004129, -0.004129</span>

<span class="sd">    &gt;&gt;&gt; d_input = 1e-8</span>
<span class="sd">    &gt;&gt;&gt; for inputs in ((0.0, 0.0),</span>
<span class="sd">    ...                (1.0, 0.0),</span>
<span class="sd">    ...                (0.0, 1.0),</span>
<span class="sd">    ...                (1.0, 1.0)):</span>
<span class="sd">    ...     derivatives = []</span>
<span class="sd">    ...     for idx_input in range(2):</span>
<span class="sd">    ...         ann.inputs = inputs</span>
<span class="sd">    ...         ann.inputs[idx_input] = inputs[idx_input]-d_input/2.0</span>
<span class="sd">    ...         ann.calculate_values()</span>
<span class="sd">    ...         value0 = ann.outputs[0]</span>
<span class="sd">    ...         ann.inputs[idx_input] = inputs[idx_input]+d_input/2.0</span>
<span class="sd">    ...         ann.calculate_values()</span>
<span class="sd">    ...         value1 = ann.outputs[0]</span>
<span class="sd">    ...         derivatives.append((value1-value0)/d_input)</span>
<span class="sd">    ...     round_([inputs[0], inputs[1]] + derivatives)</span>
<span class="sd">    0.0, 0.0, 0.000015, 0.000015</span>
<span class="sd">    1.0, 0.0, 0.694609, 0.694609</span>
<span class="sd">    0.0, 1.0, 0.694609, 0.694609</span>
<span class="sd">    1.0, 1.0, -0.004129, -0.004129</span>

<span class="sd">    Note that Python class |anntools.ANN| handles a corresponding Cython</span>
<span class="sd">    extension class defined in |annutils|, which does not protect itself</span>
<span class="sd">    against segmentation faults. But class  |anntools.ANN| takes up this</span>
<span class="sd">    task, meaning using its public members should always result in readable</span>
<span class="sd">    exceptions instead of program crashes, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; ANN(None).nmb_layers</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Attribute `nmb_layers` \</span>
<span class="sd">of object `ann` is not usable so far.  At least, you have to prepare \</span>
<span class="sd">attribute `nmb_inputs` first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NDIM</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">TYPE</span> <span class="o">=</span> <span class="s2">&quot;annutils.ANN&quot;</span>
    <span class="n">TIME</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">SPAN</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subvars</span><span class="p">:</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">SubParameters</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subvars</span> <span class="o">=</span> <span class="n">subvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subpars</span> <span class="o">=</span> <span class="n">subvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">FastAccessParameter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span> <span class="o">=</span> <span class="n">annutils</span><span class="o">.</span><span class="n">ANN</span><span class="p">()</span>
        <span class="n">_ANNArrayProperty</span><span class="o">.</span><span class="n">add_cann</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__hydpy__connect_variable2subgroup__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Connect the actual |anntools.ANN| object with the given</span>
<span class="sd">        |SubParameters| object.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpars</span><span class="o">.</span><span class="n">fastaccess</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nmb_inputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">nmb_neurons</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
        <span class="n">nmb_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">weights_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_hidden</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">intercepts_hidden</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">intercepts_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span> <span class="o">=</span> <span class="n">nmb_inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span> <span class="o">=</span> <span class="n">nmb_outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span> <span class="o">=</span> <span class="n">nmb_neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_input</span> <span class="o">=</span> <span class="n">weights_input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_hidden</span> <span class="o">=</span> <span class="n">weights_hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_output</span> <span class="o">=</span> <span class="n">weights_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_hidden</span> <span class="o">=</span> <span class="n">intercepts_hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_output</span> <span class="o">=</span> <span class="n">intercepts_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_derivatives</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_derivatives</span>

    <span class="k">def</span> <span class="nf">__update_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__protectedproperties</span><span class="o">.</span><span class="n">allready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_input</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_hidden</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_output</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_hidden</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_output</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_derivatives</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_derivatives</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span>
    <span class="k">def</span> <span class="nf">nmb_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># pylint: disable=method-hidden</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of input nodes.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_inputs</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_inputs = 3</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_inputs</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_inputs</span>

    <span class="nd">@nmb_inputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nmb_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_inputs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update_shapes</span><span class="p">()</span>

    <span class="nd">@nmb_inputs</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">nmb_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span>
    <span class="k">def</span> <span class="nf">nmb_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># pylint: disable=method-hidden</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of output nodes.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_outputs</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_outputs = 2</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_outputs</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; del ann.nmb_outputs</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_outputs</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `nmb_outputs` \</span>
<span class="sd">of object `ann` has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_outputs</span>

    <span class="nd">@nmb_outputs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nmb_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pylint: disable=missing-docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_outputs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update_shapes</span><span class="p">()</span>

    <span class="nd">@nmb_outputs</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">nmb_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span>
    <span class="k">def</span> <span class="nf">nmb_neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>  <span class="c1"># pylint: disable=method-hidden</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of neurons of the hidden layers.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_neurons</span>
<span class="sd">        (2, 1)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_neurons = (3,)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_neurons</span>
<span class="sd">        (3,)</span>
<span class="sd">        &gt;&gt;&gt; del ann.nmb_neurons</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_neurons</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `nmb_neurons` \</span>
<span class="sd">of object `ann` has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">))</span>

    <span class="nd">@nmb_neurons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nmb_neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pylint: disable=missing-docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_neurons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_layers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update_shapes</span><span class="p">()</span>

    <span class="nd">@nmb_neurons</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">nmb_neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="n">__protectedproperties</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">ProtectedProperties</span><span class="p">(</span>
        <span class="n">nmb_inputs</span><span class="p">,</span> <span class="n">nmb_outputs</span><span class="p">,</span> <span class="n">nmb_neurons</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_weights_input</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of input weights.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=3, nmb_neurons=(2, 1), nmb_outputs=1)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_weights_input</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_weights_input</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the input weights.</span>

<span class="sd">        The first integer value is the number of input nodes; the second</span>
<span class="sd">        integer value is the number of neurons of the first hidden layer:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=3, nmb_neurons=(2, 1), nmb_outputs=1)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_weights_input</span>
<span class="sd">        (3, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">weights_input</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The weights between all input nodes and neurons of the first </span>
<span class="s2">        hidden layer.</span>
<span class="s2">        </span>
<span class="s2">        The &quot;weight properties&quot; of class |anntools.ANN| are usable as </span>
<span class="s2">        explained in-depth for the input weights below. </span>
<span class="s2">    </span>
<span class="s2">        The input nodes and the neurons vary on the first axis and the</span>
<span class="s2">        second axis of the 2-dimensional array, respectively (see property </span>
<span class="s2">        |anntools.ANN.shape_weights_input|):</span>

<span class="s2">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="s2">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="s2">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(3,))</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        array([[ 0.,  0.,  0.],</span>
<span class="s2">               [ 0.,  0.,  0.]])</span>
<span class="s2">        </span>
<span class="s2">        The following error occurs when either the number of input nodes or </span>
<span class="s2">        of hidden neurons is unknown:</span>
<span class="s2">        </span>
<span class="s2">        &gt;&gt;&gt; del ann.nmb_inputs</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">        ...</span>
<span class="s2">        hydpy.core.exceptiontools.AttributeNotReady: Attribute </span><span class="se">\</span>
<span class="s2">`weights_input` of object `ann` is not usable so far.  At least, </span><span class="se">\</span>
<span class="s2">you have to prepare attribute `nmb_inputs` first.</span>
<span class="s2">        &gt;&gt;&gt; ann.nmb_inputs = 2</span>

<span class="s2">        It is allowed to set values via slicing:</span>
<span class="s2">        </span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input[:, 0] = 1.</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        array([[ 1.,  0.,  0.],</span>
<span class="s2">               [ 1.,  0.,  0.]])</span>

<span class="s2">        If possible, property |anntools.ANN.weights_input| performs type </span>
<span class="s2">        conversions:</span>

<span class="s2">        &gt;&gt;&gt; ann.weights_input = &quot;2&quot;</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        array([[ 2.,  2.,  2.],</span>
<span class="s2">               [ 2.,  2.,  2.]])</span>

<span class="s2">        One can assign whole matrices directly:</span>

<span class="s2">        &gt;&gt;&gt; import numpy</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input = numpy.eye(2, 3)</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        array([[ 1.,  0.,  0.],</span>
<span class="s2">               [ 0.,  1.,  0.]])</span>

<span class="s2">        One can also delete the values contained in the array:</span>

<span class="s2">        &gt;&gt;&gt; del ann.weights_input</span>
<span class="s2">        &gt;&gt;&gt; ann.weights_input</span>
<span class="s2">        array([[ 0.,  0.,  0.],</span>
<span class="s2">               [ 0.,  0.,  0.]])</span>

<span class="s2">        Errors like wrong shapes (or unconvertible inputs) result in error</span>
<span class="s2">        messages:</span>

<span class="s2">        &gt;&gt;&gt; ann.weights_input = numpy.eye(3)</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">        ...</span>
<span class="s2">        ValueError: While trying to set the input weights of the artificial </span><span class="se">\</span>
<span class="s2">neural network `ann` of element `?`, the following error occurred: could not </span><span class="se">\</span>
<span class="s2">broadcast input array from shape (3,3) into shape (2,3)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_weights_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the output weights.</span>

<span class="sd">        The first integer value is the number of neurons of the first hidden</span>
<span class="sd">        layer; the second integer value is the number of output nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_weights_output</span>
<span class="sd">        (1, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_weights_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of output weights.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 4), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_weights_output</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span>

    <span class="n">weights_output</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The weights between all neurons of the last hidden layer and </span>
<span class="s2">        the output nodes.</span>

<span class="s2">        See the documentation on properties |anntools.ANN.shape_weights_output|</span>
<span class="s2">        and |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_weights_hidden</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the activation of the hidden</span>
<span class="sd">        neurons.</span>

<span class="sd">        The first integer value is the number of connection between the</span>
<span class="sd">        hidden layers. The second integer value is the maximum number of</span>
<span class="sd">        neurons of all hidden layers feeding information into another</span>
<span class="sd">        hidden layer (all except the last one). The third integer</span>
<span class="sd">        value is the maximum number of the neurons of all hidden layers</span>
<span class="sd">        receiving information from another hidden layer (all except the</span>
<span class="sd">        first one):</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=6, nmb_neurons=(4, 3, 2), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_weights_hidden</span>
<span class="sd">        (2, 4, 3)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=6, nmb_neurons=(4,), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_weights_hidden</span>
<span class="sd">        (0, 0, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nmb_neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">nmb_neurons</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_weights_hidden</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of hidden weights.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(4, 3, 2), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_weights_hidden</span>
<span class="sd">        18</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nmb</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx_layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nmb</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="n">idx_layer</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">[</span><span class="n">idx_layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nmb</span>

    <span class="n">weights_hidden</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The weights between the neurons of the different hidden layers.</span>

<span class="s2">        See the documentation on properties |anntools.ANN.shape_weights_hidden|</span>
<span class="s2">        and |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_intercepts_hidden</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the intercepts of neurons of</span>
<span class="sd">        the hidden layers.</span>

<span class="sd">        The first integer value is to the number of hidden layers;</span>
<span class="sd">        the second integer value is the maximum number of neurons of</span>
<span class="sd">        all hidden layers:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=6, nmb_neurons=(4, 3, 2), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_intercepts_hidden</span>
<span class="sd">        (3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_intercepts_hidden</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of input intercepts.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="p">)</span>

    <span class="n">intercepts_hidden</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The intercepts of all neurons of the hidden layers.</span>

<span class="s2">        See the documentation on properties </span>
<span class="s2">        |anntools.ANN.shape_intercepts_hidden| and </span>
<span class="s2">        |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_intercepts_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the intercepts of neurons of</span>
<span class="sd">        the hidden layers.</span>

<span class="sd">        The only integer value is the number of output nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_intercepts_output</span>
<span class="sd">        (3,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_intercepts_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of output intercepts.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_intercepts_output</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span>

    <span class="n">intercepts_output</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The intercepts of all output nodes.</span>

<span class="s2">        See the documentation on properties </span>
<span class="s2">        |anntools.ANN.shape_intercepts_output| and </span>
<span class="s2">        |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array defining the activation function for each</span>
<span class="sd">        neuron of the hidden layers.</span>

<span class="sd">        The first integer value is to the number of hidden layers;</span>
<span class="sd">        the second integer value is the maximum number of neurons of</span>
<span class="sd">        all hidden layers:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=6, nmb_neurons=(4, 3, 2), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_activation</span>
<span class="sd">        (3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span>

    <span class="n">activation</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Indices for selecting suitable activation functions for the</span>
<span class="s2">        neurons of the hidden layers.</span>
<span class="s2">        </span>
<span class="s2">        By default, |anntools.ANN| uses the logistic function for calculating </span>
<span class="s2">        the activation of the neurons of the hidden layers and uses the </span>
<span class="s2">        identity function for the output nodes.  However, property </span>
<span class="s2">        |anntools.ANN.activation| allows defining other activation functions </span>
<span class="s2">        for the hidden neurons individually.  So far, one can select the</span>
<span class="s2">        identity function and a &quot;filter version&quot; of the logistic function</span>
<span class="s2">        as alternatives -- others might follow. </span>
<span class="s2">        </span>
<span class="s2">        Assume a neuron receives input :math:`i_1` and :math:`i_2` from </span>
<span class="s2">        two nodes of the input layer or its upstream hidden layer.  We </span>
<span class="s2">        weight these input values as usual:</span>
<span class="s2">        </span>
<span class="s2">            :math:`x_1 = c + w_1 </span><span class="se">\\</span><span class="s2">cdot i_1 + w_2 </span><span class="se">\\</span><span class="s2">cdot i_2`</span>
<span class="s2">        </span>
<span class="s2">        When selecting the identity function through setting the index value </span>
<span class="s2">        &quot;0&quot;, the activation of the considered neuron is:</span>
<span class="s2">            </span>
<span class="s2">            :math:`a_1 = x_1`</span>
<span class="s2">        </span>
<span class="s2">        Using the identity function is helpful for educational examples</span>
<span class="s2">        and for bypassing input through one layer without introducing</span>
<span class="s2">        nonlinearity.</span>
<span class="s2">        </span>
<span class="s2">        When selecting the logistic function through setting the index value </span>
<span class="s2">        &quot;1&quot;, the activation of the considered neuron is:</span>
<span class="s2">        </span>
<span class="s2">            :math:`a_1 = 1-</span><span class="se">\\</span><span class="s2">frac</span><span class="si">{1}</span><span class="s2">{1+exp(x_1)}`</span>
<span class="s2">        </span>
<span class="s2">        The logistic function is a standard function for constructing neural </span>
<span class="s2">        networks.  It allows to approximate any relationship within a specific </span>
<span class="s2">        range and accuracy, provided the neural network is large enough.</span>
<span class="s2">        </span>
<span class="s2">        When selecting the &quot;filter version&quot; of the logistic function through </span>
<span class="s2">        setting the index value &quot;2&quot;, the activation of the considered neuron </span>
<span class="s2">        is:</span>
<span class="s2">        </span>
<span class="s2">            :math:`a_1 = 1-</span><span class="se">\\</span><span class="s2">frac</span><span class="si">{1}</span><span class="s2">{1+exp(x_1)} </span><span class="se">\\</span><span class="s2">cdot i_1`</span>
<span class="s2">            </span>
<span class="s2">        &quot;Filter version&quot; means that our neuron now filters the input of the </span>
<span class="s2">        single input node placed at the corresponding position of its layer.  </span>
<span class="s2">        This activation function helps force the output of a neural network </span>
<span class="s2">        to be zero but never negative beyond a certain threshold.          </span>
<span class="s2">        </span>
<span class="s2">        Similar to the main documentation on class |anntools.ANN|, we define </span>
<span class="s2">        a relatively complex network to show that both the &quot;normal&quot; and</span>
<span class="s2">        the derivative calculations work.  This time, we set the activation</span>
<span class="s2">        function explicitly.  &quot;1&quot; stands for the logistic function, which</span>
<span class="s2">        we first use for all hidden neurons:</span>
<span class="s2">        </span>
<span class="s2">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN</span>
<span class="s2">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="s2">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="s2">        &gt;&gt;&gt; ann(nmb_inputs=2,</span>
<span class="s2">        ...     nmb_neurons=(2, 2),</span>
<span class="s2">        ...     nmb_outputs=2,</span>
<span class="s2">        ...     weights_input=[[0.2, -0.1],</span>
<span class="s2">        ...                    [-1.7, 0.6]],</span>
<span class="s2">        ...     weights_hidden=[[[-.5, 1.0],</span>
<span class="s2">        ...                      [0.4, 2.4]]],</span>
<span class="s2">        ...     weights_output=[[0.8, -0.9],</span>
<span class="s2">        ...                     [0.5, -0.4]],</span>
<span class="s2">        ...     intercepts_hidden=[[0.9, 0.0],</span>
<span class="s2">        ...                        [-0.4, -0.2]],</span>
<span class="s2">        ...     intercepts_output=[1.3, -2.0],</span>
<span class="s2">        ...     activation=[[1, 1],</span>
<span class="s2">        ...                 [1, 1]])    </span>
<span class="s2">        &gt;&gt;&gt; ann.inputs = -0.1,  1.3</span>
<span class="s2">        &gt;&gt;&gt; ann.calculate_values()</span>
<span class="s2">        &gt;&gt;&gt; round_(ann.outputs)</span>
<span class="s2">        2.074427, -2.734692</span>
<span class="s2">        &gt;&gt;&gt; for idx_input in range(2):</span>
<span class="s2">        ...     ann.calculate_derivatives(idx_input)</span>
<span class="s2">        ...     round_(ann.output_derivatives)</span>
<span class="s2">        -0.006199, 0.006571</span>
<span class="s2">        0.039804, -0.044169</span>
<span class="s2">        </span>
<span class="s2">        In the next example, we want to apply the identity function for the</span>
<span class="s2">        second neuron of the first hidden layer and the first neuron of the</span>
<span class="s2">        second hidden layer.  Therefore, we pass its index value &quot;0&quot; to the </span>
<span class="s2">        corresponding |anntools.ANN.activation| entries:</span>
<span class="s2">        </span>
<span class="s2">        &gt;&gt;&gt; ann.activation = [[1, 0], [0, 1]]</span>
<span class="s2">        &gt;&gt;&gt; ann</span>
<span class="s2">        ann(</span>
<span class="s2">            nmb_inputs=2,</span>
<span class="s2">            nmb_neurons=(2, 2),</span>
<span class="s2">            nmb_outputs=2,</span>
<span class="s2">            weights_input=[[0.2, -0.1],</span>
<span class="s2">                           [-1.7, 0.6]],</span>
<span class="s2">            weights_hidden=[[[-0.5, 1.0],</span>
<span class="s2">                             [0.4, 2.4]]],</span>
<span class="s2">            weights_output=[[0.8, -0.9],</span>
<span class="s2">                            [0.5, -0.4]],</span>
<span class="s2">            intercepts_hidden=[[0.9, 0.0],</span>
<span class="s2">                               [-0.4, -0.2]],</span>
<span class="s2">            intercepts_output=[1.3, -2.0],</span>
<span class="s2">            activation=[[1, 0],</span>
<span class="s2">                        [0, 1]],</span>
<span class="s2">        )</span>
<span class="s2">        </span>
<span class="s2">        The agreement between the analytical and the numerical derivatives </span>
<span class="s2">        gives us confidence everything works fine:</span>
<span class="s2">             </span>
<span class="s2">        &gt;&gt;&gt; ann.calculate_values()</span>
<span class="s2">        &gt;&gt;&gt; round_(ann.outputs)</span>
<span class="s2">        1.584373, -2.178468</span>
<span class="s2">        &gt;&gt;&gt; for idx_input in range(2):</span>
<span class="s2">        ...     ann.calculate_derivatives(idx_input)</span>
<span class="s2">        ...     round_(ann.output_derivatives)</span>
<span class="s2">        -0.056898, 0.060219</span>
<span class="s2">        0.369807, -0.394801</span>
<span class="s2">        &gt;&gt;&gt; d_input = 1e-8</span>
<span class="s2">        &gt;&gt;&gt; for idx_input in range(2):</span>
<span class="s2">        ...     input_ = ann.inputs[idx_input]</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_-d_input/2.0</span>
<span class="s2">        ...     ann.calculate_values()</span>
<span class="s2">        ...     values0 = ann.outputs.copy()</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_+d_input/2.0</span>
<span class="s2">        ...     ann.calculate_values()</span>
<span class="s2">        ...     values1 = ann.outputs.copy()</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_</span>
<span class="s2">        ...     round_((values1-values0)/d_input)</span>
<span class="s2">        -0.056898, 0.060219</span>
<span class="s2">        0.369807, -0.394801</span>
<span class="s2">        </span>
<span class="s2">        Finally, we perform the same check for the &quot;filter version&quot; of the</span>
<span class="s2">        logistic function:</span>
<span class="s2">        </span>
<span class="s2">        &gt;&gt;&gt; ann.activation = [[1, 2], [2, 1]]</span>
<span class="s2">        &gt;&gt;&gt; ann.calculate_values()</span>
<span class="s2">        &gt;&gt;&gt; round_(ann.outputs)</span>
<span class="s2">        1.825606, -2.445682</span>
<span class="s2">        &gt;&gt;&gt; for idx_input in range(2):</span>
<span class="s2">        ...     ann.calculate_derivatives(idx_input)</span>
<span class="s2">        ...     round_(ann.output_derivatives)</span>
<span class="s2">        0.009532, -0.011236</span>
<span class="s2">        -0.001715, 0.02872</span>
<span class="s2">        &gt;&gt;&gt; d_input = 1e-8</span>
<span class="s2">        &gt;&gt;&gt; for idx_input in range(2):</span>
<span class="s2">        ...     input_ = ann.inputs[idx_input]</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_-d_input/2.0</span>
<span class="s2">        ...     ann.calculate_values()</span>
<span class="s2">        ...     values0 = ann.outputs.copy()</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_+d_input/2.0</span>
<span class="s2">        ...     ann.calculate_values()</span>
<span class="s2">        ...     values1 = ann.outputs.copy()</span>
<span class="s2">        ...     ann.inputs[idx_input] = input_</span>
<span class="s2">        ...     round_((values1-values0)/d_input)</span>
<span class="s2">        0.009532, -0.011236</span>
<span class="s2">        -0.001715, 0.02872</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the input values.</span>

<span class="sd">        The only integer value is the number of input nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=5, nmb_neurons=(2, 1), nmb_outputs=2)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_inputs</span>
<span class="sd">        (5,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="p">,)</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The values of the input nodes.</span>

<span class="s2">        See the documentation on properties |anntools.ANN.shape_inputs|</span>
<span class="s2">        and |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the output values.</span>

<span class="sd">        The only integer value is the number of output nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_outputs</span>
<span class="sd">        (6,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="p">,)</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The values of the output nodes.</span>

<span class="s2">        See the documentation on properties |anntools.ANN.shape_outputs|</span>
<span class="s2">        and |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_output_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the output derivatives.</span>

<span class="sd">        The only integer value is the number of output nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_output_derivatives</span>
<span class="sd">        (6,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="p">,)</span>

    <span class="n">output_derivatives</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The derivatives of the output nodes.</span>

<span class="s2">        See the documentation on properties </span>
<span class="s2">        |anntools.ANN.shape_output_derivatives| and </span>
<span class="s2">        |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">nmb_layers</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">DependentProperty</span><span class="p">(</span><span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">)</span>

    <span class="nd">@nmb_layers</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">nmb_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of hidden layers.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(2, 1), nmb_outputs=3)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_layers</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">nmb_layers</span>

    <span class="n">shape_neurons</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">DependentProperty</span><span class="p">(</span><span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">)</span>

    <span class="nd">@shape_neurons</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">shape_neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the activities of the neurons</span>
<span class="sd">        of the hidden layers.</span>

<span class="sd">        The first integer value is the number of hidden layers; the</span>
<span class="sd">        second integer value is the maximum number of neurons of all</span>
<span class="sd">        hidden layers:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(4, 3, 2), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_neurons</span>
<span class="sd">        (3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span>

    <span class="n">neurons</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The derivatives of the activation of the neurons of the </span>
<span class="s2">        hidden layers.</span>

<span class="s2">        See the documentation on properties |anntools.ANN.shape_neurons|</span>
<span class="s2">        and |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">shape_neuron_derivatives</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">DependentProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span>
    <span class="p">)</span>

    <span class="nd">@shape_neuron_derivatives</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">shape_neuron_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The shape of the array containing the derivatives of the activities</span>
<span class="sd">        of the neurons of the hidden layers.</span>

<span class="sd">        The first integer value is the number of hidden layers; the</span>
<span class="sd">        second integer value is the maximum number of neurons of all</span>
<span class="sd">        hidden layers:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(4, 3, 2), nmb_outputs=6)</span>
<span class="sd">        &gt;&gt;&gt; ann.shape_neuron_derivatives</span>
<span class="sd">        (3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_nmb_neurons</span>

    <span class="n">neuron_derivatives</span> <span class="o">=</span> <span class="n">_ANNArrayProperty</span><span class="p">(</span>
        <span class="n">protected</span><span class="o">=</span><span class="n">__protectedproperties</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The derivatives of the activation of the neurons of the </span>
<span class="s2">        hidden layers.</span>

<span class="s2">        See the documentation on properties </span>
<span class="s2">        |anntools.ANN.shape_neuron_derivatives| and </span>
<span class="s2">        |anntools.ANN.weights_input| for further information.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="ANN.calculate_values"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN.calculate_values">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the network output values based on the input values</span>
<span class="sd">        defined previously.</span>

<span class="sd">        For more information, see the documentation on class |anntools.ANN|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="ANN.calculate_derivatives"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN.calculate_derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_input</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the derivatives of the network output values with</span>
<span class="sd">        respect to the input value of the given index.</span>

<span class="sd">        For more information, see the documentation on class |anntools.ANN|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cann</span><span class="o">.</span><span class="n">calculate_derivatives</span><span class="p">(</span><span class="n">idx_input</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of all input, inner, and output weights.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=1, nmb_neurons=(2, 3), nmb_outputs=4)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_weights</span>
<span class="sd">        20</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nmb_weights_input</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_weights_hidden</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_weights_output</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_intercepts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The number of all inner and output intercepts.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=1, nmb_neurons=(2, 3), nmb_outputs=4)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_intercepts</span>
<span class="sd">        9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_intercepts_hidden</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_intercepts_output</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;The sum of |anntools.ANN.nmb_weights| and</span>
<span class="sd">        |anntools.ANN.nmb_intercepts|.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ann = ANN(None)</span>
<span class="sd">        &gt;&gt;&gt; ann(nmb_inputs=1, nmb_neurons=(2, 3), nmb_outputs=4)</span>
<span class="sd">        &gt;&gt;&gt; ann.nmb_parameters</span>
<span class="sd">        29</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_weights</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_intercepts</span>

<div class="viewcode-block" id="ANN.verify"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="sd">&quot;&quot;&quot;Raise a |RuntimeError| if the network&#39;s shape is not defined</span>
<span class="sd">        completely.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import ANN</span>
<span class="sd">        &gt;&gt;&gt; ANN(None).verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The shape of the the artificial neural network \</span>
<span class="sd">parameter `ann` of element `?` has not been defined so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__protectedproperties</span><span class="o">.</span><span class="n">allready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The shape of the the artificial neural network &quot;</span>
                <span class="s2">&quot;parameter </span><span class="si">%s</span><span class="s2"> has not been defined so far.&quot;</span>
                <span class="o">%</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ANN.assignrepr"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN.assignrepr">[docs]</a>    <span class="k">def</span> <span class="nf">assignrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the actual |anntools.ANN| object</span>
<span class="sd">        prefixed with the given string.&quot;&quot;&quot;</span>
        <span class="n">blanks</span> <span class="o">=</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">nmb_inputs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">nmb_neurons=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_neurons</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">nmb_outputs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights_input</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">weights_input=&quot;</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_layers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list3</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weights_hidden</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">weights_hidden=&quot;</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
            <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights_output</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">weights_output=&quot;</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
        <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_hidden</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">intercepts_hidden=&quot;</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
        <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intercepts_output</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">intercepts_output=&quot;</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_list2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">activation=&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
            <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indent</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ANN.plot"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ANN.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">xmax</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">idx_input</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">idx_output</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot the relationship between a particular input (`idx_input`)</span>
<span class="sd">        and a particular output (`idx_output`) variable described by the</span>
<span class="sd">        actual |anntools.ANN| object.</span>

<span class="sd">        Define the lower and the upper bound of the x-axis via arguments</span>
<span class="sd">        `xmin` and `xmax`.  Modify the number of plotted points via</span>
<span class="sd">        argument `points`.  Pass additional `matplotlib` plotting arguments</span>
<span class="sd">        as keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unsubscriptable-object</span>
        <span class="c1"># pylint: disable=unsupported-assignment-operation</span>
        <span class="c1"># pylint is wrong about &quot;self.inputs&quot;</span>
        <span class="n">xs_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="n">ys_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xs_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x__</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs_</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">x__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">()</span>
            <span class="n">ys_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">idx_output</span><span class="p">]</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs_</span><span class="p">,</span> <span class="n">ys_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ann"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.ann">[docs]</a><span class="k">def</span> <span class="nf">ann</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ANN</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a new stand-alone |anntools.ANN| object with the given parameter</span>
<span class="sd">    values.</span>

<span class="sd">    The purpose of this function is to allow for string representations of</span>
<span class="sd">    parameters containing multiple |anntools.ANN| instances.</span>

<span class="sd">    When passing no arguments, the default values of class |anntools.ANN|</span>
<span class="sd">    apply:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import ann</span>
<span class="sd">    &gt;&gt;&gt; ann1 = ann()</span>
<span class="sd">    &gt;&gt;&gt; ann1</span>
<span class="sd">    ann(</span>
<span class="sd">        weights_input=[[0.0]],</span>
<span class="sd">        weights_output=[[0.0]],</span>
<span class="sd">        intercepts_hidden=[[0.0]],</span>
<span class="sd">        intercepts_output=[0.0],</span>
<span class="sd">    )</span>

<span class="sd">    Of course, you can change any parameter value:</span>

<span class="sd">    &gt;&gt;&gt; ann2 = ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...            weights_input=4.0, weights_output=3.0,</span>
<span class="sd">    ...            intercepts_hidden=-16.0, intercepts_output=-1.0)</span>
<span class="sd">    &gt;&gt;&gt; ann2</span>
<span class="sd">    ann(</span>
<span class="sd">        weights_input=[[4.0]],</span>
<span class="sd">        weights_output=[[3.0]],</span>
<span class="sd">        intercepts_hidden=[[-16.0]],</span>
<span class="sd">        intercepts_output=[-1.0],</span>
<span class="sd">    )</span>

<span class="sd">    The following line clarifies that we initialised two independent</span>
<span class="sd">    |anntools.ANN| objects (instead of changing the values of an existing</span>
<span class="sd">    |anntools.ANN| object vai its `call` method):</span>

<span class="sd">    &gt;&gt;&gt; ann1 is ann2</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_ann</span> <span class="o">=</span> <span class="n">ANN</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">new_ann</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_ann</span></div>


<div class="viewcode-block" id="SeasonalANN"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.SeasonalANN">[docs]</a><span class="k">class</span> <span class="nc">SeasonalANN</span><span class="p">(</span><span class="n">BaseANN</span><span class="p">):</span>
    <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
    <span class="sd">&quot;&quot;&quot;Handles relationships described by artificial neural networks that</span>
<span class="sd">    vary within an annual cycle.</span>

<span class="sd">    Class |anntools.SeasonalANN| is an alternative implementation of class</span>
<span class="sd">    |SeasonalParameter| specifically designed for handling multiple</span>
<span class="sd">    |anntools.ANN| objects that are valid for different times of the year,</span>
<span class="sd">    described by |TOY| objects.  The total output of a |anntools.SeasonalANN|</span>
<span class="sd">    object is a weighted mean of the output of one or two &quot;normal&quot; neural</span>
<span class="sd">    networks.  Property |anntools.SeasonalANN.ratios| provides the weights</span>
<span class="sd">    for the different times of the year.</span>

<span class="sd">    To explain this in more detail, we modify an example of the documentation</span>
<span class="sd">    on class.  let us define a |anntools.SeasonalANN| object that contains</span>
<span class="sd">    three &quot;normal&quot; networks for January, 1, March, 1, and July, 1,</span>
<span class="sd">    respectively:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import ann, pub, SeasonalANN</span>
<span class="sd">    &gt;&gt;&gt; pub.options.reprdigits = 6</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-10-01&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; seasonalann = SeasonalANN(None)</span>
<span class="sd">    &gt;&gt;&gt; seasonalann(</span>
<span class="sd">    ...     _1_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                 intercepts_hidden=0.0, intercepts_output=1.0),</span>
<span class="sd">    ...     _7_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=4.0, weights_output=3.0,</span>
<span class="sd">    ...                 intercepts_hidden=-16.0, intercepts_output=-1.0),</span>
<span class="sd">    ...     _3_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                 intercepts_hidden=0.0, intercepts_output=-1.0))</span>

<span class="sd">    The confusing time order in the initialization call above does not pose a</span>
<span class="sd">    problem, as class |anntools.SeasonalANN| performs time sorting internally:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann</span>
<span class="sd">    seasonalann(</span>
<span class="sd">        toy_1_1_12_0_0=ann(</span>
<span class="sd">            weights_input=[[0.0]],</span>
<span class="sd">            weights_output=[[0.0]],</span>
<span class="sd">            intercepts_hidden=[[0.0]],</span>
<span class="sd">            intercepts_output=[1.0],</span>
<span class="sd">        ),</span>
<span class="sd">        toy_3_1_12_0_0=ann(</span>
<span class="sd">            weights_input=[[0.0]],</span>
<span class="sd">            weights_output=[[0.0]],</span>
<span class="sd">            intercepts_hidden=[[0.0]],</span>
<span class="sd">            intercepts_output=[-1.0],</span>
<span class="sd">        ),</span>
<span class="sd">        toy_7_1_12_0_0=ann(</span>
<span class="sd">            weights_input=[[4.0]],</span>
<span class="sd">            weights_output=[[3.0]],</span>
<span class="sd">            intercepts_hidden=[[-16.0]],</span>
<span class="sd">            intercepts_output=[-1.0],</span>
<span class="sd">        ),</span>
<span class="sd">    )</span>

<span class="sd">    One can easily plot the resulting graphs of all networks:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.plot(0.0, 8.0)</span>

<span class="sd">    You can use the `pyplot` API of `matplotlib` to modify the figure</span>
<span class="sd">    or to save it to disk (or print it to the screen, in case the</span>
<span class="sd">    interactive mode of `matplotlib` is disabled):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import save_autofig</span>
<span class="sd">    &gt;&gt;&gt; save_autofig(&quot;SeasonalANN_plot.png&quot;)</span>

<span class="sd">    .. image:: SeasonalANN_plot.png</span>

<span class="sd">    The property |anntools.SeasonalANN.shape| does reflect the number of</span>
<span class="sd">    required weighting ratios for each time of year (in this example</span>
<span class="sd">    366 days per year) and each neural network (in this example three):</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.shape</span>
<span class="sd">    (366, 3)</span>

<span class="sd">    For safety reasons, |anntools.SeasonalANN.shape| should normally not</span>
<span class="sd">    be changed manually:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.shape = (366, 4)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: can&#39;t set attribute</span>

<span class="sd">    The following interactive plot shows the |anntools.SeasonalANN.ratios|</span>
<span class="sd">    used for weighting(note the missing values for October, November, and</span>
<span class="sd">    December, being not relevant for the initialisation period):</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from bokeh import plotting, models, palettes</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import docs</span>
<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; plotting.output_file(os.path.join(</span>
<span class="sd">        ...     docs.__path__[0], &quot;html_&quot;, &quot;anntools.SeasonalANN.ratios.html&quot;))</span>
<span class="sd">        &gt;&gt;&gt; hover = models.HoverTool(tooltips=[</span>
<span class="sd">        ...     (&quot;(x,y)&quot;, &quot;($x, $y)&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; plot = plotting.figure(toolbar_location=&quot;above&quot;,</span>
<span class="sd">        ...                        plot_width=500, plot_height=300)</span>
<span class="sd">        &gt;&gt;&gt; plot.tools.append(hover)</span>
<span class="sd">        &gt;&gt;&gt; legend_entries = []</span>
<span class="sd">        &gt;&gt;&gt; for idx, (toy, color) in enumerate(</span>
<span class="sd">        ...         zip(seasonalann.toys, palettes.Dark2_5)):</span>
<span class="sd">        ...     line = plot.line(range(366), seasonalann.ratios[:, idx],</span>
<span class="sd">        ...                      alpha=0.8, muted_alpha=0.2, color=color)</span>
<span class="sd">        ...     line.muted = True</span>
<span class="sd">        ...     legend_entries.append((str(toy), [line]))</span>
<span class="sd">        &gt;&gt;&gt; legend = models.Legend(items=legend_entries,</span>
<span class="sd">        ...                        location=(10, 0),</span>
<span class="sd">        ...                        click_policy=&quot;mute&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plot.add_layout(legend, &quot;right&quot;)</span>
<span class="sd">        &gt;&gt;&gt; label_dict = {0: &quot;Jan 1&quot;,</span>
<span class="sd">        ...               60: &quot;Mar 1&quot;,</span>
<span class="sd">        ...               182: &quot;Jul 1&quot;}</span>
<span class="sd">        &gt;&gt;&gt; plot.xaxis.ticker =  sorted(label_dict.keys())</span>
<span class="sd">        &gt;&gt;&gt; plot.xaxis.formatter = models.FuncTickFormatter(</span>
<span class="sd">        ...     code=f&quot;var labels = {label_dict}; return labels[tick];&quot;)</span>
<span class="sd">        &gt;&gt;&gt; dummy = plotting.save(plot)</span>

<span class="sd">    .. raw:: html</span>

<span class="sd">        &lt;iframe</span>
<span class="sd">            src=&quot;anntools.SeasonalANN.ratios.html&quot;</span>
<span class="sd">            width=&quot;100%&quot;</span>
<span class="sd">            height=&quot;300px&quot;</span>
<span class="sd">            frameborder=0</span>
<span class="sd">        &gt;&lt;/iframe&gt;</span>

<span class="sd">    For example, on July, 1 (which is the 183rd day of a leap year),</span>
<span class="sd">    only the output of the third network is relevant:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import print_values</span>
<span class="sd">    &gt;&gt;&gt; print_values(seasonalann.ratios[182])</span>
<span class="sd">    0.0, 0.0, 1.0</span>

<span class="sd">    On Juni, 30, and July, 2, also the second and the first neural network</span>
<span class="sd">    are relevant, respectively:</span>

<span class="sd">    &gt;&gt;&gt; print_values(seasonalann.ratios[181])</span>
<span class="sd">    0.0, 0.008197, 0.991803</span>
<span class="sd">    &gt;&gt;&gt; print_values(seasonalann.ratios[183])</span>
<span class="sd">    0.005435, 0.0, 0.994565</span>

<span class="sd">    Inserting data, processing this data, and fetching the output works</span>
<span class="sd">    as explained for class |anntools.ANN|, except that you must additionally</span>
<span class="sd">    pass the index of the actual time of year.  Passing the index value</span>
<span class="sd">    `182` activates the third network only, being configured as the one</span>
<span class="sd">    exemplifying class |anntools.ANN|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; for input_ in range(9):</span>
<span class="sd">    ...     seasonalann.inputs[0] = input_</span>
<span class="sd">    ...     seasonalann.calculate_values(182)</span>
<span class="sd">    ...     round_([input_, seasonalann.outputs[0]])</span>
<span class="sd">    0, -1.0</span>
<span class="sd">    1, -0.999982</span>
<span class="sd">    2, -0.998994</span>
<span class="sd">    3, -0.946041</span>
<span class="sd">    4, 0.5</span>
<span class="sd">    5, 1.946041</span>
<span class="sd">    6, 1.998994</span>
<span class="sd">    7, 1.999982</span>
<span class="sd">    8, 2.0</span>

<span class="sd">    To see that the final output values are actually the weighted mean</span>
<span class="sd">    of the output values of the single neural networks, we repeat the</span>
<span class="sd">    above example for January, 13, where the first and the second neural</span>
<span class="sd">    network have ratios of 0.8 and 0.2 respectively:</span>

<span class="sd">    &gt;&gt;&gt; print_values(seasonalann.ratios[12])</span>
<span class="sd">    0.8, 0.2, 0.0</span>

<span class="sd">    For both networks, all parameters except the output intercepts are</span>
<span class="sd">    zero.  Hence, the calculated output is independent of the given input.</span>
<span class="sd">    The output of the first network (1.0) dominates the output of the</span>
<span class="sd">    second network (-1.0):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; for input_ in range(9):</span>
<span class="sd">    ...     seasonalann.inputs[0] = input_</span>
<span class="sd">    ...     seasonalann.calculate_values(12)</span>
<span class="sd">    ...     round_([input_, seasonalann.outputs[0]])</span>
<span class="sd">    0, 0.6</span>
<span class="sd">    1, 0.6</span>
<span class="sd">    2, 0.6</span>
<span class="sd">    3, 0.6</span>
<span class="sd">    4, 0.6</span>
<span class="sd">    5, 0.6</span>
<span class="sd">    6, 0.6</span>
<span class="sd">    7, 0.6</span>
<span class="sd">    8, 0.6</span>

<span class="sd">    It is of great importance that all contained neural networks are</span>
<span class="sd">    consistent.  Hence class |anntools.SeasonalANN| performs some</span>
<span class="sd">    related checks:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann = SeasonalANN(None)</span>
<span class="sd">    &gt;&gt;&gt; seasonalann.calculate_values(0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: The seasonal neural network collection `seasonalann` \</span>
<span class="sd">of element `?` has not been properly prepared so far.</span>

<span class="sd">    &gt;&gt;&gt; seasonalann(1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: Type `int` is not (a subclass of) type `ANN`.</span>

<span class="sd">    &gt;&gt;&gt; seasonalann(</span>
<span class="sd">    ...     _13_1_12=ann(nmb_inputs=2, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                  weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                  intercepts_hidden=0.0, intercepts_output=1.0))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to add a season specific neural network to \</span>
<span class="sd">parameter `seasonalann` of element `?`, the following error occurred: \</span>
<span class="sd">While trying to initialise a TOY object based on argument value `_13_1_12` \</span>
<span class="sd">of type `str`, the following error occurred: While trying to retrieve \</span>
<span class="sd">the month, the following error occurred: The value of property `month` \</span>
<span class="sd">of TOY (time of year) objects must lie within the range `(1, 12)`, \</span>
<span class="sd">but the given value is `13`.</span>

<span class="sd">    &gt;&gt;&gt; seasonalann(</span>
<span class="sd">    ...     ann(nmb_inputs=2, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...         weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...         intercepts_hidden=0.0, intercepts_output=1.0))</span>
<span class="sd">    &gt;&gt;&gt; seasonalann</span>
<span class="sd">    seasonalann(</span>
<span class="sd">        ann(</span>
<span class="sd">            nmb_inputs=2,</span>
<span class="sd">            weights_input=[[0.0],</span>
<span class="sd">                           [0.0]],</span>
<span class="sd">            weights_output=[[0.0]],</span>
<span class="sd">            intercepts_hidden=[[0.0]],</span>
<span class="sd">            intercepts_output=[1.0],</span>
<span class="sd">        )</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; seasonalann(</span>
<span class="sd">    ...     ann(nmb_inputs=2, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...         weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...         intercepts_hidden=0.0, intercepts_output=1.0),</span>
<span class="sd">    ...     _7_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=4.0, weights_output=3.0,</span>
<span class="sd">    ...                 intercepts_hidden=-16.0, intercepts_output=-1.0),</span>
<span class="sd">    ...     _3_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                 intercepts_hidden=0.0, intercepts_output=-1.0))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Type `SeasonalANN` accepts either a single positional \</span>
<span class="sd">argument or an arbitrary number of keyword arguments, but for the \</span>
<span class="sd">corresponding parameter of element `?` 1 positional and 2 keyword \</span>
<span class="sd">arguments have been given.</span>

<span class="sd">    &gt;&gt;&gt; seasonalann(</span>
<span class="sd">    ...     _1_1_12=ann(nmb_inputs=2, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                 intercepts_hidden=0.0, intercepts_output=1.0),</span>
<span class="sd">    ...     _7_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=4.0, weights_output=3.0,</span>
<span class="sd">    ...                 intercepts_hidden=-16.0, intercepts_output=-1.0),</span>
<span class="sd">    ...     _3_1_12=ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...                 weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...                 intercepts_hidden=0.0, intercepts_output=-1.0))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: The number of input and output values of all neural \</span>
<span class="sd">networks contained by a seasonal neural network collection must be \</span>
<span class="sd">identical and be known by the containing object.  But the seasonal \</span>
<span class="sd">neural network collection `seasonalann` of element `?` assumes `2` input \</span>
<span class="sd">and `1` output values, while the network corresponding to the time of \</span>
<span class="sd">year `toy_3_1_12_0_0` requires `1` input and `1` output values.</span>

<span class="sd">    For safety, each failure results in a total loss of the previously</span>
<span class="sd">    defined networks:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann</span>
<span class="sd">    seasonalann()</span>

<span class="sd">    Alternatively, neural networks can be added individually via</span>
<span class="sd">    attribute access:</span>

<span class="sd">    &gt;&gt;&gt; jan = ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">    ...           weights_input=0.0, weights_output=0.0,</span>
<span class="sd">    ...           intercepts_hidden=0.0, intercepts_output=1.0)</span>
<span class="sd">    &gt;&gt;&gt; seasonalann.toy_1_1_12 = jan</span>

<span class="sd">    If you set an attribute, everything updates automatically, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; round_(seasonalann.ratios[0])</span>
<span class="sd">    1.0</span>

<span class="sd">    The mentioned safety checks do also apply when adding networks</span>
<span class="sd">    via attribute access, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.toy_7_1_12 = ann(nmb_inputs=2,</span>
<span class="sd">    ...                              nmb_neurons=(1,),</span>
<span class="sd">    ...                              nmb_outputs=1,</span>
<span class="sd">    ...                              weights_input=0.0,</span>
<span class="sd">    ...                              weights_output=0.0,</span>
<span class="sd">    ...                              intercepts_hidden=0.0,</span>
<span class="sd">    ...                              intercepts_output=1.0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to assign a new neural network to the \</span>
<span class="sd">seasonal neural network collection `seasonalann` of element `?` based \</span>
<span class="sd">on name `toy_7_1_12`, the following error occurred: \</span>
<span class="sd">The number of input and output values of all neural networks contained \</span>
<span class="sd">by a seasonal neural network collection must be identical and be known \</span>
<span class="sd">by the containing object.  But the seasonal neural network collection \</span>
<span class="sd">`seasonalann` of element `?` assumes `1` input and `1` output values, \</span>
<span class="sd">while the network corresponding to the time of year `toy_7_1_12_0_0` \</span>
<span class="sd">requires `2` input and `1` output values.</span>

<span class="sd">    Besides setting new networks, getting and deleting them also works:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.toy_1_1_12 = jan</span>
<span class="sd">    &gt;&gt;&gt; seasonalann.toy_1_1_12</span>
<span class="sd">    ann(</span>
<span class="sd">        weights_input=[[0.0]],</span>
<span class="sd">        weights_output=[[0.0]],</span>
<span class="sd">        intercepts_hidden=[[0.0]],</span>
<span class="sd">        intercepts_output=[1.0],</span>
<span class="sd">    )</span>
<span class="sd">    &gt;&gt;&gt; del seasonalann.toy_1_1_12</span>

<span class="sd">    These are the error messages related to attribute access problems:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.toy_1_1_12</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: While trying to look up for a neural network handled \</span>
<span class="sd">by the seasonal neural network collection `seasonalann` of element `?` \</span>
<span class="sd">based on name `toy_1_1_12`, the following error occurred: No neural network \</span>
<span class="sd">is registered under a TOY object named `toy_1_1_12_0_0`.</span>

<span class="sd">    &gt;&gt;&gt; del seasonalann.toy_1_1_12</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: While trying to remove a new neural network from the \</span>
<span class="sd">seasonal neural network collection `seasonalann` of element `?` based on \</span>
<span class="sd">name `toy_1_1_12`, the following error occurred: No neural network is \</span>
<span class="sd">registered under a TOY object named `toy_1_1_12_0_0`.</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.toy_1_1_12 = 1</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: While trying to assign a new neural network to the seasonal \</span>
<span class="sd">neural network collection `seasonalann` of element `?` based on name \</span>
<span class="sd">`toy_1_1_12`, the following error occurred: Value `1` of type `int` has \</span>
<span class="sd">been given, but a value of type `ANN` is required.</span>

<span class="sd">    Setting and deleting &quot;normal&quot; attributes is supported:</span>

<span class="sd">    &gt;&gt;&gt; seasonalann.temp = 999</span>
<span class="sd">    &gt;&gt;&gt; seasonalann.temp</span>
<span class="sd">    999</span>
<span class="sd">    &gt;&gt;&gt; del seasonalann.temp</span>
<span class="sd">    &gt;&gt;&gt; seasonalann.temp</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: &#39;SeasonalANN&#39; object has no attribute &#39;temp&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NDIM</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">TYPE</span> <span class="o">=</span> <span class="s2">&quot;annutils.SeasonalANN&quot;</span>
    <span class="n">TIME</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">SPAN</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subvars</span><span class="p">:</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">SubParameters</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subvars</span> <span class="o">=</span> <span class="n">subvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subpars</span> <span class="o">=</span> <span class="n">subvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">FastAccessParameter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">,</span> <span class="n">ANN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sann</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_refresh</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_refresh</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Type `</span><span class="si">%s</span><span class="s2">` accepts either a single positional argument or &quot;</span>
                    <span class="s2">&quot;an arbitrary number of keyword arguments, but for the &quot;</span>
                    <span class="s2">&quot;corresponding parameter of element `</span><span class="si">%s</span><span class="s2">` </span><span class="si">%d</span><span class="s2"> positional &quot;</span>
                    <span class="s2">&quot;and </span><span class="si">%d</span><span class="s2"> keyword arguments have been given.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">toystr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ANN</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Type `</span><span class="si">%s</span><span class="s2">` is not (a subclass of) type `ANN`.&quot;</span>
                        <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">toystr</span><span class="p">)),</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                    <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                        <span class="s2">&quot;While trying to add a season specific neural &quot;</span>
                        <span class="s2">&quot;network to parameter `</span><span class="si">%s</span><span class="s2">` of element `</span><span class="si">%s</span><span class="s2">`&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                    <span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">exc</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_refresh</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__hydpy__connect_variable2subgroup__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Connect the actual |anntools.SeasonalANN| object with the given</span>
<span class="sd">        |SubParameters| object.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpars</span><span class="o">.</span><span class="n">fastaccess</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sann</span><span class="p">)</span>

<div class="viewcode-block" id="SeasonalANN.refresh"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.SeasonalANN.refresh">[docs]</a>    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;Prepare the actual |anntools.SeasonalANN| object for calculations.</span>

<span class="sd">        Class |anntools.SeasonalANN| stores its |anntools.ANN| objects by</span>
<span class="sd">        reference.  Therefore, despite all automated refreshings (explained</span>
<span class="sd">        in the general documentation on class |anntools.SeasonalANN|), it</span>
<span class="sd">        is still possible to destroy the inner consistency of a</span>
<span class="sd">        |anntools.SeasonalANN| instance:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import SeasonalANN, ann</span>
<span class="sd">        &gt;&gt;&gt; seasonalann = SeasonalANN(None)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann.simulationstep = &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; jan = ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">        ...           weights_input=0.0, weights_output=0.0,</span>
<span class="sd">        ...           intercepts_hidden=0.0, intercepts_output=1.0)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann(_1_1_12=jan)</span>
<span class="sd">        &gt;&gt;&gt; jan.nmb_inputs, jan.nmb_outputs = 2, 3</span>
<span class="sd">        &gt;&gt;&gt; jan.nmb_inputs, jan.nmb_outputs</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann.nmb_inputs, seasonalann.nmb_outputs</span>
<span class="sd">        (1, 1)</span>

<span class="sd">        Due to the C level implementation of the mathematical core of</span>
<span class="sd">        both |anntools.ANN| and |anntools.SeasonalANN| in module |annutils|,</span>
<span class="sd">        such an inconsistency might result in a program crash without any</span>
<span class="sd">        informative error message.  Whenever you are think some inconsistency</span>
<span class="sd">        might have crept in and you want to repair it, call method</span>
<span class="sd">        |anntools.SeasonalANN.refresh| explicitly:</span>

<span class="sd">        &gt;&gt;&gt; seasonalann.refresh()</span>
<span class="sd">        &gt;&gt;&gt; jan.nmb_inputs, jan.nmb_outputs</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann.nmb_inputs, seasonalann.nmb_outputs</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unsupported-assignment-operation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_refresh</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__sann</span> <span class="o">=</span> <span class="n">annutils</span><span class="o">.</span><span class="n">SeasonalANN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anns</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">nmb_anns</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">nmb_anns</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">ratios</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__sann</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SeasonalANN.verify"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.SeasonalANN.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;Raise a |RuntimeError| and remove all handled neural networks,</span>
<span class="sd">        if they are defined inconsistently.</span>

<span class="sd">        Class |anntools.SeasonalANN| stores its |anntools.ANN| objects by</span>
<span class="sd">        reference.  Therefore, despite all automated refreshings (explained</span>
<span class="sd">        in the general documentation on class |anntools.SeasonalANN|), it</span>
<span class="sd">        is still possible to destroy the inner consistency of a</span>
<span class="sd">        |anntools.SeasonalANN| instance:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import SeasonalANN, ann</span>
<span class="sd">        &gt;&gt;&gt; seasonalann = SeasonalANN(None)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann.simulationstep = &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; jan = ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">        ...           weights_input=0.0, weights_output=0.0,</span>
<span class="sd">        ...           intercepts_hidden=0.0, intercepts_output=1.0)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann(_1_1_12=jan)</span>
<span class="sd">        &gt;&gt;&gt; jan.nmb_inputs, jan.nmb_outputs = 2, 3</span>
<span class="sd">        &gt;&gt;&gt; jan.nmb_inputs, jan.nmb_outputs</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann.nmb_inputs, seasonalann.nmb_outputs</span>
<span class="sd">        (1, 1)</span>

<span class="sd">        Due to the C level implementation of the mathematical core of both</span>
<span class="sd">        |anntools.ANN| and |anntools.SeasonalANN| in module |annutils|,</span>
<span class="sd">        such an inconsistency might result in a program crash without any</span>
<span class="sd">        informative error message. Whenever you think some inconsistency</span>
<span class="sd">        might have crept in and you want to find out if your suspicion is</span>
<span class="sd">        right, call method |anntools.SeasonalANN.verify| explicitly.</span>

<span class="sd">        &gt;&gt;&gt; seasonalann.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The number of input and output values of all neural \</span>
<span class="sd">networks contained by a seasonal neural network collection must be \</span>
<span class="sd">identical and be known by the containing object.  But the seasonal \</span>
<span class="sd">neural network collection `seasonalann` of element `?` assumes `1` input \</span>
<span class="sd">and `1` output values, while the network corresponding to the time of \</span>
<span class="sd">year `toy_1_1_12_0_0` requires `2` input and `3` output values.</span>

<span class="sd">        &gt;&gt;&gt; seasonalann</span>
<span class="sd">        seasonalann()</span>

<span class="sd">        &gt;&gt;&gt; seasonalann.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: Seasonal artificial neural network collections need \</span>
<span class="sd">to handle at least one &quot;normal&quot; single neural network, but for the seasonal \</span>
<span class="sd">neural network `seasonalann` of element `?` none has been defined so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">anns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Seasonal artificial neural network collections need &quot;</span>
                <span class="sa">f</span><span class="s1">&#39;to handle at least one &quot;normal&quot; single neural network, &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;but for the seasonal neural network `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` of element &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">` none has been defined so far.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">toy</span><span class="p">,</span> <span class="n">ann_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ann_</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span> <span class="o">!=</span> <span class="n">ann_</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span> <span class="o">!=</span> <span class="n">ann_</span><span class="o">.</span><span class="n">nmb_outputs</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of input and output values of all neural &quot;</span>
                    <span class="s2">&quot;networks contained by a seasonal neural network &quot;</span>
                    <span class="s2">&quot;collection must be identical and be known by the &quot;</span>
                    <span class="s2">&quot;containing object.  But the seasonal neural &quot;</span>
                    <span class="s2">&quot;network collection `</span><span class="si">%s</span><span class="s2">` of element `</span><span class="si">%s</span><span class="s2">` assumes &quot;</span>
                    <span class="s2">&quot;`</span><span class="si">%d</span><span class="s2">` input and `</span><span class="si">%d</span><span class="s2">` output values, while the network &quot;</span>
                    <span class="s2">&quot;corresponding to the time of year `</span><span class="si">%s</span><span class="s2">` requires &quot;</span>
                    <span class="s2">&quot;`</span><span class="si">%d</span><span class="s2">` input and `</span><span class="si">%d</span><span class="s2">` output values.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="p">,</span>
                        <span class="n">toy</span><span class="p">,</span>
                        <span class="n">ann_</span><span class="o">.</span><span class="n">nmb_inputs</span><span class="p">,</span>
                        <span class="n">ann_</span><span class="o">.</span><span class="n">nmb_outputs</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios</span>
        <span class="n">ratios</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">toys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toys</span>
        <span class="n">centred</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="o">.</span><span class="n">centred_timegrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tdx</span><span class="p">,</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">rel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">centred</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">rel</span><span class="p">:</span>
                <span class="n">xnew</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx_1</span><span class="p">,</span> <span class="n">x_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">toys</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x_1</span> <span class="o">&gt;</span> <span class="n">xnew</span><span class="p">:</span>
                        <span class="n">idx_0</span> <span class="o">=</span> <span class="n">idx_1</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">x_0</span> <span class="o">=</span> <span class="n">toys</span><span class="p">[</span><span class="n">idx_0</span><span class="p">]</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">idx_1</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">x_0</span> <span class="o">=</span> <span class="n">toys</span><span class="p">[</span><span class="n">idx_0</span><span class="p">]</span>
                    <span class="n">x_1</span> <span class="o">=</span> <span class="n">toys</span><span class="p">[</span><span class="n">idx_1</span><span class="p">]</span>
                <span class="n">ratios</span><span class="p">[</span><span class="n">tdx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">ratios</span><span class="p">[</span><span class="n">tdx</span><span class="p">,</span> <span class="n">idx_1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xnew</span> <span class="o">-</span> <span class="n">x_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_1</span> <span class="o">-</span> <span class="n">x_0</span><span class="p">)</span>
                <span class="n">ratios</span><span class="p">[</span><span class="n">tdx</span><span class="p">,</span> <span class="n">idx_0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratios</span><span class="p">[</span><span class="n">tdx</span><span class="p">,</span> <span class="n">idx_1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The shape of array |anntools.SeasonalANN.ratios|.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private on purpose.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">),)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s2">&quot;366d&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">simulationstep</span>
        <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">)))</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">ratios</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">toys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;A sorted |tuple| of all contained |TOY| objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">toy</span> <span class="k">for</span> <span class="p">(</span><span class="n">toy</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">anns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ANN</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;A sorted |tuple| of all contained |anntools.ANN| objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ann_</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ann_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ratios</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The ratios for weighting the single neural network outputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">ratios</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sann</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">annutils</span><span class="o">.</span><span class="n">SeasonalANN</span><span class="p">:</span>
        <span class="n">sann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sann</span>
        <span class="k">if</span> <span class="n">sann</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sann</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;The seasonal neural network collection `</span><span class="si">%s</span><span class="s2">` of &quot;</span>
            <span class="s2">&quot;element `</span><span class="si">%s</span><span class="s2">` has not been properly prepared so far.&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of input values of all neural networks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">nmb_inputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The general input data for all neural networks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nmb_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of output values of all neural networks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">nmb_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The weighted output of the individual neural networks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

<div class="viewcode-block" id="SeasonalANN.calculate_values"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.SeasonalANN.calculate_values">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_toy</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the network output values based on the input values</span>
<span class="sd">        defined previously for the given index referencing the actual</span>
<span class="sd">        time of year.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sann</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">(</span><span class="n">idx_toy</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeasonalANN.plot"><a class="viewcode-back" href="../../../anntools.html#hydpy.auxs.anntools.SeasonalANN.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">idx_input</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Call method |anntools.ANN.plot| of all |anntools.ANN| objects</span>
<span class="sd">        handled by the actual |anntools.SeasonalANN| object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">toy</span><span class="p">,</span> <span class="n">ann_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ann_</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">xmin</span><span class="p">,</span>
                <span class="n">xmax</span><span class="p">,</span>
                <span class="n">idx_input</span><span class="o">=</span><span class="n">idx_input</span><span class="p">,</span>
                <span class="n">idx_output</span><span class="o">=</span><span class="n">idx_output</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">toy</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;toy_&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No neural network is registered under a &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;TOY object named `</span><span class="si">{</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;While trying to look up for a neural network handled &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;by the seasonal neural network collection `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of element `</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">` based on &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;toy_&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ANN</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has been given, but a value of type &quot;</span>
                        <span class="s2">&quot;`ANN` is required.&quot;</span>
                        <span class="o">%</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">value_of_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                    <span class="s2">&quot;While trying to assign a new neural network to &quot;</span>
                    <span class="s2">&quot;the seasonal neural network collection `</span><span class="si">%s</span><span class="s2">` of &quot;</span>
                    <span class="s2">&quot;element `</span><span class="si">%s</span><span class="s2">` based on name `</span><span class="si">%s</span><span class="s2">`&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;toy_&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No neural network is registered under a &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;TOY object named `</span><span class="si">{</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;While trying to remove a new neural network from the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;seasonal neural network collection `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;element `</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">` based on &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">TOY</span><span class="p">,</span> <span class="n">ANN</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">toy</span><span class="p">,</span> <span class="n">ann_</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">toy</span><span class="p">,</span> <span class="n">ann_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">()&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">timetools</span><span class="o">.</span><span class="n">TOY0</span><span class="p">):</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">toy</span><span class="p">,</span> <span class="n">ann_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">ann_</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">toy</span><span class="si">}</span><span class="s2">=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_toy2ann</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># noinspection PyTypeChecker,PyUnresolvedReferences</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import ann, pub, SeasonalANN</span>
<span class="sd">        &gt;&gt;&gt; seasonalann = SeasonalANN(None)</span>
<span class="sd">        &gt;&gt;&gt; seasonalann(</span>
<span class="sd">        ...     ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,</span>
<span class="sd">        ...         weights_input=0.0, weights_output=0.0,</span>
<span class="sd">        ...         intercepts_hidden=0.0, intercepts_output=1.0))</span>
<span class="sd">        &gt;&gt;&gt; print(*dir(seasonalann))</span>
<span class="sd">        NDIM SPAN TIME TYPE anns calculate_values fastaccess inputs name \</span>
<span class="sd">nmb_inputs nmb_outputs outputs plot ratios refresh shape subpars subvars \</span>
<span class="sd">toy_1_1_0_0_0 toys verify</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">dir_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">toy</span><span class="p">)</span> <span class="k">for</span> <span class="n">toy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">toys</span><span class="p">]</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.anntools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>