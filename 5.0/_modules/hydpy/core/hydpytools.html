<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.core.hydpytools &#8212; HydPy 5.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=127cebf3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=eafc0fe6" />
    
    <script src="../../../_static/documentation_options.js?v=f98c4cc8"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.hydpytools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to.html">How toâ€¦</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.core.hydpytools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module implements the main features for managing *HydPy* projects.</span>

<span class="sd">.. _`NetCDF Climate and Forecast (CF) Metadata Conventions`: http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/cf-conventions.html  # pylint: disable=line-too-long</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span> <span class="nn">networkx</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">import</span> <span class="nn">hydpy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">devicetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">filetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">modeltools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">printtools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">propertytools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">selectiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">sequencetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">timetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core.typingtools</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">auxfiletools</span>


<span class="n">ConditionsType</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">NDArrayFloat</span><span class="p">]]]]</span>


<div class="viewcode-block" id="HydPy">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy">[docs]</a>
<span class="k">class</span> <span class="nc">HydPy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The main class for managing *HydPy* projects.</span>

<span class="sd">    In typical *HydPy* projects, one prepares a single instance of class |HydPy|.  This</span>
<span class="sd">    instance, which we name &quot;hp&quot; throughout this documentation instead of &quot;hydpy&quot; to</span>
<span class="sd">    avoid a naming collision with the `hydpy` site package, provides many convenient</span>
<span class="sd">    methods to perform tasks like reading time-series data or starting simulation runs.</span>
<span class="sd">    Additionally, it serves as a root to access most details of a *HydPy* project,</span>
<span class="sd">    allowing for more granular control over the framework features.</span>

<span class="sd">    We elaborate these short explanations by using the `LahnH` example project.</span>
<span class="sd">    Calling function |prepare_full_example_1| copies the complete example project</span>
<span class="sd">    `LahnH` into the `iotesting` directory of the *HydPy* site package (alternatively,</span>
<span class="sd">    you can copy the `LahnH` example project, which can be found in subpackage `data`,</span>
<span class="sd">    into a working directory of your choice):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">    &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">    At first, the |HydPy| instance needs to know the name of the relevant project,</span>
<span class="sd">    which is identical to the name of the project&#39;s root directory.  Pass `LahnH` to</span>
<span class="sd">    the constructor of class |HydPy|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">    &gt;&gt;&gt; hp = HydPy(&quot;LahnH&quot;)</span>

<span class="sd">    So far, our |HydPy| instance does not know any project configurations except its</span>
<span class="sd">    name.  Most of this information would be available via properties |HydPy.nodes| and</span>
<span class="sd">    |HydPy.elements|, but we get the following error responses if we try to access them:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The actual HydPy instance does not handle any nodes at the moment.</span>

<span class="sd">    &gt;&gt;&gt; hp.elements</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The actual HydPy instance does not handle any elements at the \</span>
<span class="sd">moment.</span>

<span class="sd">    One could continue rather quickly by calling the method |HydPy.prepare_everything|,</span>
<span class="sd">    which would make our |HydPy| instance ready for its first simulation run in one go.</span>
<span class="sd">    However, we prefer to continue step by step by calling the more specific</span>
<span class="sd">    preparation methods, which offers more flexibility.</span>

<span class="sd">    First, the |HydPy| instance needs to know the relevant |Node| and |Element| objects.</span>
<span class="sd">    Method |HydPy.prepare_network| reads this information from so-called &quot;network</span>
<span class="sd">    files&quot;.  Then, the |Node| and |Element| objects connect automatically and thereby</span>
<span class="sd">    define the topology or the network structure of the project (see the documentation</span>
<span class="sd">    on class |NetworkManager| and module |devicetools| for more detailed  explanations):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import TestIO</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_network()</span>

<span class="sd">    (Using the &quot;with&quot; statement in combination with class |TestIO| makes sure we are</span>
<span class="sd">    reading the network files from a subdirectory of the `iotesting` directory.  Here</span>
<span class="sd">    and in the following, you must omit such &quot;with blocks&quot; in case you copied the</span>
<span class="sd">    `LahnH` example project into your current working directory.)</span>

<span class="sd">    Now, our |HydPy| instance offers access to all |Node| objects defined within the</span>
<span class="sd">    `LahnH` example project, which are grouped by a |Nodes| object:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes</span>
<span class="sd">    Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">    Taking the node `dill` as an example, we can dive into the details and, for example,</span>
<span class="sd">    search for those elements which node `dill` is connected to (it receives water from</span>
<span class="sd">    element `land_dill` and passes it to element `stream_dill_lahn_2`), or inspect its</span>
<span class="sd">    simulated discharge value handled by a |Sim| sequence object (so far, zero):</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.entries</span>
<span class="sd">    Elements(&quot;land_dill&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">    Elements(&quot;stream_dill_lahn_2&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(0.0)</span>

<span class="sd">    All |Node| objects are ready to be used.  The same is only partly true for the</span>
<span class="sd">    |Element| objects, which are also accessible (via a |Elements| instance) and</span>
<span class="sd">    properly connected to the |Node| objects but do not handle workable |Model| objects,</span>
<span class="sd">    which is required to perform any simulation run:</span>

<span class="sd">    &gt;&gt;&gt; hp.elements</span>
<span class="sd">    Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">             &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">             &quot;stream_lahn_2_lahn_3&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.elements.stream_dill_lahn_2</span>
<span class="sd">    Element(&quot;stream_dill_lahn_2&quot;,</span>
<span class="sd">            inlets=&quot;dill&quot;,</span>
<span class="sd">            outlets=&quot;lahn_2&quot;,</span>
<span class="sd">            keywords=&quot;river&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.elements.land_dill.model</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: The model object of element \</span>
<span class="sd">`land_dill` has been requested but not been prepared so far.</span>

<span class="sd">    Hence, we need to call method |HydPy.prepare_models|, which instructs all |Element|</span>
<span class="sd">    objects to read the relevant parameter control files and prepare their |Model|</span>
<span class="sd">    objects.  Note that the individual |Element| object does not know the relevant</span>
<span class="sd">    model type beforehand; both the information on the model type and the parameter</span>
<span class="sd">    settings is encoded in individual control files, making it easy to exchange</span>
<span class="sd">    individual models later (the documentation on method |Elements.prepare_models| of</span>
<span class="sd">    class |Elements| is a good starting point for a deeper understanding on configuring</span>
<span class="sd">    *HydPy* projects via control files):</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_models()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: While trying to initialise the model \</span>
<span class="sd">object of element `land_dill`, the following error occurred: The initialisation period \</span>
<span class="sd">has not been defined via attribute `timegrids` of module `pub` yet but might be \</span>
<span class="sd">required to prepare the model properly.</span>

<span class="sd">    Oops, something went wrong.  We forgot to define the simulation period, which might</span>
<span class="sd">    be relevant for some time-dependent configurations.  We discuss some examples of</span>
<span class="sd">    such configurations below but now use this little accident to discuss the typical</span>
<span class="sd">    pattern of *HydPy* error messages.  First, we usually try to add some additional</span>
<span class="sd">    &quot;spatial&quot; information (in this case: the name of the related |Element| object).</span>
<span class="sd">    Second, we try to explain in which program context an error occurs.  This context</span>
<span class="sd">    is already available in much more detail in the so-called &quot;stack trace&quot; (the middle</span>
<span class="sd">    part of the printed error response we do not show).  Stack trace descriptions are</span>
<span class="sd">    great for programmers but hard to read for others, which is why we often add &quot;While</span>
<span class="sd">    trying to...&quot; explanations to our error messages.  In our example, one can see that</span>
<span class="sd">    the error occurred while trying to initialise the |Model| object of element</span>
<span class="sd">    `land_dill`, which is quite evident in our example but could be less evident in</span>
<span class="sd">    more complex *HydPy* applications.</span>

<span class="sd">    The last sentence of the error message tells us that we need to define the</span>
<span class="sd">    attribute `timegrids` of module `pub`.  `pub` stands for &quot;public&quot;, meaning module</span>
<span class="sd">    `pub` handles all (or at least most of) the globally available configuration data.</span>
<span class="sd">    One example is that module `pub` handles a |Timegrids| instance defining both the</span>
<span class="sd">    initialisation and the simulation period, which can be done by the following</span>
<span class="sd">    assignment (see the documentation on class |Timegrid| and on class |Timegrids| for</span>
<span class="sd">    further information):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>

<span class="sd">    Now method |HydPy.prepare_models| does not complain anymore and adds an instance of</span>
<span class="sd">    the |hland_v1| application model to element `land_dill`, to which we set an</span>
<span class="sd">    additional reference to shorten the following examples:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_models()</span>

<span class="sd">    &gt;&gt;&gt; model = hp.elements.land_dill.model</span>
<span class="sd">    &gt;&gt;&gt; model.name</span>
<span class="sd">    &#39;hland_v1&#39;</span>

<span class="sd">    All control parameter values, defined in the corresponding control file, are</span>
<span class="sd">    correctly set.  As an example, we show the values of control parameter</span>
<span class="sd">    |hland_control.IcMax|, which in this case defines different values for hydrological</span>
<span class="sd">    response units of type |hland_constants.FIELD| (1.0 mm) and of type</span>
<span class="sd">    |hland_constants.FOREST| (1.5 mm):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.control.icmax</span>
<span class="sd">    icmax(field=1.0, forest=1.5)</span>

<span class="sd">    The appearance (or &quot;string representation&quot;) of all parameters that have a unit with</span>
<span class="sd">    a time reference (we call these parameters &quot;time-dependent&quot;) like</span>
<span class="sd">    |hland_control.PercMax| depends on the current setting of option</span>
<span class="sd">    |Options.parameterstep|, which is one day by default (see the documentation on</span>
<span class="sd">    class |Parameter| for more information on dealing with time-dependent parameters</span>
<span class="sd">    subclasses):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.control.percmax</span>
<span class="sd">    percmax(1.39636)</span>
<span class="sd">    &gt;&gt;&gt; pub.options.parameterstep(&quot;1h&quot;)</span>
<span class="sd">    Period(&quot;1d&quot;)</span>

<span class="sd">    The values of the derived parameters, which need to be calculated before starting a</span>
<span class="sd">    simulation run based on the control parameters and eventually based on some other</span>
<span class="sd">    settings (e.g. the initialisation period), are also ready.  Here we show the value</span>
<span class="sd">    of the derived parameter  |hland_derived.UH|, representing the ordinates of a unit</span>
<span class="sd">    hydrograph (the single value of 1.0 means that the unit hydrograph does not cause</span>
<span class="sd">    any time delay):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.derived.uh</span>
<span class="sd">    uh(1.0)</span>

<span class="sd">    We define all class names in &quot;CamelCase&quot; letters (which is a Python convention) and,</span>
<span class="sd">    whenever practical, name the related objects identically but in lower case letters.</span>
<span class="sd">    We hope that eases finding the relevant parts of the online documentation when in</span>
<span class="sd">    trouble with a particular object.  Three examples we already encountered are the</span>
<span class="sd">    |Timegrids| instance `timegrids` of module `pub`, the |Nodes| instance `nodes` of</span>
<span class="sd">    class `HydPy`, and the |hland_derived.UH| instance `uh` of application model</span>
<span class="sd">    |hland_v1|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import classname</span>
<span class="sd">    &gt;&gt;&gt; classname(pub.timegrids)</span>
<span class="sd">    &#39;Timegrids&#39;</span>

<span class="sd">    &gt;&gt;&gt; classname(hp.nodes)</span>
<span class="sd">    &#39;Nodes&#39;</span>

<span class="sd">    &gt;&gt;&gt; classname(model.parameters.derived.uh)</span>
<span class="sd">    &#39;UH&#39;</span>

<span class="sd">    As shown above, all |Parameter| objects of the model of element `land_dill` are</span>
<span class="sd">    ready to be used. However, all sequences (which handle the time variable properties)</span>
<span class="sd">    contain |numpy| |numpy.nan| values, which we use to indicate missing data.  We show</span>
<span class="sd">    this for the 0-dimensional input sequence |hland_inputs.T|, the 1-dimensional factor</span>
<span class="sd">    sequence |hland_factors.TC|, the 1-dimensional state sequence |hland_states.SM|,</span>
<span class="sd">    and the 0-dimensional flux sequence |hland_fluxes.QT|:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.factors.tc</span>
<span class="sd">    tc(nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(nan)</span>

<span class="sd">    There are some other sequence types (see the documentation on module |sequencetools|</span>
<span class="sd">    for more details) but |InputSequence|, |FactorSequence| |FluxSequence|, and</span>
<span class="sd">    |StateSequence| are the most common ones (besides the |NodeSequence| subtypes</span>
<span class="sd">    |Obs| and especially |Sim|).</span>

<span class="sd">    |StateSequence| objects describe many aspects of the current state of a model (or,</span>
<span class="sd">    e.g., of a catchment).  Each simulation run requires proper initial states, which</span>
<span class="sd">    we call initial conditions in the following (also covering memory aspects</span>
<span class="sd">    represented by |LogSequence| objects).  We load all necessary initial conditions by</span>
<span class="sd">    calling the method |HydPy.load_conditions| (see the documentation on method</span>
<span class="sd">    |HydPy.load_conditions| for further details):</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_conditions()</span>

<span class="sd">    Now, the states of our model are also ready to be used.  However, one should note</span>
<span class="sd">    that state sequence |hland_states.SM| knows only the current soil moisture states</span>
<span class="sd">    for the twelve hydrological response units of element `land_dill` (more</span>
<span class="sd">    specifically, we loaded the soil moisture values related to the start date of the</span>
<span class="sd">    initialisation period, which is January 1 at zero o&#39;clock).  By default and for</span>
<span class="sd">    reasons of memory storage efficiency, sequences generally handle the currently</span>
<span class="sd">    relevant values only instead of complete time-series:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.factors.tc</span>
<span class="sd">    tc(nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">       222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(nan)</span>

<span class="sd">    For states like |hland_states.SM|, we need to know the values at the beginning of</span>
<span class="sd">    the simulation period only.  All following values are calculated subsequentially</span>
<span class="sd">    during the simulation run.  However, this is different for input sequences like</span>
<span class="sd">    |hland_inputs.T|.  Time variable properties like the air temperature are external</span>
<span class="sd">    forcings. Hence they must be available over the whole simulation period apriori.</span>
<span class="sd">    Such complete time-series can be made available via property |IOSequence.series| of</span>
<span class="sd">    class |IOSequence|, which has not happened for any sequence so far:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Sequence `t` of element `land_dill` \</span>
<span class="sd">is not requested to make any time-series data available.</span>

<span class="sd">    Before loading time-series data, we need to reserve the required memory storage.</span>
<span class="sd">    We do this for all sequences at once (not only the |ModelSequence| objects but also</span>
<span class="sd">    the |NodeSequence| objects as the |Sim| instance handled by node `dill`) by calling</span>
<span class="sd">    the method |HydPy.prepare_allseries|:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries()</span>

<span class="sd">    Now property |IOSequence.series| returns an |InfoArray| object, which is a slight</span>
<span class="sd">    modification of the widely applied |numpy| |numpy.ndarray|.  The first axis (or the</span>
<span class="sd">    only axis) corresponds to the number of days of the initialisation period (a</span>
<span class="sd">    *HydPy* convention).  For the 1-dimensional sequences |hland_factors.TC| and</span>
<span class="sd">    |hland_states.SM|, the second axis corresponds to the number of hydrological</span>
<span class="sd">    response units (a |hland| convention):</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series</span>
<span class="sd">    InfoArray([nan, nan, nan, nan])</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.factors.tc.series</span>
<span class="sd">    InfoArray([[nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]])</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm.series</span>
<span class="sd">    InfoArray([[nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],</span>
<span class="sd">               [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]])</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt.series</span>
<span class="sd">    InfoArray([nan, nan, nan, nan])</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim.series</span>
<span class="sd">    InfoArray([nan, nan, nan, nan])</span>

<span class="sd">    So far, each time-series array is empty.  The `LahnH` example project provides</span>
<span class="sd">    time-series files for the input sequences only, which is the minimum requirement</span>
<span class="sd">    for starting a simulation run.  We use method |HydPy.load_inputseries| to load this</span>
<span class="sd">    data:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_inputseries()</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    Finally, we can perform the simulation run by calling the method |HydPy.simulate|:</span>

<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>

<span class="sd">    The time-series arrays of all sequences now contain calculated values --- except</span>
<span class="sd">    those of input sequence |hland_inputs.T|, of course (for the sequences</span>
<span class="sd">    |hland_factors.TC| and |hland_states.SM|, we show the time-series of the first</span>
<span class="sd">    hydrological response unit only):</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    0.751154, 0.238461, -1.443848, -4.918849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    By comparison, you see that the lastly calculated (or read) time-series value is</span>
<span class="sd">    the actual one for each |Sequence_| object.  This mechanism allows, for example, to</span>
<span class="sd">    write the final states of soil moisture sequence |hland_states.SM| and use them as</span>
<span class="sd">    initial conditions later, even if its complete time-series were not available:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(-5.968849)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">       208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">       235.597338, 234.329294)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(6.017787)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(6.017787)</span>

<span class="sd">    In many applications, the simulated time-series is the result we are interested in.</span>
<span class="sd">    Hence we close our explanations with some detailed examples on this topic that also</span>
<span class="sd">    cover the potential problem of limited rapid access storage availability.</span>

<span class="sd">    The *HydPy* framework does not overwrite already existing time-series by default</span>
<span class="sd">    files.  However, you can change this and related settings via the |SequenceManager|</span>
<span class="sd">    object available in module |pub| (module |pub| also handles |ControlManager| and</span>
<span class="sd">    |ConditionManager| objects for settings related to reading and writing control</span>
<span class="sd">    files and condition files).  We change the default behaviour by setting the</span>
<span class="sd">    |SequenceManager.overwrite| attribute to |True|:</span>

<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.overwrite = True</span>

<span class="sd">    Now we can (over)write all possible time series:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.save_inputseries()</span>
<span class="sd">    ...     hp.save_factorseries()</span>
<span class="sd">    ...     hp.save_fluxseries()</span>
<span class="sd">    ...     hp.save_stateseries()</span>
<span class="sd">    ...     hp.save_simseries()</span>
<span class="sd">    ...     hp.save_obsseries()</span>

<span class="sd">    Alternatively, apply |HydPy.save_modelseries| to write the series of all the</span>
<span class="sd">    |InputSequence|, |FactorSequence|, |FluxSequence|, and |StateSequence| objects and</span>
<span class="sd">    |HydPy.save_nodeseries| to write the series of all |Sim| and |Obs| objects in one</span>
<span class="sd">    step:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.save_modelseries()</span>
<span class="sd">    ...     hp.save_nodeseries()</span>

<span class="sd">    Even shorter, just apply the method |HydPy.save_allseries|:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.save_allseries()</span>

<span class="sd">    Next, we show how the reading of time-series works.  We first set the time-series</span>
<span class="sd">    values of all considered sequences to zero for this purpose:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim.series = 0.</span>

<span class="sd">    Now we can reload the time-series of all relevant sequences.  However, doing so</span>
<span class="sd">    would result in a warning due to incomplete data (for example, of the observation</span>
<span class="sd">    data handled by the |Obs| sequence objects, which is not available in the `LahnH`</span>
<span class="sd">    example project).  To circumvent this problem, we disable the |Options.checkseries|</span>
<span class="sd">    option, which is one of the public options handled by the instance of class</span>
<span class="sd">    |Options| available as another attribute of module |pub|.  We again use &quot;with</span>
<span class="sd">    blocks&quot;, making sure the option (and the current working directory) changes only</span>
<span class="sd">    temporarily while loading the time-series:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_inputseries()</span>
<span class="sd">    ...     hp.load_factorseries()</span>
<span class="sd">    ...     hp.load_fluxseries()</span>
<span class="sd">    ...     hp.load_stateseries()</span>
<span class="sd">    ...     hp.load_simseries()</span>
<span class="sd">    ...     hp.load_obsseries()</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_modelseries()</span>
<span class="sd">    ...     hp.load_nodeseries()</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_allseries()</span>

<span class="sd">    The read time-series data equals the previously written one:</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    0.751154, 0.238461, -1.443848, -4.918849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    We mentioned the possibility for more granular control of *HydPy* by using the</span>
<span class="sd">    different objects handled by the |HydPy| object instead of using its convenience</span>
<span class="sd">    methods. Here is an elaborate example showing how to (re)load the states of an</span>
<span class="sd">    arbitrary simulation time step, which might be relevant for more complex workflows</span>
<span class="sd">    implementing data assimilation techniques:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.load_data(1)</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">       208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">       236.244147, 234.972621)</span>

<span class="sd">    Using the node sequence |Sim| as an example, we also show the inverse functionality</span>
<span class="sd">    of changing time-series values:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim = 0.0</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.save_data(2)</span>
<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 0.0, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.load_data(1)</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(8.901179)</span>

<span class="sd">    In the examples above, we keep all data in rapid access memory, which can be</span>
<span class="sd">    problematic when handling long time-series in huge *HydPy* projects.  When in</span>
<span class="sd">    trouble, first try to prepare only those time-series that are strictly required</span>
<span class="sd">    (very often, it is sufficient to call |HydPy.prepare_inputseries|,</span>
<span class="sd">    |HydPy.load_inputseries|, and |HydPy.prepare_simseries| only).  If this does not</span>
<span class="sd">    work in your project, you can read input data from and write output data to NetCDF</span>
<span class="sd">    files during simulation.  These follow the `NetCDF Climate and Forecast (CF)</span>
<span class="sd">    Metadata Conventions`_.  To benefit from this feature, assign |False| to the</span>
<span class="sd">    `allocate_ram` argument of the individual &quot;prepare series&quot; methods (which disables</span>
<span class="sd">    handling the time-series in RAM) and assign |True| to the respective &quot;jit&quot;</span>
<span class="sd">    arguments (which prepares the &quot;just-in-time&quot; file access).  The methods</span>
<span class="sd">    |HydPy.prepare_factorseries|, |HydPy.prepare_fluxseries|, and</span>
<span class="sd">    |HydPy.prepare_stateseries| deal with &quot;output sequences&quot; for which read data would</span>
<span class="sd">    be overwritten during the simulation and thus only support the `write_jit` argument.</span>
<span class="sd">    The |HydPy.prepare_inputseries| method, on the other hand, supports both the</span>
<span class="sd">    `read_jit` and the `write_jit` argument.  However, in most cases, only reading</span>
<span class="sd">    makes sense.  The argument `write_jit` is thought for when other methods (for</span>
<span class="sd">    example data assimilation approaches) modify the input data, and we need to keep</span>
<span class="sd">    track of these modifications:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_inputseries(allocate_ram=False, read_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_factorseries(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_fluxseries(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_stateseries(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_simseries(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_obsseries(allocate_ram=False, read_jit=True)</span>

<span class="sd">    By doing so, you lose the previously available time-series information.  We use</span>
<span class="sd">    function |attrready| to check this:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import attrready</span>
<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.inputs.t, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.factors.tc, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.states.sm, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.fluxes.qt, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(hp.nodes.dill.sequences.sim, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    Reloading the initial conditions and starting a new simulation run leads to the</span>
<span class="sd">    same results as the simulation run above:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_conditions()</span>
<span class="sd">    ...     hp.simulate()</span>

<span class="sd">    This time, reading input data from files happened during simulation.  Likewise, the</span>
<span class="sd">    calculated output data is not directly available in RAM but in different NetCDF</span>
<span class="sd">    files. To check all results are identical to those shown above, we must load them</span>
<span class="sd">    into RAM.  Therefore, we first need to prepare the |IOSequence.series| objects</span>
<span class="sd">    again:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries()</span>

<span class="sd">    By default, *HydPy* handles time-series data in simple text files (&quot;asc&quot; files):</span>

<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.filetype</span>
<span class="sd">    &#39;asc&#39;</span>

<span class="sd">    One way to prepare to load the results from the available NetCDF files instead is</span>
<span class="sd">    to set the |SequenceManager.filetype| attribute of the public |SequenceManager|</span>
<span class="sd">    object to &quot;nc&quot;:</span>

<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.filetype = &quot;nc&quot;</span>

<span class="sd">    Now we can load the previously written results into RAM (see the documentation on</span>
<span class="sd">    module |netcdftools| for further information) and inspect the results:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.sequencemanager.netcdfreading():</span>
<span class="sd">    ...     hp.load_modelseries()</span>
<span class="sd">    ...     hp.load_simseries()</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    0.751154, 0.238461, -1.443848, -4.918849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    You can handle time-series in RAM and allow just-in-time NetCDF file access at the</span>
<span class="sd">    same time.  Before showing how this works, we first disable both functionalities</span>
<span class="sd">    for all sequences and delete all previously written NetCDF files:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries(allocate_ram=False)</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.inputs.t, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.factors.tc, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.states.sm, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(model.sequences.fluxes.qt, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; attrready(hp.nodes.dill.sequences.sim, &quot;series&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     for filename in os.listdir(f&quot;LahnH/series/default&quot;):</span>
<span class="sd">    ...         if &quot;input&quot; not in filename:</span>
<span class="sd">    ...             os.remove(f&quot;LahnH/series/default/{filename}&quot;)</span>

<span class="sd">    We again call method |HydPy.prepare_allseries|, but now with assigning |True| to</span>
<span class="sd">    the arguments `allocate_ram` and `jit`:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries(allocate_ram=True, jit=True)</span>

<span class="sd">    After another simulation run, all input data (read during simulation) and output</span>
<span class="sd">    data (calculated during simulation) are directly available:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_conditions()</span>
<span class="sd">    ...     hp.simulate()</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    0.751154, 0.238461, -1.443848, -4.918849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    After subsequent deallocation and allocation for refreshing RAM, reading the</span>
<span class="sd">    previously written NetCDF files makes the same data available:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries(allocate_ram=False)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries(allocate_ram=True)</span>
<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.sequencemanager.netcdfreading():</span>
<span class="sd">    ...     hp.load_modelseries()</span>
<span class="sd">    ...     hp.load_simseries()</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    0.751154, 0.238461, -1.443848, -4.918849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">deviceorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Element</span><span class="p">]]</span>

    <span class="n">_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">]</span>
    <span class="n">_elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projectname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">projectname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">projectname</span> <span class="o">=</span> <span class="n">projectname</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">networkmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">NetworkManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">controlmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">ControlManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">SequenceManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">conditionmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">ConditionManager</span><span class="p">()</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">]()</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">_get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The currently handled |Node| objects.</span>

<span class="sd">        You are allowed to get, set and delete the currently handled nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        &gt;&gt;&gt; del hp.nodes</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The actual HydPy instance does not handle any nodes at the \</span>
<span class="sd">moment.</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes = &quot;dill&quot;, &quot;lahn_1&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;)</span>

<span class="sd">        However, note that doing so might result in erroneous networks and that you,</span>
<span class="sd">        even in case of correctness, must most likely call method |HydPy.update_devices|</span>
<span class="sd">        before performing the next simulation run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The actual HydPy instance does not handle any nodes at the moment.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_set_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">_del_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">elements</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span>
        <span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span>
    <span class="p">]()</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">_get_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The currently handled |Element| objects.</span>

<span class="sd">        You are allowed to get, set and delete the currently handled elements:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                 &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">                 &quot;stream_lahn_2_lahn_3&quot;)</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The actual HydPy instance does not handle any elements \</span>
<span class="sd">at the moment.</span>

<span class="sd">        &gt;&gt;&gt; hp.elements = &quot;land_dill&quot;, &quot;land_lahn_1&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>

<span class="sd">        However, note that doing so might result in erroneous networks</span>
<span class="sd">        and that you, even in case of correctness, must most likely call</span>
<span class="sd">        method |HydPy.update_devices| before performing the next</span>
<span class="sd">        simulation run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span>
        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The actual HydPy instance does not handle any elements at the moment.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">elements</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_set_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">_del_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="HydPy.prepare_everything">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_everything">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_everything</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience method to make the actual |HydPy| instance runnable.</span>

<span class="sd">        Method |HydPy.prepare_everything| is the fastest approach to get a runnable</span>
<span class="sd">        |HydPy| object.  You only need to import class |Hydpy|, initialise it with the</span>
<span class="sd">        project name, define the simulation period via the |Timegrids| object of module</span>
<span class="sd">        |pub|, and call method |HydPy.prepare_everything| (in this documentation, we</span>
<span class="sd">        first need to prepare the example project via function |prepare_full_example_1|</span>
<span class="sd">        and change the current working directory via class |TestIO|):</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, round_, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp.prepare_everything()</span>

<span class="sd">        Now you can start a simulation run and inspect the calculated time-series of</span>
<span class="sd">        all relevant sequences.  We take the discharge values of the flux sequence</span>
<span class="sd">        |hland_fluxes.QT| of |Element| object `land_dill` and of the node sequence</span>
<span class="sd">        |Sim| of |Node| object `dill` as examples, which provide the same information:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.elements.land_dill.model.sequences.fluxes.qt.series)</span>
<span class="sd">        11.78038, 8.901179, 7.131072, 6.017787</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">        11.78038, 8.901179, 7.131072, 6.017787</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_network</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_conditions</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warnmissingobsfile</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_nodeseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_inputseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.prepare_network">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_network">[docs]</a>
    <span class="nd">@printtools</span><span class="o">.</span><span class="n">print_progress</span>
    <span class="k">def</span> <span class="nf">prepare_network</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load all network files as |Selections| (stored in module |pub|) and assign</span>
<span class="sd">        the &quot;complete&quot; selection to the |HydPy| object.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.selections</span>

<span class="sd">        First, we call function |prepare_full_example_1| to prepare the `LahnH` example</span>
<span class="sd">        project, including its network files `headwaters.py`, `nonheadwaters.py`, and</span>
<span class="sd">        `streams.py`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">        Directly after initialising class |HydPy|, neither the resulting object nor</span>
<span class="sd">        module |pub| contain any information stemming from the network files:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pub.selections</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute selections of module \</span>
<span class="sd">`pub` is not defined at the moment.</span>

<span class="sd">        By calling the method |HydPy.prepare_network|, one loads all three network</span>
<span class="sd">        files into separate |Selection| objects, all handled by the |Selections| object</span>
<span class="sd">        of module |pub|.  Additionally, there is a |Selection| object named `complete`,</span>
<span class="sd">        covering all |Node| and |Element| objects of the other |Selection| objects:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; pub.selections</span>
<span class="sd">        Selections(&quot;complete&quot;, &quot;headwaters&quot;, &quot;nonheadwaters&quot;, &quot;streams&quot;)</span>

<span class="sd">        &gt;&gt;&gt; pub.selections.headwaters &lt;= pub.selections.complete</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pub.selections.nonheadwaters &lt;= pub.selections.complete</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pub.selections.streams &lt;= pub.selections.complete</span>
<span class="sd">        True</span>

<span class="sd">        Initially, the |HydPy| object is aware of the complete set of |Node| and</span>
<span class="sd">        |Element| objects:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes == pub.selections.complete.nodes</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements == pub.selections.complete.elements</span>
<span class="sd">        True</span>

<span class="sd">        See the documentation on method |HydPy.update_devices| on how to &quot;activate|</span>
<span class="sd">        another selection in the safest manner.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">()</span>
        <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span> <span class="o">+=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">networkmanager</span><span class="o">.</span><span class="n">load_files</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_devices</span><span class="p">(</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span><span class="o">.</span><span class="n">complete</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_models">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_models">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_models</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read all control files related to the current |Element| objects, initialise</span>
<span class="sd">        the defined models, and prepare their parameter values.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        First, we call function |prepare_full_example_1| to prepare the `LahnH` example</span>
<span class="sd">        project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">        Now we can initialise a |HydPy| instance accordingly and call its methods</span>
<span class="sd">        |HydPy.prepare_network| and |HydPy.prepare_models|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, round_, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>

<span class="sd">        As a result, each |Element| object handles a model of the type and with the</span>
<span class="sd">        parameter values defined in the relevant control file:</span>

<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.name</span>
<span class="sd">        &#39;hland_v1&#39;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.parameters.control.area</span>
<span class="sd">        area(692.3)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.model.name</span>
<span class="sd">        &#39;musk_classic&#39;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.model.parameters.control.nmbsegments</span>
<span class="sd">        nmbsegments(lag=0.583)</span>

<span class="sd">        The `LahnH` example project comes with one auxiliary file, named `land.py`.</span>
<span class="sd">        This file defines general parameter values, valid for all single parameter</span>
<span class="sd">        objects of the different model instances referencing this file via the `auxfile`</span>
<span class="sd">        keyword argument.  The following examples use the `land_dill` element to show</span>
<span class="sd">        that the affected parameters are also correctly prepared:</span>

<span class="sd">        &gt;&gt;&gt; control = hp.elements.land_dill.model.parameters.control</span>
<span class="sd">        &gt;&gt;&gt; control.alpha</span>
<span class="sd">        alpha(1.0)</span>
<span class="sd">        &gt;&gt;&gt; control.pcorr</span>
<span class="sd">        pcorr(1.0)</span>
<span class="sd">        &gt;&gt;&gt; control.resparea</span>
<span class="sd">        resparea(True)</span>
<span class="sd">        &gt;&gt;&gt; control.icmax</span>
<span class="sd">        icmax(field=1.0, forest=1.5)</span>

<span class="sd">        We show that the individual |hland_control.IcMax| values for two different</span>
<span class="sd">        elements are different to demonstrate that parameter values defined within a</span>
<span class="sd">        master control file (|hland_control.ZoneType|) can affect the actual values of</span>
<span class="sd">        parameters defined in auxiliary control files:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(control.icmax.values)</span>
<span class="sd">        1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5</span>
<span class="sd">        &gt;&gt;&gt; round_(</span>
<span class="sd">        ...     hp.elements.land_lahn_2.model.parameters.control.icmax.values)</span>
<span class="sd">        1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5</span>

<span class="sd">        Missing parameter information in auxiliary files results in errors like the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; filepath = &quot;LahnH/control/default/land.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(filepath) as infile:</span>
<span class="sd">        ...         text = infile.read().replace(&quot;alpha(1.0)&quot;, &quot;&quot;)</span>
<span class="sd">        ...     with open(filepath, &quot;w&quot;) as outfile:</span>
<span class="sd">        ...         outfile.write(text)</span>
<span class="sd">        ...     hp.prepare_models()   # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to initialise the model object of element \</span>
<span class="sd">`land_dill`, the following error occurred: While trying to load the control file \</span>
<span class="sd">`...land_dill.py`, the following error occurred: While trying to extract information \</span>
<span class="sd">for parameter `alpha` from file `land`, the following error occurred: The selected \</span>
<span class="sd">auxiliary file does not define value(s) for parameter `alpha`.</span>

<span class="sd">        Completely wrong control files result in the following error:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(&quot;LahnH/control/default/land_dill.py&quot;, &quot;w&quot;):</span>
<span class="sd">        ...         pass</span>
<span class="sd">        ...     hp.prepare_models()   # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to initialise the model object of element \</span>
<span class="sd">`land_dill`, the following error occurred: Model parameters cannot be loaded from \</span>
<span class="sd">control file `...land_dill.py`.  Please refer to the HydPy documentation on how to \</span>
<span class="sd">prepare control files properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.init_models">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.init_models">[docs]</a>
    <span class="k">def</span> <span class="nf">init_models</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated! Use method |HydPy.prepare_models| instead.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import warn_later</span>
<span class="sd">        &gt;&gt;&gt; with warn_later(), mock.patch.object(HydPy, &quot;prepare_models&quot;) as mocked:</span>
<span class="sd">        ...     hp = HydPy(&quot;test&quot;)</span>
<span class="sd">        ...     hp.init_models()</span>
<span class="sd">        HydPyDeprecationWarning: Method `init_models` of class `HydPy` is \</span>
<span class="sd">deprecated.  Use method `prepare_models` instead.</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call()]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Method `init_models` of class `HydPy` is deprecated.  Use method &quot;</span>
            <span class="s2">&quot;`prepare_models` instead.&quot;</span><span class="p">,</span>
            <span class="n">exceptiontools</span><span class="o">.</span><span class="n">HydPyDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.save_controls">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_controls">[docs]</a>
    <span class="k">def</span> <span class="nf">save_controls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">simulationstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">auxfiler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">auxfiletools</span><span class="o">.</span><span class="n">Auxfiler</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the control files of all current |Element| objects.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        We use the `LahnH` example project to demonstrate how to write a complete set</span>
<span class="sd">        of parameter control files.  For convenience, we let function</span>
<span class="sd">        |prepare_full_example_2| prepare a fully functional |HydPy| object, handling</span>
<span class="sd">        seven |Element| objects controlling four |hland_v1| and three |musk_classic|</span>
<span class="sd">        application models:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        At first, there is only one control subfolder named &quot;default&quot;, containing the</span>
<span class="sd">        seven master control files used in the step above:</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     os.listdir(&quot;LahnH/control&quot;)</span>
<span class="sd">        [&#39;default&#39;]</span>

<span class="sd">        Next, we use the |ControlManager| to create a new directory and write analogue</span>
<span class="sd">        control files into it:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls()</span>
<span class="sd">        ...     sorted(os.listdir(&quot;LahnH/control&quot;))</span>
<span class="sd">        [&#39;default&#39;, &#39;newdir&#39;]</span>

<span class="sd">        We focus our examples on the (shorter) control files of the application model</span>
<span class="sd">        |musk_classic|.  These control files define the values of the parameters</span>
<span class="sd">        |musk_control.NmbSegments| and |musk_control.Coefficients| via the keyword</span>
<span class="sd">        arguments `lag` and `damp`.  For the river channel connecting the outlets of</span>
<span class="sd">        subcatchment `lahn_1` and `lahn_2`, the `lag` value is 0.583 days, and the</span>
<span class="sd">        `damp` value is zero:</span>

<span class="sd">        &gt;&gt;&gt; model = hp.elements.stream_lahn_1_lahn_2.model</span>
<span class="sd">        &gt;&gt;&gt; model.parameters.control</span>
<span class="sd">        nmbsegments(lag=0.583)</span>
<span class="sd">        coefficients(damp=0.0)</span>

<span class="sd">        Its control file&#39;s name equals the element&#39;s name:</span>

<span class="sd">        &gt;&gt;&gt; dir_ = &quot;LahnH/control/newdir/&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(lag=0.583)</span>
<span class="sd">        coefficients(damp=0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        The time step information stems from the |Timegrid| object available via |pub|:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.stepsize</span>
<span class="sd">        Period(&quot;1d&quot;)</span>

<span class="sd">        Use the |Auxfiler| class to avoid redefining the same parameter values in</span>
<span class="sd">        multiple control files.  We prepare an |Auxfiler| object that handles the</span>
<span class="sd">        model&#39;s two parameters discussed above:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Auxfiler</span>
<span class="sd">        &gt;&gt;&gt; auxfiler = Auxfiler(&quot;musk_classic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; auxfiler.musk_classic.add_parameter(</span>
<span class="sd">        ...     model.parameters.control.nmbsegments, filename=&quot;stream&quot;)</span>
<span class="sd">        &gt;&gt;&gt; auxfiler.musk_classic.add_parameter(</span>
<span class="sd">        ...     model.parameters.control.coefficients, filename=&quot;stream&quot;)</span>

<span class="sd">        When passing the |Auxfiler| object to the method |HydPy.save_controls|, the</span>
<span class="sd">        control file of element `stream_lahn_1_lahn_2` does not define the values of</span>
<span class="sd">        both parameters on its own but references the auxiliary file `stream.py`</span>
<span class="sd">        instead:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls(auxfiler=auxfiler)</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(auxfile=&quot;stream&quot;)</span>
<span class="sd">        coefficients(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        `stream.py` contains the actual value definitions:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(lag=0.583)</span>
<span class="sd">        coefficients(damp=0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        The |musk_classic| model of element `stream_lahn_2_lahn_3` defines the same</span>
<span class="sd">        value for parameter |musk_control.Coefficients| but a different one for</span>
<span class="sd">        parameter |musk_control.NmbSegments|.  Hence, only |musk_control.Coefficients|</span>
<span class="sd">        can reference the control file `stream.py`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_2_lahn_3.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(lag=0.417)</span>
<span class="sd">        coefficients(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        Another option is to pass alternative step size information.  The</span>
<span class="sd">        `simulationstep` information, which is no integral part of control files but</span>
<span class="sd">        helpful in testing them, has no impact on the written data.  However, passing</span>
<span class="sd">        an alternative `parameterstep` information changes the written values of</span>
<span class="sd">        time-dependent parameters both in the primary and the auxiliary control files:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls(</span>
<span class="sd">        ...         auxfiler=auxfiler, parameterstep=&quot;2d&quot;, simulationstep=&quot;1h&quot;)</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(auxfile=&quot;stream&quot;)</span>
<span class="sd">        coefficients(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(lag=0.2915)</span>
<span class="sd">        coefficients(damp=0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_2_lahn_3.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.musk_classic import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        nmbsegments(lag=0.2085)</span>
<span class="sd">        coefficients(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_controls</span><span class="p">(</span>
            <span class="n">parameterstep</span><span class="o">=</span><span class="n">parameterstep</span><span class="p">,</span>
            <span class="n">simulationstep</span><span class="o">=</span><span class="n">simulationstep</span><span class="p">,</span>
            <span class="n">auxfiler</span><span class="o">=</span><span class="n">auxfiler</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.load_conditions">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_conditions">[docs]</a>
    <span class="k">def</span> <span class="nf">load_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load all currently relevant initial conditions.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        The following examples demonstrate both the functionality of method</span>
<span class="sd">        |HydPy.load_conditions| and |HydPy.save_conditions| based on the `LahnH`</span>
<span class="sd">        project, which we prepare via function |prepare_full_example_2|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        Our |HydPy| instance `hp` is ready for the first simulation run, meaning the</span>
<span class="sd">        required initial conditions are available already.  First, we start a</span>
<span class="sd">        simulation run covering the whole initialisation period and inspect the</span>
<span class="sd">        resulting soil moisture values of |Element| `land_dill`, handled by a sequence</span>
<span class="sd">        object of type |hland_states.SM|:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; sm = hp.elements.land_dill.model.sequences.states.sm</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">           208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">           235.597338, 234.329294)</span>

<span class="sd">        By default, method |HydPy.load_conditions| always (re)loads the initial</span>
<span class="sd">        conditions from the directory with its name matching the start date of the</span>
<span class="sd">        simulation period, which we prove by also showing the related content of the</span>
<span class="sd">        respective condition file `land_dill.py`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/init_1996_01_01_00_00_00/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">        Now we perform two consecutive runs, covering the first and the second half of</span>
<span class="sd">        the initialisation period, respectively, and write, in both cases, the</span>
<span class="sd">        resulting final conditions to disk:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.save_conditions()</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.save_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">           208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">           235.597338, 234.329294)</span>

<span class="sd">        Analogous to method |HydPy.load_conditions|, method |HydPy.save_conditions|</span>
<span class="sd">        writes the resulting conditions to a directory with its name matching the end</span>
<span class="sd">        date of the simulation period, which we prove by reloading the conditions</span>
<span class="sd">        related to the middle of the initialisation period and showing the relevant</span>
<span class="sd">        file content:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/init_1996_01_03_00_00_00/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        ...         print(lines[12])</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        You can define another directory by assigning a different name to the attribute</span>
<span class="sd">        |FileManager.currentdir| of the actual |ConditionManager| instance:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.conditionmanager.currentdir = &quot;test&quot;</span>
<span class="sd">        ...     hp.save_conditions()</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/test/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        ...         print(lines[12])</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        This change remains permanent until you undo it manually:</span>

<span class="sd">        &gt;&gt;&gt; sm(0.0)</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     del pub.conditionmanager.currentdir</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_conditions</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_conditions">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_conditions">[docs]</a>
    <span class="k">def</span> <span class="nf">save_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save all currently relevant final conditions.</span>

<span class="sd">        See the documentation on method |HydPy.load_conditions| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_conditions</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.trim_conditions">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.trim_conditions">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check all values of the condition sequences (|StateSequence| and</span>
<span class="sd">        |LogSequence| objects) for boundary violations and fix them if necessary.</span>

<span class="sd">        We use the `LahnH` example project to explain the functionality of the method</span>
<span class="sd">        |HydPy.trim_conditions|, which gives no response when all conditions are</span>
<span class="sd">        correctly set:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True):</span>
<span class="sd">        ...     hp.trim_conditions()</span>

<span class="sd">        If you try, for example, to set interception capacities (|hland_states.Ic|)</span>
<span class="sd">        that violate the maximum capacity (|hland_control.IcMax|), you get a direct</span>
<span class="sd">        response based on function |trim|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import warn_later</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True), warn_later():</span>
<span class="sd">        ...     hp.elements.land_dill.model.sequences.states.ic(1.2)</span>
<span class="sd">        UserWarning: For variable `ic` of element `land_dill` at least one value \</span>
<span class="sd">needed to be trimmed.  The old and the new value(s) are \</span>
<span class="sd">`1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2` and \</span>
<span class="sd">`1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2`, respectively.</span>

<span class="sd">        However, changing the boundaries themselves without adjusting the conditions</span>
<span class="sd">        cannot be detected automatically.  Whenever in doubt, call method</span>
<span class="sd">        |HydPy.trim_conditions| explicitly:</span>

<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.parameters.control.icmax(1.1)</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True), warn_later():</span>
<span class="sd">        ...     hp.trim_conditions()</span>
<span class="sd">        UserWarning: For variable `ic` of element `land_dill` at least one value \</span>
<span class="sd">needed to be trimmed.  The old and the new value(s) are \</span>
<span class="sd">`1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2` and \</span>
<span class="sd">`1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1`, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">trim_conditions</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.reset_conditions">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.reset_conditions">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset all currently relevant condition sequences.</span>

<span class="sd">        Method |HydPy.reset_conditions| is the most convenient way to perform</span>
<span class="sd">        simulations repeatedly for the same period, each time starting from the same</span>
<span class="sd">        initial conditions, e.g. for parameter calibration. Each |StateSequence| and</span>
<span class="sd">        |LogSequence| object remembers the last assigned values and can reactivate them</span>
<span class="sd">        for the mentioned purpose.</span>

<span class="sd">        For demonstration, we perform a simulation for the `LahnH` example project</span>
<span class="sd">        spanning four days:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import print_values</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        Just repeating the simulation gives different results due to applying the final</span>
<span class="sd">        states of the first simulation run as the initial states of the second run:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        26.218473, 25.039964, 24.205384, 23.296241</span>

<span class="sd">        Calling |HydPy.reset_conditions| first allows repeating the first simulation</span>
<span class="sd">        run exactly multiple times:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">reset_conditions</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConditionsType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A nested dictionary that contains the values of all condition sequences of</span>
<span class="sd">        all currently handled models.</span>

<span class="sd">        The primary  purpose of property |HydPy.conditions| is similar to method</span>
<span class="sd">        |HydPy.reset_conditions|, to allow to perform repeated calculations starting</span>
<span class="sd">        from the same initial conditions.  Nevertheless, |HydPy.conditions| is more</span>
<span class="sd">        flexible when to handling multiple conditions, which can, for example, be</span>
<span class="sd">        useful for applying ensemble-based assimilation algorithms.</span>

<span class="sd">        For demonstration, we perform simulations for the `LahnH` example project</span>
<span class="sd">        spanning the first three months of 1996.  We begin with a preparation run</span>
<span class="sd">        beginning on January 1 and ending on February 20:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO, print_values</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-04-01&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp.prepare_everything()</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series[48:52])</span>
<span class="sd">        70.553509, 94.344086, nan, nan</span>

<span class="sd">        At the end of the preparation run, a snow layer is covering the Lahn catchment.</span>
<span class="sd">        In the `lahn_1` subcatchment, this snow layer contains 19.5 mm of frozen water</span>
<span class="sd">        and 1.7 mm of liquid water:</span>

<span class="sd">        &gt;&gt;&gt; lahn1_states = hp.elements.land_lahn_1.model.sequences.states</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        1.745963</span>

<span class="sd">        Now we save the current conditions and perform the first simulation run from</span>
<span class="sd">        the 20th day of February until the end of March:</span>

<span class="sd">        &gt;&gt;&gt; conditions = hp.conditions</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-04-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; first = hp.nodes.lahn_3.sequences.sim.series.copy()</span>
<span class="sd">        &gt;&gt;&gt; print_values(first[48:52])</span>
<span class="sd">        0.0, 0.0, 85.150677, 63.902098</span>

<span class="sd">        To exactly repeat the last simulation run, we assign the memorised conditions</span>
<span class="sd">        to property |HydPy.conditions|:</span>

<span class="sd">        &gt;&gt;&gt; hp.conditions = conditions</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        1.745963</span>

<span class="sd">        All discharge values of the second simulation run are identical to the ones of</span>
<span class="sd">        the first simulation run:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-04-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; second = hp.nodes.lahn_3.sequences.sim.series.copy()</span>
<span class="sd">        &gt;&gt;&gt; print_values(second[48:52])</span>
<span class="sd">        0.0, 0.0, 85.150677, 63.902098</span>
<span class="sd">        &gt;&gt;&gt; all(first == second)</span>
<span class="sd">        True</span>

<span class="sd">        We selected the snow period as an example due to potential problems with the</span>
<span class="sd">        limited water holding capacity of the snow layer, which depends on the ice</span>
<span class="sd">        content of the snow layer (|hland_states.SP|) and the relative water holding</span>
<span class="sd">        capacity (|hland_control.WHC|).  Due to this restriction, problems can occur.</span>
<span class="sd">        To give an example, we set |hland_control.WHC| to zero temporarily, apply the</span>
<span class="sd">        memorised conditions, and finally reset the original values of |</span>
<span class="sd">        hland_control.WHC|:</span>

<span class="sd">        &gt;&gt;&gt; for element in hp.elements.catchment:</span>
<span class="sd">        ...     element.whc = element.model.parameters.control.whc.values</span>
<span class="sd">        ...     element.model.parameters.control.whc = 0.0</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(False):</span>
<span class="sd">        ...     hp.conditions = conditions</span>
<span class="sd">        &gt;&gt;&gt; for element in hp.elements.catchment:</span>
<span class="sd">        ...     element.model.parameters.control.whc = element.whc</span>

<span class="sd">        Without any water holding capacity of the snow layer, its water content is zero</span>
<span class="sd">        despite the actual memorised value of 1.7 mm:</span>

<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        0.0</span>

<span class="sd">        What is happening in such conflicts partly depends on the implementation of the</span>
<span class="sd">        respective application model.  For safety, we suggest setting the option</span>
<span class="sd">        |Options.warntrim| to |True| before resetting conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">conditions</span>

    <span class="nd">@conditions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">:</span> <span class="n">ConditionsType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="n">conditions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">networkproperties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span>
        <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Some properties of the network defined by the currently relevant |Node| and</span>
<span class="sd">        |Element| objects.</span>

<span class="sd">        See the documentation on method |HydPy.print_networkproperties| for further</span>
<span class="sd">        information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;Number of nodes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
            <span class="s2">&quot;Number of elements&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">),</span>
            <span class="s2">&quot;Number of end nodes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endnodes</span><span class="p">),</span>
            <span class="s2">&quot;Number of distinct networks&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segregatednetworks</span><span class="p">),</span>
            <span class="s2">&quot;Applied node variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="s2">&quot;Applied model types&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modeltypes</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="HydPy.print_networkproperties">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.print_networkproperties">[docs]</a>
    <span class="k">def</span> <span class="nf">print_networkproperties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print some properties of the network defined by the currently relevant</span>
<span class="sd">        |Node| and |Element| objects.</span>

<span class="sd">        |HydPy.print_networkproperties| is for convenience to summarise specific</span>
<span class="sd">        network measures like |HydPy.segregatednetworks|.</span>

<span class="sd">        The `LahnH` example project defines a small, single network, with all</span>
<span class="sd">        catchments ultimately discharging to node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        &gt;&gt;&gt; hp.print_networkproperties()</span>
<span class="sd">        Number of nodes: 4</span>
<span class="sd">        Number of elements: 7</span>
<span class="sd">        Number of end nodes: 1</span>
<span class="sd">        Number of distinct networks: 1</span>
<span class="sd">        Applied node variables: Q (4)</span>
<span class="sd">        Applied model types: hland_v1 (4) and musk_classic (3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">networkproperties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">nmb</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">nmb</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All currently relevant |Node| objects that define a downstream endpoint of</span>
<span class="sd">        the network.</span>

<span class="sd">        The `LahnH` example project defines a small, single network, with all</span>
<span class="sd">        catchments ultimately discharging to node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_3&quot;)</span>

<span class="sd">        After breaking the connection between node `lahn_1` and its downstream river</span>
<span class="sd">        channel element `stream_lahn_1_lahn2`, `lahn_1` also becomes an end node:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_1.exits.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; del hp.nodes.lahn_1.exits.stream_lahn_1_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_lahn_1_lahn_2.inlets.lahn_1</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        Even with a proper connection to a downstream element, a node counts as an end</span>
<span class="sd">        node as long as these elements are not part of the currently relevant network</span>
<span class="sd">        (meaning, currently handled by the |HydPy| object):</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_dill_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">        Elements(&quot;stream_dill_lahn_2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        Connections with &quot;remote&quot; elements are considered irrelevant:</span>

<span class="sd">        &gt;&gt;&gt; stream = hp.elements.stream_lahn_2_lahn_3</span>
<span class="sd">        &gt;&gt;&gt; stream.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers += stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endnodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">exits</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">receivers</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endnodes</span> <span class="o">+=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">endnodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segregatednetworks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of segregated networks defined by the currently relevant |Node|</span>
<span class="sd">        and |Element| objects.</span>

<span class="sd">        Each end node (as defined by property |HydPy.endnodes|) eventually defines a</span>
<span class="sd">        single network, segregated from the networks of other end nodes.  Due to the</span>
<span class="sd">        `LahnH` example project defining only a single end node, there can be only one</span>
<span class="sd">        segregate network, accordingly:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;,</span>
<span class="sd">                            &quot;land_lahn_3&quot;, &quot;stream_dill_lahn_2&quot;,</span>
<span class="sd">                            &quot;stream_lahn_1_lahn_2&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        Revisiting the examples of the documentation on property |HydPy.endnodes|, we</span>
<span class="sd">        get the similar results.  Note that the segregated networks are always</span>
<span class="sd">        |Selection| objects that do not overlap each other (meaning, no |Node| or</span>
<span class="sd">        |Element| object occurs more than one time):</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_1.exits.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; del hp.nodes.lahn_1.exits.stream_lahn_1_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_lahn_1_lahn_2.inlets.lahn_1</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                            &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">                            &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_dill_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">        Elements(&quot;stream_dill_lahn_2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.dill</span>
<span class="sd">        Selection(&quot;dill&quot;,</span>
<span class="sd">                  nodes=&quot;dill&quot;,</span>
<span class="sd">                  elements=&quot;land_dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                            &quot;stream_lahn_1_lahn_2&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>


<span class="sd">        &gt;&gt;&gt; stream = hp.elements.stream_lahn_2_lahn_3</span>
<span class="sd">        &gt;&gt;&gt; stream.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers += stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.dill</span>
<span class="sd">        Selection(&quot;dill&quot;,</span>
<span class="sd">                  nodes=&quot;dill&quot;,</span>
<span class="sd">                  elements=&quot;land_dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_2</span>
<span class="sd">        Selection(&quot;lahn_2&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_2&quot;,</span>
<span class="sd">                  elements=(&quot;land_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;))</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_3&quot;,</span>
<span class="sd">                  elements=(&quot;land_lahn_3&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        In all examples above, the number of the end nodes and the number of the</span>
<span class="sd">        segregated networks are identical, which is not the case when two or more</span>
<span class="sd">        networks share the same network.  We restore our original network and add two</span>
<span class="sd">        additional end nodes, `nowhere` and `somewhere`,  linking the first one with</span>
<span class="sd">        element `stream_lahn_2_lahn_3` and the second one with the additional element</span>
<span class="sd">        `stream_lahn_1_nowhere`, which we connect to node `lahn_1`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Element</span>
<span class="sd">        &gt;&gt;&gt; _ = Element(&quot;stream_lahn_2_lahn_3&quot;, outlets=&quot;nowhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += &quot;nowhere&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements += Element(&quot;stream_lahn_1_nowhere&quot;,</span>
<span class="sd">        ...                        inlets=&quot;lahn_1&quot;,</span>
<span class="sd">        ...                        outlets=&quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += &quot;somewhere&quot;</span>

<span class="sd">        Now there are three end nodes but only two segregated networks, as node</span>
<span class="sd">        `nowhere` does not reference any upstream devices not also referenced by node</span>
<span class="sd">        `lahn_3`.  The unique feature of element `lahn_3` and `stream_lahn_1_nowhere`</span>
<span class="sd">        is that they drain to either node `lahn_3` or `somewhere` but not both, which</span>
<span class="sd">        is why they are the only members of selection `lahn_3` and `somewhere`,</span>
<span class="sd">        respectively:</span>

<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_3&quot;, &quot;nowhere&quot;, &quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_3&quot;, &quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_3&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.somewhere</span>
<span class="sd">        Selection(&quot;somewhere&quot;,</span>
<span class="sd">                  nodes=&quot;somewhere&quot;,</span>
<span class="sd">                  elements=&quot;stream_lahn_1_nowhere&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sels1</span><span class="p">,</span> <span class="n">sels2</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">(),</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">()</span>
        <span class="n">complete</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">(</span><span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endnodes</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">search_upstream</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">sels1</span><span class="o">.</span><span class="n">add_selections</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
            <span class="n">sels2</span><span class="o">.</span><span class="n">add_selections</span><span class="p">(</span><span class="n">sel</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sel1</span><span class="p">,</span> <span class="n">sel2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">sels1</span><span class="p">,</span> <span class="n">sels2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sel1</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">sel2</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">sel1</span> <span class="o">-=</span> <span class="n">sel2</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sels1</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sels1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sels1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sels1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summary of all |Node.variable| properties of the currently relevant |Node|</span>
<span class="sd">        objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.variables</span>
<span class="sd">        {&#39;Q&#39;: 4}</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import FusedVariable, Node</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.inputs import hland_T</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += Node(&quot;test&quot;, variable=FusedVariable(&quot;T&quot;, hland_T))</span>
<span class="sd">        &gt;&gt;&gt; hp.variables</span>
<span class="sd">        {&#39;Q&#39;: 4, FusedVariable(&quot;T&quot;, hland_T): 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">Type</span><span class="p">[</span><span class="n">sequencetools</span><span class="o">.</span><span class="n">InputSequence</span><span class="p">],</span>
                <span class="n">Type</span><span class="p">[</span><span class="n">sequencetools</span><span class="o">.</span><span class="n">OutputSequence</span><span class="p">],</span>
                <span class="n">devicetools</span><span class="o">.</span><span class="n">FusedVariable</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="nb">int</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tuple_</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">modeltypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summary of all |Model| subclasses of the currently relevant |Element|</span>
<span class="sd">        objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.modeltypes</span>
<span class="sd">        {&#39;unprepared&#39;: 7}</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        &gt;&gt;&gt; hp.modeltypes</span>
<span class="sd">        {&#39;hland_v1&#39;: 4, &#39;musk_classic&#39;: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">modeltypes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">getattr_</span><span class="p">(</span>
                <span class="n">element</span><span class="p">,</span> <span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="s2">&quot;unprepared&quot;</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">Model</span>
            <span class="p">)</span>
            <span class="n">modeltypes</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">modeltypes</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">selection</span><span class="p">:</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Selection as input&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Devices as input&quot;&quot;&quot;</span>

<div class="viewcode-block" id="HydPy.update_devices">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.update_devices">[docs]</a>
    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the order in which method |HydPy.simulate| processes the currently</span>
<span class="sd">        relevant |Node| and |Element| objects.</span>

<span class="sd">        Eventually passed |Node| and |Element| objects (for example, contained within a</span>
<span class="sd">        |Selection| object) replace existing ones.</span>

<span class="sd">        As described in the documentation on the method |HydPy.prepare_network|, a</span>
<span class="sd">        |HydPy| object usually starts with the &quot;complete&quot; network of the considered</span>
<span class="sd">        project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        The safest approach to &quot;activate&quot; another selection is to use the method</span>
<span class="sd">        |HydPy.update_devices|.  The first option is to pass a complete |Selection|</span>
<span class="sd">        object:</span>

<span class="sd">        &gt;&gt;&gt; pub.selections.headwaters</span>
<span class="sd">        Selection(&quot;headwaters&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_1&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_1&quot;))</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>

<span class="sd">        Method |HydPy.update_devices| automatically updates the `deviceorder`, assuring</span>
<span class="sd">        method |HydPy.simulate| processes &quot;upstream&quot; model instances before it</span>
<span class="sd">        processes their &quot;downstream&quot; neighbours:</span>

<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_dill</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        dill</span>
<span class="sd">        lahn_1</span>

<span class="sd">        Second, you can pass some nodes only, which by the way removes the old elements:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(nodes=&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements()</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        dill</span>

<span class="sd">        Third, you can pass some elements only, which by the way removes the old nodes:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes()</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_dill</span>
<span class="sd">        land_lahn_1</span>

<span class="sd">        Fourth, you can pass nodes and elements at the same time:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(nodes=&quot;dill&quot;,</span>
<span class="sd">        ...                   elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_dill</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        dill</span>

<span class="sd">        Fifth, you can pass no argument at all, which only updates the device order:</span>

<span class="sd">        &gt;&gt;&gt; del hp.nodes.dill</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_dill</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        dill</span>
<span class="sd">        &gt;&gt;&gt; hp.update_devices()</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_dill</span>
<span class="sd">        land_lahn_1</span>

<span class="sd">        Method |HydPy.update_devices| does not allow to pass single devices and devices</span>
<span class="sd">        contained within a selection at the same time:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters,</span>
<span class="sd">        ...                   nodes=&quot;dill&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Method `update_devices` of class `HydPy` does not allow to use \</span>
<span class="sd">both the `selection` argument and the `nodes` or  the `elements` argument at the same \</span>
<span class="sd">time.</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters,</span>
<span class="sd">        ...                   elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Method `update_devices` of class `HydPy` does not allow to use \</span>
<span class="sd">both the `selection` argument and the `nodes` or  the `elements` argument at the same \</span>
<span class="sd">time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">elements</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Method `update_devices` of class `HydPy` does not allow to use &quot;</span>
                    <span class="s2">&quot;both the `selection` argument and the `nodes` or  the `elements` &quot;</span>
                    <span class="s2">&quot;argument at the same time.&quot;</span>
                <span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
            <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span>
            <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">devices</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">create_directedgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="n">names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">devices</span> <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">methodorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All methods of the currently relevant |Node| and |Element| objects to be</span>
<span class="sd">        processed by method |HydPy.simulate| during a simulation time step, ordered in</span>
<span class="sd">        a correct execution sequence.</span>

<span class="sd">        Property |HydPy.methodorder| should be of interest to framework developers only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">funcs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">attrready</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="p">,</span> <span class="s2">&quot;sequencemanager&quot;</span><span class="p">):</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">read_netcdfslices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;oldsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_simdata</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">reset</span><span class="p">)</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_obsdata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">device</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;obs_newsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">fill_obsdata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">senders</span><span class="p">:</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update_senders</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update_receivers</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;obs_newsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">reset_obsdata</span><span class="p">)</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_simdata</span><span class="p">)</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_obsdata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">attrready</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="p">,</span> <span class="s2">&quot;sequencemanager&quot;</span><span class="p">):</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">write_netcdfslices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">funcs</span>

<div class="viewcode-block" id="HydPy.simulate">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.simulate">[docs]</a>
    <span class="nd">@printtools</span><span class="o">.</span><span class="n">print_progress</span>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a simulation run over the actual simulation period defined by the</span>
<span class="sd">        |Timegrids| object stored in module |pub|.</span>

<span class="sd">        We let function |prepare_full_example_2| prepare a runnable |HydPy| object</span>
<span class="sd">        related to the `LahnH` example project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        First, we execute a default simulation run covering the whole simulation period</span>
<span class="sd">        and inspect the discharge series simulated at the outlet of the river basin,</span>
<span class="sd">        represented by node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        After resetting the initial conditions via method |HydPy.reset_conditions|, we</span>
<span class="sd">        repeat the simulation run and get the same results:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        Simulation runs do not need to cover the whole initialisation period at once.</span>
<span class="sd">        After setting the |Timegrid.lastdate| property of the `sim` |Timegrid| of the</span>
<span class="sd">        |Timegrids| objects stored within module |pub| to the middle of the</span>
<span class="sd">        initialisation period, method |HydPy.simulate| calculates the first two</span>
<span class="sd">        discharge values only:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 0.0, 0.0</span>

<span class="sd">        After adjusting both the |Timegrid.firstdate| and |Timegrid.lastdate| of the</span>
<span class="sd">        `sim` |Timegrid| to the second half of the initialisation period,</span>
<span class="sd">        |HydPy.simulate| completes the time-series:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        In the above examples, each |Model| object (handled by an |Element| object)</span>
<span class="sd">        passes its simulated values via a |Node| object to its downstream |Model|</span>
<span class="sd">        object.  There are four ways to deviate from this default behaviour that can be</span>
<span class="sd">        selected for each node individually via the property |Node.deploymode|.  We</span>
<span class="sd">        focus on node `lahn_2` as the upstream neighbour of node `lahn_3`.  So far, its</span>
<span class="sd">        deploy mode is `newsim`, meaning that the node passes newly calculated</span>
<span class="sd">        simulation values to the downstream element `stream_lahn_2_lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode</span>
<span class="sd">        &#39;newsim&#39;</span>

<span class="sd">        Under the second option, `oldsim`, node `lahn_2` does not pass the discharge</span>
<span class="sd">        values simulated in the next simulation run, but the &quot;old&quot; discharge values</span>
<span class="sd">        already available by the |IOSequence.series| array of the |Sim| sequence.  This</span>
<span class="sd">        behaviour can, for example, be useful when calibrating subsequent subareas of a</span>
<span class="sd">        river basin sequentially, beginning with the headwaters and continuing with</span>
<span class="sd">        their downstream neighbours.  For the clarity of this example, we decrease all</span>
<span class="sd">        values of the &quot;old&quot; simulated series of node `lahn_2` by 10 mÂ³/s:</span>

<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;oldsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.sim.series -= 10.0</span>

<span class="sd">        After performing another simulation run (over the whole initialisation period,</span>
<span class="sd">        again), the modified discharge values of node `lahn_2` are unchanged.  The</span>
<span class="sd">        simulated values of node `lahn_3` are, compared to the `newsim` runs, decreased</span>
<span class="sd">        by 10 mÂ³/s (there is no time delay or dampening of the discharge values between</span>
<span class="sd">        both nodes due to the lag time of application model |musk_classic| being</span>
<span class="sd">        smaller than the simulation time step):</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        32.3697, 17.210443, 12.930066, 10.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        44.043745, 27.320814, 21.922053, 18.413644</span>

<span class="sd">        The third option is `obs`, where node `lahn_2` receives and stores the values</span>
<span class="sd">        from its upstream models but passes other, observed values, handled by sequence</span>
<span class="sd">        |Obs|, which we, for simplicity, set to zero for the complete initialisation</span>
<span class="sd">        and simulation period (more often, one would read measured data from files via</span>
<span class="sd">        methods as |HydPy.load_obsseries|):</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.obs.series = 0.0</span>

<span class="sd">        Now the simulated values of node `lahn_2` are identical with the ones of the</span>
<span class="sd">        `newsim` example, but the simulated values of node `lahn_3` are lower due to</span>
<span class="sd">        receiving the observed instead of the simulated values from upstream:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, 0.0, 0.0, 0.0</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 10.110371, 8.991987, 8.212314</span>

<span class="sd">        Unfortunately, observation time-series are often incomplete.  *HydPy* generally</span>
<span class="sd">        uses |numpy| |numpy.nan| to represent missing values.  Passing |numpy.nan|</span>
<span class="sd">        inputs to a model usually results in |numpy.nan| outputs.  Hence, after</span>
<span class="sd">        assigning |numpy.nan| to some entries of the observation series of node</span>
<span class="sd">        `lahn_2`, the simulation series of node `lahn_3` also contains |numpy.nan|</span>
<span class="sd">        values:</span>

<span class="sd">        &gt;&gt;&gt; from numpy import nan</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">        ...     hp.nodes.lahn_2.sequences.obs.series= 0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, nan, 8.991987, nan</span>

<span class="sd">        To avoid calculating |numpy.nan| values, one can select the fourth option,</span>
<span class="sd">        `obs_newsim`.  Now the priority for node `lahn_2` is to deploy its observed</span>
<span class="sd">        values.  However, for each missing observation, it deploys its newly simulated</span>
<span class="sd">        value instead:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs_newsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 37.320814, 8.991987, 28.413644</span>

<span class="sd">        The fifth option, `obs_oldsim`, serves the same purpose as option `obs_newsim`</span>
<span class="sd">        but uses already available &quot;old&quot; simulation results as substitutes:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs_oldsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.sim.series = (</span>
<span class="sd">        ...     32.3697, 17.210443, 12.930066, 10.20133)</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        32.3697, 17.210443, 12.930066, 10.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 27.320814, 8.991987, 18.413644</span>

<span class="sd">        The last example shows that resetting option |Node.deploymode| to `newsim`</span>
<span class="sd">        results in the default behaviour of the method |HydPy.simulate| again:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;newsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">simindices</span>
        <span class="n">methodorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">methodorder</span>
        <span class="n">cm</span><span class="p">:</span> <span class="n">ContextManager</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">nullcontext</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">attrready</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="p">,</span> <span class="s2">&quot;sequencemanager&quot;</span><span class="p">):</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">provide_netcdfjitaccess</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">cm</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">printtools</span><span class="o">.</span><span class="n">progressbar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">methodorder</span><span class="p">:</span>
                    <span class="n">func</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.doit">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.doit">[docs]</a>
    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated! Use method |HydPy.simulate| instead.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import warn_later</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; with warn_later(), mock.patch.object(HydPy, &quot;simulate&quot;) as mocked:</span>
<span class="sd">        ...     hp = HydPy(&quot;test&quot;)</span>
<span class="sd">        ...     hp.doit()</span>
<span class="sd">        HydPyDeprecationWarning: Method `doit` of class `HydPy` is deprecated.  Use \</span>
<span class="sd">method `simulate` instead.</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call()]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Method `doit` of class `HydPy` is deprecated.  Use method `simulate` &quot;</span>
            <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
            <span class="n">exceptiontools</span><span class="o">.</span><span class="n">HydPyDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_allseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_allseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tell all current |IOSequence| objects how to handle time-series data.</span>

<span class="sd">        Assign |True| to the `allocate_ram` argument (default) to activate the</span>
<span class="sd">        |IOSequence.series| property of all sequences so that their time-series data</span>
<span class="sd">        can become available in RAM.</span>

<span class="sd">        Assign |True| to the `jit` argument to activate the &quot;just-in-time&quot; reading from</span>
<span class="sd">        NetCDF files for all |InputSequence| and |Obs| objects and to activate the</span>
<span class="sd">        &quot;just-in-time&quot; writing of NetCDF files for all |FactorSequence|, |FluxSequence|,</span>
<span class="sd">        |StateSequence| and |Sim| objects.</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_modelseries</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_nodeseries</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_modelseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_modelseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for model</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_allseries</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_inputseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_inputseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_inputseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">read_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for model</span>
<span class="sd">        input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_inputseries</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">read_jit</span><span class="o">=</span><span class="n">read_jit</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_factorseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_factorseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_factorseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for model</span>
<span class="sd">        factor sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_factorseries</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_fluxseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_fluxseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_fluxseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for model</span>
<span class="sd">        flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_fluxseries</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span><span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_stateseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_stateseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_stateseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for model</span>
<span class="sd">        state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_stateseries</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_nodeseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_nodeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for node</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_allseries</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_simseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_simseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_simseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">read_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for</span>
<span class="sd">        simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_simseries</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">read_jit</span><span class="o">=</span><span class="n">read_jit</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.prepare_obsseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_obsseries">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_obsseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">read_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised for</span>
<span class="sd">        observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_obsseries</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">read_jit</span><span class="o">=</span><span class="n">read_jit</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HydPy.save_allseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_allseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the time-series data of all current |IOSequence| objects at once to</span>
<span class="sd">        data file(s).</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_nodeseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_modelseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_modelseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for model</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_allseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_inputseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_inputseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_inputseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for model</span>
<span class="sd">        input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_inputseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_factorseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_factorseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_factorseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for model</span>
<span class="sd">        factor sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_factorseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_fluxseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_fluxseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_fluxseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for model</span>
<span class="sd">        flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_fluxseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_stateseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_stateseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_stateseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for model</span>
<span class="sd">        state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_stateseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_nodeseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_nodeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for node</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_allseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_simseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_simseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for</span>
<span class="sd">        simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_simseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.save_obsseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_obsseries">[docs]</a>
    <span class="k">def</span> <span class="nf">save_obsseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised for</span>
<span class="sd">        observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_obsseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_allseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_allseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the time-series data of all current |IOSequence| objects at once from</span>
<span class="sd">        data file(s).</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_nodeseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_modelseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_modelseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for model</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_allseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_inputseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_inputseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_inputseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for model</span>
<span class="sd">        input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_inputseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_factorseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_factorseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_factorseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for model</span>
<span class="sd">        factor sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_factorseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_fluxseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_fluxseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_fluxseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for model</span>
<span class="sd">        flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_fluxseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_stateseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_stateseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_stateseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for model</span>
<span class="sd">        state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_stateseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_nodeseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_nodeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for node</span>
<span class="sd">        sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_allseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_simseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_simseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for</span>
<span class="sd">        simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_simseries</span><span class="p">()</span></div>


<div class="viewcode-block" id="HydPy.load_obsseries">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_obsseries">[docs]</a>
    <span class="k">def</span> <span class="nf">load_obsseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised for</span>
<span class="sd">        observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_obsseries</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="create_directedgraph">
<a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.create_directedgraph">[docs]</a>
<span class="k">def</span> <span class="nf">create_directedgraph</span><span class="p">(</span>
    <span class="n">devices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">HydPy</span><span class="p">,</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a directed graph based on the given devices.&quot;&quot;&quot;</span>
    <span class="n">digraph</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">digraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">devices</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
    <span class="n">digraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">devices</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">devices</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">inlets</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">digraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">outlets</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
            <span class="n">digraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">digraph</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.hydpytools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>