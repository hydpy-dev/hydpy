<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.core.sequencetools &#8212; HydPy 6.3dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=127cebf3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    
    <script src="../../../_static/documentation_options.js?v=6fd2034b"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.sequencetools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example_projects.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference_manual.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.core.sequencetools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module implements tools for defining and handling different kinds of</span>
<span class="sd">hydrological model sequences (time series).&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">enum</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hydpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">devicetools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">propertytools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">variabletools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core.typingtools</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">modeltools</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">timetools</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons</span><span class="w"> </span><span class="kn">import</span> <span class="n">pointerutils</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons</span><span class="w"> </span><span class="kn">import</span> <span class="n">sequenceutils</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># from hydpy.core import modeltools    actual import below</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons.autogen</span><span class="w"> </span><span class="kn">import</span> <span class="n">pointerutils</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons.autogen</span><span class="w"> </span><span class="kn">import</span> <span class="n">sequenceutils</span>


<span class="n">TypeSequences</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TypeSequences&quot;</span><span class="p">,</span> <span class="s2">&quot;Sequences&quot;</span><span class="p">,</span> <span class="s2">&quot;devicetools.Node&quot;</span><span class="p">)</span>

<span class="n">TypeModelSequences</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeModelSequences&quot;</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;ModelSequences[ModelSequence, variabletools.FastAccess]&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">TypeSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TypeSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Sequence_&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">TypeIOSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TypeIOSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;IOSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">TypeModelSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeModelSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;ModelSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">TypeModelIOSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeModelIOSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;ModelIOSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">TypeOutputSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeOutputSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;OutputSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">TypeLinkSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeLinkSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;LinkSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="n">TypeFastAccessIOSequence_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;TypeFastAccessIOSequence_co&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;FastAccessIOSequence&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="n">ModelSequencesSubypes</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="s2">&quot;InputSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FactorSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FluxSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StateSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LogSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AideSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ReceiverSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ObserverSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SenderSequences&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">ModelIOSequencesSubtypes</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="s2">&quot;InputSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FactorSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FluxSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StateSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ReceiverSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SenderSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ObserverSequences&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">LinkSequencesSubtypes</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="s2">&quot;InletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutletSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ReceiverSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ObserverSequences&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SenderSequences&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">InOutSequence</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="s2">&quot;InputSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InletSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ReceiverSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ObserverSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutputSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutletSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SenderSequence&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">InOutSequenceTypes</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;InputSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;InletSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;ReceiverSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;ObserverSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;OutputSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;OutletSequence&quot;</span><span class="p">],</span>
    <span class="nb">type</span><span class="p">[</span><span class="s2">&quot;SenderSequence&quot;</span><span class="p">],</span>
<span class="p">]</span>

<span class="n">Aggregation</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;unmodified&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]]</span>


<div class="viewcode-block" id="FastAccessIOSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessIOSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FastAccessIOSequence</span><span class="p">(</span><span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides fast access to the values of the |IOSequence| objects of a specific</span>
<span class="sd">    subgroup and supports handling time series data during simulations.</span>

<span class="sd">    The following details are of relevance for *HydPy* developers only.</span>

<span class="sd">    |sequencetools.FastAccessIOSequence| is applied in Python mode only.  When working</span>
<span class="sd">    in Cython mode, it is replaced by model-specific Cython extension classes, which</span>
<span class="sd">    are computationally more efficient.  For compatibility with these extension classes,</span>
<span class="sd">    |sequencetools.FastAccessIOSequence| objects work with dynamically set instance</span>
<span class="sd">    members.  For example, suppose there is a sequence named `seq1`, which is</span>
<span class="sd">    2-dimensional, then its associated attributes are:</span>

<span class="sd">      * seq1 (|NDArrayFloat|): The actual sequence value(s).</span>
<span class="sd">      * _seq1_ndim (|int|): The number of dimensions.</span>
<span class="sd">      * _seq1_length_0 (|int|): Length in the first dimension.</span>
<span class="sd">      * _seq1_length_1 (|int|): Length in the second dimension.</span>
<span class="sd">      * _seq1_ramflag (|bool|): Handle time series data in RAM?</span>
<span class="sd">      * _seq1_array (|NDArrayFloat|): Time-series data (when handled in RAM).</span>
<span class="sd">      * _seq1_diskflag_reading (|bool|): Read data from a NetCDF file during simulation?</span>
<span class="sd">      * _seq1_diskflag_writing (|bool|): Write data to a NetCDF file during simulation?</span>
<span class="sd">      * _seq1_ncarray (|NDArrayFloat|): An array connected with the data slice of the</span>
<span class="sd">        NetCDF file relevant for `seq1`.</span>

<span class="sd">    Note that the respective |IOSequences| and |IOSequence| objects initialise, change,</span>
<span class="sd">    and apply these dynamical attributes.  To handle them directly is error-prone and</span>
<span class="sd">    thus not recommended.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FastAccessIOSequence.load_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessIOSequence.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the data of certain sequences from the defined sources.</span>

<span class="sd">        The following flags specify the data source (listed in the order of their</span>
<span class="sd">        priority):</span>

<span class="sd">         * inputflag (|bool|): Take the data from an &quot;input node&quot;.</span>
<span class="sd">         * diskflag_reading (|bool|): Read the data &quot;on the fly&quot; from a NetCDF file</span>
<span class="sd">           during a simulation run.</span>
<span class="sd">         * ramflag (|bool|): Take the data from the time series handled by the</span>
<span class="sd">           |IOSequence.series| attribute of the respective |IOSequence| object.</span>

<span class="sd">        If, for example, `diskflag_reading` and `ramflag` are both activated,</span>
<span class="sd">        |FastAccessIOSequence.load_data| prefers the data available within the NetCDF</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">)</span>
            <span class="n">inputflag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;inputflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">diskflag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;diskflag_reading&quot;</span><span class="p">)</span>
            <span class="n">ramflag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ramflag&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inputflag</span> <span class="ow">or</span> <span class="n">diskflag</span> <span class="ow">or</span> <span class="n">ramflag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inputflag</span><span class="p">:</span>
                    <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;inputpointer&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">diskflag</span><span class="p">:</span>
                    <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ncarray&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">actual</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">actual</span></div>


<div class="viewcode-block" id="FastAccessIOSequence.save_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessIOSequence.save_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the data of certain sequences to the defined sources.</span>

<span class="sd">        The following flags the data targets:</span>

<span class="sd">         * diskflag_writing (|bool|): Write the data &quot;on the fly&quot; to a NetCDF file</span>
<span class="sd">           during a simulation run.</span>
<span class="sd">         * ramflag (|bool|): Give the data to the time series handled by the</span>
<span class="sd">           |IOSequence.series| attribute of the respective |IOSequence| object.</span>

<span class="sd">        It is possible to write data to a NetCDF file and pass it to |IOSequence.series|</span>
<span class="sd">        simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">actual</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;diskflag_writing&quot;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ncarray&quot;</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">actual</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ncarray&quot;</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">actual</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ramflag&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">actual</span></div>
</div>



<div class="viewcode-block" id="FastAccessInputSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessInputSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FastAccessInputSequence</span><span class="p">(</span><span class="n">FastAccessIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;|FastAccessIOSequence| subclass specialised for input sequences.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FastAccessInputSequence.set_pointerinput">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessInputSequence.set_pointerinput">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointerinput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PDouble</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the given |PDouble| object as the pointer for the 0-dimensional</span>
<span class="sd">        |InputSequence| object with the given name.&quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_inputpointer&quot;</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FastAccessOutputSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessOutputSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FastAccessOutputSequence</span><span class="p">(</span><span class="n">FastAccessIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;|FastAccessIOSequence| subclass specialised for output sequences.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FastAccessOutputSequence.set_pointeroutput">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessOutputSequence.set_pointeroutput">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointeroutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PDouble</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the given |PDouble| object as the pointer for the 0-dimensional</span>
<span class="sd">        |OutputSequence| object with the given name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;outputpointer&quot;</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">)</span></div>


<div class="viewcode-block" id="FastAccessOutputSequence.update_outputs">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessOutputSequence.update_outputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pass the data of all sequences with an activated output flag.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;outputflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;outputpointer&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FastAccessLinkSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FastAccessLinkSequence</span><span class="p">(</span><span class="n">FastAccessIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;|FastAccessIOSequence| subclass specialised for link sequences.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FastAccessLinkSequence.alloc_pointer">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence.alloc_pointer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">alloc_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate enough memory for the given vector length of the |LinkSequence|</span>
<span class="sd">        object&#39;s pointer with the given name.</span>

<span class="sd">        Cython extension classes must define |FastAccessLinkSequence.alloc_pointer| if</span>
<span class="sd">        the model handles at least one 1-dimensional |LinkSequence| subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_pointer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span></div>


<div class="viewcode-block" id="FastAccessLinkSequence.dealloc_pointer">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence.dealloc_pointer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dealloc_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Free the previously allocated memory of the |LinkSequence| object&#39;s pointer</span>
<span class="sd">        with the given name.</span>

<span class="sd">        Cython extension classes must define |FastAccessLinkSequence.dealloc_pointer|</span>
<span class="sd">        if the model handles at least one 1-dimensional |LinkSequence| subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="FastAccessLinkSequence.set_pointer0d">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence.set_pointer0d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointer0d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define a pointer referencing the given |Double| object for the 0-dimensional</span>
<span class="sd">        |LinkSequence| object with the given name.</span>

<span class="sd">        Cython extension classes must define |FastAccessLinkSequence.set_pointer0d| if</span>
<span class="sd">        the model handles at least one 0-dimensional |LinkSequence| subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_pointer&quot;</span><span class="p">,</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PDouble</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="FastAccessLinkSequence.set_pointer1d">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence.set_pointer1d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointer1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define a pointer referencing the given |Double| object for the 1-dimensional</span>
<span class="sd">        |LinkSequence| object with the given name.</span>

<span class="sd">        The given index defines the vector position of the defined pointer.</span>

<span class="sd">        Cython extension classes must define |FastAccessLinkSequence.set_pointer1d| if</span>
<span class="sd">        the model handles at least one 1-dimensional |LinkSequence| subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ppdouble</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PPDouble</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_pointer&quot;</span><span class="p">)</span>
        <span class="n">ppdouble</span><span class="o">.</span><span class="n">set_pointer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="FastAccessLinkSequence.get_pointervalue">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessLinkSequence.get_pointervalue">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pointervalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">NDArrayFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the actual value(s) referenced by the pointer(s) of the</span>
<span class="sd">        |LinkSequence| object with the given name.&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_pointer&quot;</span><span class="p">)[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FastAccessNodeSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FastAccessNodeSequence</span><span class="p">(</span><span class="n">FastAccessIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;|sequencetools.FastAccessIOSequence| subclass specialised for |Node| objects.</span>

<span class="sd">    In contrast to other |FastAccessIOSequence| subclasses,</span>
<span class="sd">    |sequencetools.FastAccessNodeSequence| only needs to handle a fixed number of</span>
<span class="sd">    sequences, |Sim| and |Obs|. It thus can define the related attributes explicitly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sim</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span>
    <span class="n">_sim_ramflag</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_obs_ramflag</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_sim_array</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="n">_obs_array</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="n">_sim_diskflag_reading</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_sim_diskflag_writing</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_obs_diskflag_reading</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_obs_diskflag_writing</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_sim_ncarray</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="n">_obs_ncarray</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="n">_reset_obsdata</span><span class="p">:</span> <span class="nb">bool</span>

<div class="viewcode-block" id="FastAccessNodeSequence.load_simdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.load_simdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_simdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the next sim sequence value from a NetCDF file or, with second priority,</span>
<span class="sd">        from the |IOSequence.series| attribute of the current |Sim| object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_diskflag_reading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_ncarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.save_simdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.save_simdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_simdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the next sim sequence value to a NetCDF file and/or to the</span>
<span class="sd">        |IOSequence.series| attribute of the |Sim| object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_diskflag_writing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sim_ncarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sim_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.load_obsdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.load_obsdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_obsdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the next sim sequence value from a NetCDF file or, with second priority,</span>
<span class="sd">        from the |IOSequence.series| attribute of the |Obs| object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_diskflag_reading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_ncarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.save_obsdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.save_obsdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_obsdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the next sim sequence value to a NetCDF file and/or to the</span>
<span class="sd">        |IOSequence.series| attribute of the |Obs| object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_diskflag_writing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obs_ncarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obs_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.load_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call both method |sequencetools.FastAccessNodeSequence.load_simdata| and</span>
<span class="sd">        method |sequencetools.FastAccessNodeSequence.load_obsdata|.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_simdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_obsdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.save_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.save_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call both method |sequencetools.FastAccessNodeSequence.save_simdata| and</span>
<span class="sd">        method |sequencetools.FastAccessNodeSequence.save_obsdata|.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_simdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_obsdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.reset">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="c1"># required for consistincy with the other reset methods.</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the actual value of the simulation sequence to zero.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.fill_obsdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.fill_obsdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill_obsdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the current sim value for the current `obs` value if obs is</span>
<span class="sd">        |numpy.nan|.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="c1"># required for consistincy with the other reset methods.</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_obsdata</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FastAccessNodeSequence.reset_obsdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FastAccessNodeSequence.reset_obsdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_obsdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the current `obs` value to |numpy.nan| if modified beforehand by</span>
<span class="sd">        method |FastAccessNodeSequence.fill_obsdata|.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="c1"># required for consistincy with the other reset methods.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_obsdata</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_obsdata</span> <span class="o">=</span> <span class="kc">False</span></div>
</div>



<div class="viewcode-block" id="InfoArray">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InfoArray">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InfoArray</span><span class="p">(</span><span class="n">NDArrayFloat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;|numpy| |numpy.ndarray| subclass with an additional attribute describing the</span>
<span class="sd">    (potential) aggregation of the handled data.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.sequencetools import InfoArray</span>
<span class="sd">    &gt;&gt;&gt; array = InfoArray([1.0, 2.0], aggregation=&quot;mean&quot;)</span>
<span class="sd">    &gt;&gt;&gt; array</span>
<span class="sd">    InfoArray([1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; array.aggregation</span>
<span class="sd">    &#39;mean&#39;</span>
<span class="sd">    &gt;&gt;&gt; subarray = array[:1]</span>
<span class="sd">    &gt;&gt;&gt; subarray</span>
<span class="sd">    InfoArray([1.])</span>
<span class="sd">    &gt;&gt;&gt; subarray.aggregation</span>
<span class="sd">    &#39;mean&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">aggregation</span><span class="p">:</span> <span class="n">Aggregation</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="n">NDArrayFloat</span><span class="p">,</span> <span class="n">aggregation</span><span class="p">:</span> <span class="n">Aggregation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">aggregation</span> <span class="o">=</span> <span class="n">aggregation</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">InfoArray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregation</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">aggregation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregation</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="StandardInputNames">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StandardInputNames">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StandardInputNames</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">StrEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standard names for the |InputSequence| subclasses of the various models.</span>

<span class="sd">    One can use these names instead of the model-specific sequence names for reading</span>
<span class="sd">    input time series from or to files.  For further information, see the introductory</span>
<span class="sd">    documentation on class |HydPy|.</span>

<span class="sd">    The suffix &quot;_HRU&quot; refers to 1-dimensional sequences for which the different entries</span>
<span class="sd">    correspond to different spatial units (typically hydrological response units).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">AIR_TEMPERATURE</span> <span class="o">=</span> <span class="s2">&quot;air_temperature&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Air temperature 2 m above the ground [C].&quot;&quot;&quot;</span>
    <span class="n">ALBEDO_HRU</span> <span class="o">=</span> <span class="s2">&quot;albedo_hru&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Surface albedo [-].&quot;&quot;&quot;</span>
    <span class="n">ARTIFICIAL_GROUNDWATER_RECHARGE</span> <span class="o">=</span> <span class="s2">&quot;artificial_groundwater_recharge&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Artificial/additional groundwater recharge [mm/T].&quot;&quot;&quot;</span>
    <span class="n">ARTIFICIAL_SURFACE_WATER_SUPPLY</span> <span class="o">=</span> <span class="s2">&quot;artificial_surface_water_supply&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Artificial/additional surface water supply [mm/T].&quot;&quot;&quot;</span>
    <span class="n">ATMOSPHERIC_PRESSURE</span> <span class="o">=</span> <span class="s2">&quot;atmospheric_pressure&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Atmospheric pressure [hPa].&quot;&quot;&quot;</span>
    <span class="n">CAPILLARY_RISE</span> <span class="o">=</span> <span class="s2">&quot;capillary_rise&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Capillary rise [mm/T].&quot;&quot;&quot;</span>
    <span class="n">CLEAR_SKY_SOLAR_RADIATION</span> <span class="o">=</span> <span class="s2">&quot;clear_sky_solar_radiation&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clear sky solar radiation [W/m].&quot;&quot;&quot;</span>
    <span class="n">EVAPOTRANSPIRATION</span> <span class="o">=</span> <span class="s2">&quot;evapotranspiration&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Actual evapotranspiration [mm/T].&quot;&quot;&quot;</span>
    <span class="n">GLOBAL_RADIATION</span> <span class="o">=</span> <span class="s2">&quot;global_radiation&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Global radiation [W/m].&quot;&quot;&quot;</span>
    <span class="n">INTERCEPTED_WATER_HRU</span> <span class="o">=</span> <span class="s2">&quot;intercepted_water_hru&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Amount of intercepted water [mm].&quot;&quot;&quot;</span>
    <span class="n">MAXIMUM_AIR_TEMPERATURE</span> <span class="o">=</span> <span class="s2">&quot;maximum_air_temperature&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Highest air temperature 2 m above the ground within time interval [C].&quot;&quot;&quot;</span>
    <span class="n">MINIMUM_AIR_TEMPERATURE</span> <span class="o">=</span> <span class="s2">&quot;minimum_air_temperature&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lowest air temperature 2 m above the ground within time interval [C].&quot;&quot;&quot;</span>
    <span class="n">NORMAL_AIR_TEMPERATURE</span> <span class="o">=</span> <span class="s2">&quot;normal_air_temperature&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normal air temperature 2 m above the ground [C].&quot;&quot;&quot;</span>
    <span class="n">NORMAL_EVAPOTRANSPIRATION</span> <span class="o">=</span> <span class="s2">&quot;normal_evapotranspiration&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normal evapotranspiration [mm/T].&quot;&quot;&quot;</span>
    <span class="n">POSSIBLE_SUNSHINE_DURATION</span> <span class="o">=</span> <span class="s2">&quot;possible_sunshine_duration&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Possible sunshine duration [h].&quot;&quot;&quot;</span>
    <span class="n">POTENTIAL_EVAPOTRANSPIRATION</span> <span class="o">=</span> <span class="s2">&quot;potential_evapotranspiration&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Potential evapotranspiration [mm/T].&quot;&quot;&quot;</span>
    <span class="n">PRECIPITATION</span> <span class="o">=</span> <span class="s2">&quot;precipitation&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Precipitation [mm/T].&quot;&quot;&quot;</span>
    <span class="n">RELATIVE_HUMIDITY</span> <span class="o">=</span> <span class="s2">&quot;relative_humidity&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Relative humidity [%].&quot;&quot;&quot;</span>
    <span class="n">SNOW_COVER_DEGREE_CANOPY_HRU</span> <span class="o">=</span> <span class="s2">&quot;snow_cover_degree_canopy_hru&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Snow cover degree in the canopies of tree-like vegetation [-].&quot;&quot;&quot;</span>
    <span class="n">SNOW_COVER_DEGREE_HRU</span> <span class="o">=</span> <span class="s2">&quot;snow_cover_degree_hru&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Snow cover degree [-].&quot;&quot;&quot;</span>
    <span class="n">SOIL_WATER_HRU</span> <span class="o">=</span> <span class="s2">&quot;soil_water_hru&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Amount of soil water [mm].&quot;&quot;&quot;</span>
    <span class="n">SUNSHINE_DURATION</span> <span class="o">=</span> <span class="s2">&quot;sunshine_duration&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sunshine duration [h].&quot;&quot;&quot;</span>
    <span class="n">WIND_SPEED</span> <span class="o">=</span> <span class="s2">&quot;wind_speed&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wind speed [m/s].&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Sequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sequences</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling all sequences of a specific model.</span>

<span class="sd">    |Sequences| objects handle nine sequence subgroups as attributes such as the</span>
<span class="sd">    `inlets` and  the `receivers` subsequences:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">    &gt;&gt;&gt; sequences = hp.elements.land_dill_assl.model.sequences</span>
<span class="sd">    &gt;&gt;&gt; bool(sequences.inlets)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; bool(sequences.fluxes)</span>
<span class="sd">    True</span>

<span class="sd">    Iteration makes only the non-empty subgroups available that handle |Sequence_|</span>
<span class="sd">    objects:</span>

<span class="sd">    &gt;&gt;&gt; for subseqs in sequences:</span>
<span class="sd">    ...     print(subseqs.name)</span>
<span class="sd">    inputs</span>
<span class="sd">    factors</span>
<span class="sd">    fluxes</span>
<span class="sd">    states</span>
<span class="sd">    aides</span>
<span class="sd">    outlets</span>
<span class="sd">    &gt;&gt;&gt; len(sequences)</span>
<span class="sd">    6</span>

<span class="sd">    Keyword access provides a type-safe way to query a subgroup via a string:</span>

<span class="sd">    &gt;&gt;&gt; type(sequences[&quot;inputs&quot;]).__name__</span>
<span class="sd">    &#39;InputSequences&#39;</span>
<span class="sd">    &gt;&gt;&gt; type(sequences[&quot;wrong&quot;])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: There is no sequence subgroup named `wrong`.</span>
<span class="sd">    &gt;&gt;&gt; sequences[&quot;model&quot;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: Attribute `model` is of type `Model`, which is not a subtype of class \</span>
<span class="sd">`SubSequences`.</span>

<span class="sd">    Class |Sequences| provides some methods related to reading and writing time series</span>
<span class="sd">    data, which (directly or indirectly) call the corresponding methods of the handled</span>
<span class="sd">    |IOSequence| objects.  In most cases, users should prefer to use the related</span>
<span class="sd">    methods of class |HydPy|, but using the ones of class |Sequences| can be more</span>
<span class="sd">    convenient when analysing a specific model in-depth.</span>

<span class="sd">    To introduce these methods, we first change two IO-related settings:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; pub.options.checkseries = False</span>
<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.overwrite = True</span>

<span class="sd">    Method |Sequences.prepare_series| can both enable and disable the handling of</span>
<span class="sd">    time series in rapid access memory (RAM), and both enable and disable the reading</span>
<span class="sd">    of input data from NetCDF files and the writing of NetCDF files &quot;on the fly&quot;</span>
<span class="sd">    during simulation runs:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import attrready</span>
<span class="sd">    &gt;&gt;&gt; sequences.prepare_series(allocate_ram=False, jit=False)</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.ramflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; attrready(sequences.inputs.t, &quot;series&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag_reading</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.states.sm.diskflag_writing</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; sequences.prepare_series()</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.ramflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; attrready(sequences.inputs.t, &quot;series&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag_reading</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.states.sm.diskflag_writing</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; sequences.prepare_series(allocate_ram=False, jit=True)</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.ramflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; attrready(sequences.inputs.t, &quot;series&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; sequences.inputs.t.diskflag_reading</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; sequences.states.sm.diskflag_writing</span>
<span class="sd">    True</span>

<span class="sd">    After applying |Sequences.prepare_series|, you can use the methods</span>
<span class="sd">    |Sequences.load_series| and |Sequences.save_series| to read or write the time</span>
<span class="sd">    series of the relevant |InputSequence|, |FactorSequence|, |FluxSequence|,</span>
<span class="sd">    |StateSequence|, and |LinkSequence| objects, as the following technical test</span>
<span class="sd">    suggests.  The documentation on class |IOSequence| explains the underlying</span>
<span class="sd">    functionalities of in more detail.</span>

<span class="sd">    &gt;&gt;&gt; from unittest.mock import patch</span>
<span class="sd">    &gt;&gt;&gt; template = &quot;hydpy.core.sequencetools.%s.load_series&quot;</span>
<span class="sd">    &gt;&gt;&gt; with (</span>
<span class="sd">    ...     patch(template % &quot;InputSequences&quot;) as inputs,</span>
<span class="sd">    ...     patch(template % &quot;FactorSequences&quot;) as factors,</span>
<span class="sd">    ...     patch(template % &quot;FluxSequences&quot;) as fluxes,</span>
<span class="sd">    ...     patch(template % &quot;StateSequences&quot;) as states,</span>
<span class="sd">    ...     patch(template % &quot;OutletSequences&quot;) as outlets,</span>
<span class="sd">    ... ):</span>
<span class="sd">    ...     sequences.load_series()</span>
<span class="sd">    ...     inputs.assert_called_with()</span>
<span class="sd">    ...     factors.assert_called_with()</span>
<span class="sd">    ...     fluxes.assert_called_with()</span>
<span class="sd">    ...     states.assert_called_with()</span>
<span class="sd">    ...     outlets.assert_called_with()</span>

<span class="sd">    &gt;&gt;&gt; template = &quot;hydpy.core.sequencetools.%s.save_series&quot;</span>
<span class="sd">    &gt;&gt;&gt; with (</span>
<span class="sd">    ...     patch(template % &quot;InputSequences&quot;) as inputs,</span>
<span class="sd">    ...     patch(template % &quot;FactorSequences&quot;) as factors,</span>
<span class="sd">    ...     patch(template % &quot;FluxSequences&quot;) as fluxes,</span>
<span class="sd">    ...     patch(template % &quot;StateSequences&quot;) as states,</span>
<span class="sd">    ...     patch(template % &quot;OutletSequences&quot;) as outlets,</span>
<span class="sd">    ... ):</span>
<span class="sd">    ...     sequences.save_series()</span>
<span class="sd">    ...     inputs.assert_called_with()</span>
<span class="sd">    ...     factors.assert_called_with()</span>
<span class="sd">    ...     fluxes.assert_called_with()</span>
<span class="sd">    ...     states.assert_called_with()</span>
<span class="sd">    ...     outlets.assert_called_with()</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; pub.options.checkseries = True</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager.overwrite = False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">model</span><span class="p">:</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">Model</span>
    <span class="n">inlets</span><span class="p">:</span> <span class="n">InletSequences</span>
    <span class="n">observers</span><span class="p">:</span> <span class="n">ObserverSequences</span>
    <span class="n">receivers</span><span class="p">:</span> <span class="n">ReceiverSequences</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">InputSequences</span>
    <span class="n">factors</span><span class="p">:</span> <span class="n">FactorSequences</span>
    <span class="n">fluxes</span><span class="p">:</span> <span class="n">FluxSequences</span>
    <span class="n">states</span><span class="p">:</span> <span class="n">StateSequences</span>
    <span class="n">logs</span><span class="p">:</span> <span class="n">LogSequences</span>
    <span class="n">aides</span><span class="p">:</span> <span class="n">AideSequences</span>
    <span class="n">outlets</span><span class="p">:</span> <span class="n">OutletSequences</span>
    <span class="n">senders</span><span class="p">:</span> <span class="n">SenderSequences</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">cls_inlets</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">InletSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_observers</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">ObserverSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_receivers</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">ReceiverSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_inputs</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">InputSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_factors</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">FactorSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_fluxes</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">FluxSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_states</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">StateSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_logs</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">LogSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_aides</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">AideSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_outlets</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">OutletSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_senders</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">SenderSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cymodel</span><span class="p">:</span> <span class="n">CyModelProtocol</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cythonmodule</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">InletSequences</span><span class="p">,</span> <span class="n">cls_inlets</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">ObserverSequences</span><span class="p">,</span> <span class="n">cls_observers</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">ReceiverSequences</span><span class="p">,</span> <span class="n">cls_receivers</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">InputSequences</span><span class="p">,</span> <span class="n">cls_inputs</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">FactorSequences</span><span class="p">,</span> <span class="n">cls_factors</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">FluxSequences</span><span class="p">,</span> <span class="n">cls_fluxes</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">StateSequences</span><span class="p">,</span> <span class="n">cls_states</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">LogSequences</span><span class="p">,</span> <span class="n">cls_logs</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">AideSequences</span><span class="p">,</span> <span class="n">cls_aides</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">OutletSequences</span><span class="p">,</span> <span class="n">cls_outlets</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">senders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_subseqs</span><span class="p">(</span>
            <span class="n">SenderSequences</span><span class="p">,</span> <span class="n">cls_senders</span><span class="p">,</span> <span class="n">cymodel</span><span class="p">,</span> <span class="n">cythonmodule</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__prepare_subseqs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">default</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">TypeModelSequences</span><span class="p">],</span>
        <span class="n">class_</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">TypeModelSequences</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cymodel</span><span class="p">,</span>
        <span class="n">cythonmodule</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeModelSequences</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">class_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">class_</span><span class="p">,</span> <span class="s2">&quot;CLASSES&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">return</span> <span class="n">class_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cythonmodule</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">cymodel</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">iosubsequences</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ModelIOSequencesSubtypes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yield all relevant |IOSequences| objects handled by the current |Sequences|</span>
<span class="sd">        object.</span>

<span class="sd">        For |hland_96|, the available IO-subgroups are `inputs`, `factors`, `fluxes`,</span>
<span class="sd">        `states`, and `outlets`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;hland_96&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for subseqs in model.sequences.iosubsequences:</span>
<span class="sd">        ...     print(subseqs.name)</span>
<span class="sd">        inputs</span>
<span class="sd">        factors</span>
<span class="sd">        fluxes</span>
<span class="sd">        states</span>
<span class="sd">        outlets</span>

<span class="sd">        Not all models implement sequences for all possible subgroups.  The</span>
<span class="sd">        |Sequences.iosubsequences| property only yields those subgroups which are</span>
<span class="sd">        non-empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">linksubsequences</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">linksubsequences</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">LinkSequencesSubtypes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yield all relevant |LinkSequences| objects handled by the current</span>
<span class="sd">        |Sequences| object.</span>

<span class="sd">        For |musk_classic|, the available link sequence subgroups are `inlets` and</span>
<span class="sd">        `outlets`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;musk_classic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for subseqs in model.sequences.linksubsequences:</span>
<span class="sd">        ...     print(subseqs.name)</span>
<span class="sd">        inlets</span>
<span class="sd">        outlets</span>

<span class="sd">        Not all models implement sequences for all possible subgroups.  Therefore, the</span>
<span class="sd">        |Sequences.linksubsequences| property only yields those subgroups which are</span>
<span class="sd">        non-empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlets</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observers</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">observers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">senders</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">senders</span>

<div class="viewcode-block" id="Sequences.prepare_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.prepare_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequences.prepare_series| of attribute |Sequences.inputs|</span>
<span class="sd">        with `read_jit=jit` and of attributes |Sequences.factors|, |Sequences.fluxes|,</span>
<span class="sd">        and |Sequences.states| with `write_jit=jit`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">read_jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span><span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">jit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequences.load_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.load_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequences.load_series| of all handled |IOSequences|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subseqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iosubsequences</span><span class="p">:</span>
            <span class="n">subseqs</span><span class="o">.</span><span class="n">load_series</span><span class="p">()</span></div>


<div class="viewcode-block" id="Sequences.save_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.save_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequence.save_series| of all handled |IOSequences|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subseqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iosubsequences</span><span class="p">:</span>
            <span class="n">subseqs</span><span class="o">.</span><span class="n">save_series</span><span class="p">()</span></div>


<div class="viewcode-block" id="Sequences.load_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |ModelIOSequences.load_data| of the handled</span>
<span class="sd">        |sequencetools.InputSequences|, |sequencetools.InletSequences|,</span>
<span class="sd">        |sequencetools.ObserverSequences|, and |sequencetools.ReceiverSequences|.</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observers</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequences.save_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.save_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |ModelIOSequences.save_data| of all handled</span>
<span class="sd">        |sequencetools.ModelIOSequences| objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subseqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iosubsequences</span><span class="p">:</span>
            <span class="n">subseqs</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequences.update_outputs">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.update_outputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call the method |OutputSequences.update_outputs| of the subattributes</span>
<span class="sd">        |Sequences.factors|, |Sequences.fluxes|, and |Sequences.states|.</span>

<span class="sd">        When working in Cython mode, the standard model import overrides this generic</span>
<span class="sd">        Python version with a model-specific Cython version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">update_outputs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">update_outputs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">update_outputs</span><span class="p">()</span></div>


<div class="viewcode-block" id="Sequences.reset">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |ConditionSequence.reset| of all handled |ConditionSequence|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionsequences</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ConditionSequence</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator object yielding all conditions (|StateSequence| and |LogSequence|</span>
<span class="sd">        objects).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConditionsSubmodel</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A nested dictionary that contains the values of all condition sequences of</span>
<span class="sd">        a single model instance.</span>

<span class="sd">        See the documentation on property |HydPy.conditions| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">NDArrayFloat</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditionsequences</span><span class="p">:</span>
            <span class="n">subconditions</span> <span class="o">=</span> <span class="n">conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">subconditions</span><span class="p">[</span><span class="n">seq</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">conditions</span><span class="p">[</span><span class="n">seq</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">subconditions</span>
        <span class="k">return</span> <span class="n">conditions</span>

    <span class="nd">@conditions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">:</span> <span class="n">ConditionsSubmodel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">trimvariables</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subname</span><span class="p">,</span> <span class="n">subconditions</span> <span class="ow">in</span> <span class="n">conditions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">subseqs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subname</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">seqname</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">subconditions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">subseqs</span><span class="p">,</span> <span class="n">seqname</span><span class="p">)(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conditionsequences</span><span class="p">)):</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>

<div class="viewcode-block" id="Sequences.trim_conditions">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequences.trim_conditions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |trim| of each handled |ConditionSequence|.</span>

<span class="sd">        |Sequences.trim_conditions| is just a convenience function for calling method</span>
<span class="sd">        |trim| of all |StateSequence| and |LogSequence| objects returned by property</span>
<span class="sd">        |Sequences.conditionsequences|.  We demonstrate its functionality by preparing</span>
<span class="sd">        an instance of application model |lland_dd|, using its available default</span>
<span class="sd">        values, and defining out-of-bound values of the soil moisture state sequence</span>
<span class="sd">        |lland_states.BoWa|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model, pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-01-10&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usedefaultvalues(True):</span>
<span class="sd">        ...     model = prepare_model(&quot;lland_dd&quot;)</span>
<span class="sd">        ...     model.parameters.control.nhru(2)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.states.bowa = -100.0</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.trim_conditions()</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.states.bowa</span>
<span class="sd">        bowa(0.0, 0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditionsequences</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubSequences</span><span class="p">[</span><span class="n">TypeSequences</span><span class="p">,</span> <span class="n">Sequence_</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">subseqs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There is no sequence subgroup named `</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subseqs</span><span class="p">,</span> <span class="n">SubSequences</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subseqs</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Attribute `</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">` is of type `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">subseqs</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`, which is not &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;a subtype of class `SubSequences`.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ModelSequencesSubypes</span><span class="p">]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observers</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">observers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">receivers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aides</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">aides</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlets</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">senders</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">senders</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">seqs</span> <span class="k">for</span> <span class="n">seqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="SubSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.SubSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SubSequences</span><span class="p">(</span>
    <span class="n">variabletools</span><span class="o">.</span><span class="n">SubVariables</span><span class="p">[</span>
        <span class="n">TypeSequences</span><span class="p">,</span> <span class="n">TypeSequence_co</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">TypeFastAccess_co</span>
    <span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling subgroups of sequences.</span>

<span class="sd">    Each |SubSequences| object has a `fastaccess` attribute, which is an instance of (a</span>
<span class="sd">    subclass of) class |FastAccess| when working in pure Python mode:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import classname, Node, prepare_model, pub</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">    ...     model = prepare_model(&quot;lland_dd&quot;)</span>
<span class="sd">    &gt;&gt;&gt; classname(model.sequences.logs.fastaccess)</span>
<span class="sd">    &#39;FastAccess&#39;</span>
<span class="sd">    &gt;&gt;&gt; classname(model.sequences.inputs.fastaccess)</span>
<span class="sd">    &#39;FastAccessInputSequence&#39;</span>
<span class="sd">    &gt;&gt;&gt; from hydpy.core.sequencetools import FastAccessNodeSequence</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">    ...     node = Node(&quot;test1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(node.sequences.fastaccess, FastAccessNodeSequence)</span>
<span class="sd">    True</span>

<span class="sd">    When working in Cython mode (the default and much faster than the pure Python mode),</span>
<span class="sd">    `fastaccess` is an object of the Cython extension class `FastAccessNodeSequence` of</span>
<span class="sd">    module `sequenceutils` or a Cython extension class specialised for the respective</span>
<span class="sd">    model and sequence group:</span>

<span class="sd">    &gt;&gt;&gt; with pub.options.usecython(True):</span>
<span class="sd">    ...     model = prepare_model(&quot;lland_dd&quot;)</span>
<span class="sd">    &gt;&gt;&gt; classname(model.sequences.inputs.fastaccess)</span>
<span class="sd">    &#39;InputSequences&#39;</span>
<span class="sd">    &gt;&gt;&gt; from hydpy.cythons.sequenceutils import FastAccessNodeSequence</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.usecython(True):</span>
<span class="sd">    ...     node = Node(&quot;test2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(Node(&quot;test2&quot;).sequences.fastaccess, FastAccessNodeSequence)</span>
<span class="sd">    True</span>

<span class="sd">    See the documentation of similar class |SubParameters| for further information.</span>
<span class="sd">    However, note the difference that model developers should not subclass</span>
<span class="sd">    |SubSequences| directly but specialised subclasses like</span>
<span class="sd">    |sequencetools.FluxSequences| or |sequencetools.StateSequences| instead.</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The class name in lowercase letters omitting the last eight characters</span>
<span class="sd">        (&quot;equences&quot;).</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequences</span>
<span class="sd">        &gt;&gt;&gt; class StateSequences(StateSequences):</span>
<span class="sd">        ...     CLASSES = ()</span>
<span class="sd">        &gt;&gt;&gt; StateSequences(None).name</span>
<span class="sd">        &#39;states&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>



<div class="viewcode-block" id="ModelSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelSequences</span><span class="p">(</span>
    <span class="n">SubSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">TypeModelSequence_co</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">TypeFastAccess_co</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling model-related subgroups of sequences.&quot;&quot;&quot;</span>

    <span class="n">seqs</span><span class="p">:</span> <span class="n">Sequences</span>
    <span class="n">_cymodel</span><span class="p">:</span> <span class="n">CyModelProtocol</span> <span class="o">|</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">master</span><span class="p">:</span> <span class="n">Sequences</span><span class="p">,</span>
        <span class="n">cls_fastaccess</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">variabletools</span><span class="o">.</span><span class="n">TypeFastAccess_co</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cymodel</span><span class="p">:</span> <span class="n">CyModelProtocol</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seqs</span> <span class="o">=</span> <span class="n">master</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span> <span class="o">=</span> <span class="n">cymodel</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="o">=</span><span class="n">master</span><span class="p">,</span> <span class="n">cls_fastaccess</span><span class="o">=</span><span class="n">cls_fastaccess</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_fastaccess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_init_fastaccess</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_fastaccess</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">)</span></div>



<div class="viewcode-block" id="SeriesMode">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.SeriesMode">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SeriesMode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The type of property |IOSequence.seriesmode| of class |IOSequence|.&quot;&quot;&quot;</span>

    <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corresponds to property |IOSequence.ramflag| of class |IOSequence|.&quot;&quot;&quot;</span>
    <span class="n">diskflag_reading</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corresponds to property |IOSequence.diskflag_reading| of class |IOSequence|.&quot;&quot;&quot;</span>
    <span class="n">diskflag_writing</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corresponds to property |IOSequence.diskflag_writing| of class |IOSequence|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="IOSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IOSequences</span><span class="p">(</span>
    <span class="n">SubSequences</span><span class="p">[</span><span class="n">TypeSequences</span><span class="p">,</span> <span class="n">TypeIOSequence_co</span><span class="p">,</span> <span class="n">TypeFastAccessIOSequence_co</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of |SubSequences|, specialised for handling |IOSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">seqs</span><span class="p">:</span> <span class="n">Sequences</span>

<div class="viewcode-block" id="IOSequences.prepare_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequences.prepare_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">read_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequence.prepare_series| of all handled |IOSequence|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span>
                <span class="n">allocate_ram</span><span class="o">=</span><span class="n">allocate_ram</span><span class="p">,</span> <span class="n">read_jit</span><span class="o">=</span><span class="n">read_jit</span><span class="p">,</span> <span class="n">write_jit</span><span class="o">=</span><span class="n">write_jit</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="IOSequences.load_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequences.load_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequence.load_series| of all handled |IOSequence| objects</span>
<span class="sd">        with an activated |IOSequence.ramflag|.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">load_series</span><span class="p">()</span></div>


<div class="viewcode-block" id="IOSequences.save_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequences.save_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |IOSequence.save_series| of all handled |IOSequence| objects</span>
<span class="sd">        with an activated |IOSequence.ramflag|.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">save_series</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="ModelIOSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelIOSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelIOSequences</span><span class="p">(</span>
    <span class="n">IOSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">TypeModelIOSequence_co</span><span class="p">,</span> <span class="n">TypeFastAccessIOSequence_co</span><span class="p">],</span>
    <span class="n">ModelSequences</span><span class="p">[</span><span class="n">TypeModelIOSequence_co</span><span class="p">,</span> <span class="n">TypeFastAccessIOSequence_co</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling model-related subgroups of |IOSequence| objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelIOSequences.load_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelIOSequences.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |FastAccessIOSequence.load_data| of the |FastAccessIOSequence|</span>
<span class="sd">        object handled as attribute `fastaccess`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelIOSequences.save_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelIOSequences.save_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |FastAccessIOSequence.save_data| of the |FastAccessIOSequence|</span>
<span class="sd">        object handled as attribute `fastaccess`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="InputSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InputSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InputSequences</span><span class="p">(</span><span class="n">ModelIOSequences</span><span class="p">[</span><span class="s2">&quot;InputSequence&quot;</span><span class="p">,</span> <span class="n">FastAccessInputSequence</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |InputSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessInputSequence</span></div>



<div class="viewcode-block" id="OutputSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutputSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OutputSequences</span><span class="p">(</span>
    <span class="n">ModelIOSequences</span><span class="p">[</span><span class="n">TypeOutputSequence_co</span><span class="p">,</span> <span class="n">FastAccessOutputSequence</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |OutputSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessOutputSequence</span>

<div class="viewcode-block" id="OutputSequences.update_outputs">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutputSequences.update_outputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |FastAccessOutputSequence.update_outputs| of the</span>
<span class="sd">        |FastAccessOutputSequence| object handled as attribute `fastaccess`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">update_outputs</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">numericsequences</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">TypeOutputSequence_co</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator for &quot;numerical&quot; sequences.</span>

<span class="sd">        &quot;numerical&quot; means that the |Sequence_.NUMERIC| class attribute of the actual</span>
<span class="sd">        sequence is |True|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;dam_v001&quot;)</span>
<span class="sd">        &gt;&gt;&gt; len(model.sequences.fluxes)</span>
<span class="sd">        16</span>
<span class="sd">        &gt;&gt;&gt; for seq in model.sequences.fluxes.numericsequences:</span>
<span class="sd">        ...     print(seq)</span>
<span class="sd">        adjustedprecipitation(nan)</span>
<span class="sd">        actualevaporation(nan)</span>
<span class="sd">        inflow(nan)</span>
<span class="sd">        actualrelease(nan)</span>
<span class="sd">        flooddischarge(nan)</span>
<span class="sd">        outflow(nan)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux</span><span class="o">.</span><span class="n">NUMERIC</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">flux</span></div>



<div class="viewcode-block" id="FactorSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FactorSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FactorSequences</span><span class="p">(</span><span class="n">OutputSequences</span><span class="p">[</span><span class="s2">&quot;FactorSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |FactorSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="FluxSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FluxSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FluxSequences</span><span class="p">(</span><span class="n">OutputSequences</span><span class="p">[</span><span class="s2">&quot;FluxSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |FluxSequence| objects.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Always return the string &quot;fluxes&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;fluxes&quot;</span></div>



<div class="viewcode-block" id="StateSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StateSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StateSequences</span><span class="p">(</span><span class="n">OutputSequences</span><span class="p">[</span><span class="s2">&quot;StateSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |StateSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">fastaccess_new</span><span class="p">:</span> <span class="n">FastAccessOutputSequence</span>
    <span class="n">fastaccess_old</span><span class="p">:</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_fastaccess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_init_fastaccess</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_fastaccess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="s2">&quot;new_states&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_fastaccess</span><span class="p">()</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="s2">&quot;old_states&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">)</span>

<div class="viewcode-block" id="StateSequences.new2old">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StateSequences.new2old">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">new2old</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |StateSequence.new2old| of all handled |StateSequence|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">new2old</span><span class="p">()</span></div>


<div class="viewcode-block" id="StateSequences.reset">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StateSequences.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |ConditionSequence.reset| of all handled |StateSequence|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="LogSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LogSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogSequences</span><span class="p">(</span><span class="n">ModelSequences</span><span class="p">[</span><span class="s2">&quot;LogSequence&quot;</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |LogSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span>

<div class="viewcode-block" id="LogSequences.reset">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LogSequences.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |ConditionSequence.reset| of all handled |LogSequence|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="AideSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.AideSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AideSequences</span><span class="p">(</span><span class="n">ModelSequences</span><span class="p">[</span><span class="s2">&quot;AideSequence&quot;</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |AideSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span></div>



<div class="viewcode-block" id="LinkSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LinkSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LinkSequences</span><span class="p">(</span><span class="n">ModelIOSequences</span><span class="p">[</span><span class="n">TypeLinkSequence_co</span><span class="p">,</span> <span class="n">FastAccessLinkSequence</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |LinkSequence| objects.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessLinkSequence</span></div>



<div class="viewcode-block" id="InletSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InletSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InletSequences</span><span class="p">(</span><span class="n">LinkSequences</span><span class="p">[</span><span class="s2">&quot;InletSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling &quot;inlet&quot; |LinkSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="OutletSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutletSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OutletSequences</span><span class="p">(</span><span class="n">LinkSequences</span><span class="p">[</span><span class="s2">&quot;OutletSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling &quot;outlet&quot; |LinkSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ObserverSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ObserverSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ObserverSequences</span><span class="p">(</span><span class="n">LinkSequences</span><span class="p">[</span><span class="s2">&quot;ObserverSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling &quot;observer&quot; |LinkSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ReceiverSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ReceiverSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReceiverSequences</span><span class="p">(</span><span class="n">LinkSequences</span><span class="p">[</span><span class="s2">&quot;ReceiverSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling &quot;receiver&quot; |LinkSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="SenderSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.SenderSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SenderSequences</span><span class="p">(</span><span class="n">LinkSequences</span><span class="p">[</span><span class="s2">&quot;SenderSequence&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling &quot;sender&quot; |LinkSequence| objects.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Sequence_">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sequence_">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sequence_</span><span class="p">(</span><span class="n">variabletools</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for defining different kinds of sequences.</span>

<span class="sd">    Note that model developers should not derive their model-specific sequence classes</span>
<span class="sd">    from |Sequence_| directly but from the &quot;final&quot; subclasses provided in module</span>
<span class="sd">    |sequencetools| (e.g. |FluxSequence|).</span>

<span class="sd">    From the model developer perspective and especially from the user perspective,</span>
<span class="sd">    |Sequence_| is only a small extension of its base class |Variable|.  One relevant</span>
<span class="sd">    extension is that (only the) 0-dimensional sequence objects come with a predefined</span>
<span class="sd">    shape:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">    &gt;&gt;&gt; model = prepare_model(&quot;lland_dd&quot;)</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qa.shape</span>
<span class="sd">    ()</span>
<span class="sd">    &gt;&gt;&gt; nkor = model.sequences.fluxes.nkor</span>
<span class="sd">    &gt;&gt;&gt; nkor.shape</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Shape information for variable \</span>
<span class="sd">`nkor` can only be retrieved after it has been defined.</span>

<span class="sd">    For consistency with the usage of |Parameter| subclasses, |Sequence_| objects are</span>
<span class="sd">    also &quot;callable&quot; for setting their values (but in a much less and flexible manner):</span>

<span class="sd">    &gt;&gt;&gt; nkor.shape = 3</span>
<span class="sd">    &gt;&gt;&gt; nkor(2.0)</span>
<span class="sd">    &gt;&gt;&gt; nkor</span>
<span class="sd">    nkor(2.0, 2.0, 2.0)</span>

<span class="sd">    Under the hood, class |Sequence_| also prepares some attributes of its |FastAccess|</span>
<span class="sd">    object, used for performing the actual simulation calculations.   Framework</span>
<span class="sd">    developers should note that the respective `fastaccess` attributes contain both the</span>
<span class="sd">    name of the sequence and the name of the original attribute in lowercase letters.</span>
<span class="sd">    We take `NDIM` as an example:</span>

<span class="sd">    &gt;&gt;&gt; nkor.fastaccess._nkor_ndim</span>
<span class="sd">    1</span>

<span class="sd">    Some of these attributes require updating in some situations.  For example, other</span>
<span class="sd">    sequences than |AideSequence| objects require a &quot;length&quot; attribute, which needs</span>
<span class="sd">    updating each time the sequence&#39;s shape changes:</span>

<span class="sd">    &gt;&gt;&gt; nkor.fastaccess._nkor_length</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TYPE</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">INIT</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">NUMERIC</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">SubSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">Sequence_</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">SubSequences</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">Sequence_</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">SubSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">Sequence_</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">SubSequences</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">Sequence_</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |Sequence_.subvars|.&quot;&quot;&quot;</span>
    <span class="n">strict_valuehandling</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__connect_variable2subgroup__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__hydpy__connect_variable2subgroup__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__get_fastaccessattribute__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A hook method, called at the end of method</span>
<span class="sd">        `__hydpy__connect_variable2subgroup__` for initialising values and some</span>
<span class="sd">        attributes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">initinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A |tuple| containing the initial value and |True| or a missing value and</span>
<span class="sd">        |False|, depending on the actual |Sequence_| subclass and the actual value of</span>
<span class="sd">        option |Options.usedefaultvalues|.</span>

<span class="sd">        In the following, we do not explain property |Sequence_.initinfo| itself but</span>
<span class="sd">        show how it affects initialising new |Sequence_| objects.  Therefore, let us</span>
<span class="sd">        define a sequence test class and prepare a function for initialising it and</span>
<span class="sd">        connecting the resulting instance to a |ModelSequences| object:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import Sequence_, ModelSequences</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.variabletools import FastAccess</span>
<span class="sd">        &gt;&gt;&gt; class Test(Sequence_):</span>
<span class="sd">        ...     NDIM = 0</span>
<span class="sd">        ...     _CLS_FASTACCESS_PYTHON = FastAccess</span>
<span class="sd">        &gt;&gt;&gt; class SubGroup(ModelSequences):</span>
<span class="sd">        ...     CLASSES = (Test,)</span>
<span class="sd">        ...     _CLS_FASTACCESS_PYTHON = FastAccess</span>
<span class="sd">        &gt;&gt;&gt; def prepare():</span>
<span class="sd">        ...     subseqs = SubGroup(None)</span>
<span class="sd">        ...     test = Test(subseqs)</span>
<span class="sd">        ...     test.__hydpy__connect_variable2subgroup__()</span>
<span class="sd">        ...     return test</span>

<span class="sd">        By default, making use of the `INIT` attribute is disabled:</span>

<span class="sd">        &gt;&gt;&gt; prepare()</span>
<span class="sd">        test(nan)</span>

<span class="sd">        Enable it by setting |Options.usedefaultvalues| to |True|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usedefaultvalues(True):</span>
<span class="sd">        ...     prepare()</span>
<span class="sd">        test(0.0)</span>

<span class="sd">        Attribute `INIT` of class |Sequence_| comes with the value `0.0` by default,</span>
<span class="sd">        which should be reasonable for most |Sequence_| subclasses.  However,</span>
<span class="sd">        subclasses can define other values.  Most importantly, note the possibility to</span>
<span class="sd">        set `INIT` to `None` for sequences that do not allow specifying a reasonabe</span>
<span class="sd">        initial value for all possible situations:</span>

<span class="sd">        &gt;&gt;&gt; Test.INIT = None</span>
<span class="sd">        &gt;&gt;&gt; prepare()</span>
<span class="sd">        test(nan)</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usedefaultvalues(True):</span>
<span class="sd">        ...     prepare()</span>
<span class="sd">        test(nan)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">usedefaultvalues</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">INIT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">INIT</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">to_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">brackets</span><span class="p">)</span></div>



<div class="viewcode-block" id="IOSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IOSequence</span><span class="p">(</span><span class="n">Sequence_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for sequences with input/output functionalities.</span>

<span class="sd">    The documentation on modules |filetools| and |netcdftools| in some detail explains</span>
<span class="sd">    how to read and write time series files.  However, due to efficiency, reading and</span>
<span class="sd">    writing time series files are disabled by default.  Therefore, you must first</span>
<span class="sd">    prepare the |IOSequence.series| attribute of the relevant |IOSequence| objects.</span>
<span class="sd">    Typically, you call methods like |HydPy.prepare_inputseries| of class |HydPy|.</span>
<span class="sd">    Here, we instead use the related features of the |IOSequence| class itself.</span>

<span class="sd">    We use the `HydPy-H-Lahn` example project and focus on the `input`, `factor`,</span>
<span class="sd">    `fluxes`, and `state` sequences:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">    &gt;&gt;&gt; inputs = hp.elements.land_lahn_marb.model.sequences.inputs</span>
<span class="sd">    &gt;&gt;&gt; factors = hp.elements.land_lahn_marb.model.sequences.factors</span>
<span class="sd">    &gt;&gt;&gt; fluxes = hp.elements.land_lahn_marb.model.sequences.fluxes</span>
<span class="sd">    &gt;&gt;&gt; states = hp.elements.land_lahn_marb.model.sequences.states</span>

<span class="sd">    Each |IOSequence| object comes four flags, answering the following questions:</span>

<span class="sd">     * |IOSequence.ramflag|: can its time series can be available in RAM?</span>
<span class="sd">     * |IOSequence.diskflag_reading|: read its values &quot;on the fly&quot; from a NetCDF file</span>
<span class="sd">       during simulation runs?</span>
<span class="sd">     * |IOSequence.diskflag_writing|:write its values &quot;on the fly&quot; to a NetCDF file</span>
<span class="sd">       during simulation runs?</span>
<span class="sd">     * |IOSequence.diskflag|: is |IOSequence.diskflag_reading| and/or</span>
<span class="sd">       |IOSequence.diskflag_writing| activated?</span>

<span class="sd">    For input sequences as |hland_inputs.T|, it is common to store their time series</span>
<span class="sd">    data (required for any simulation run) in RAM, which is much faster than</span>
<span class="sd">    (repeatedly) reading data &quot;on the fly&quot; and should be preferred, as long as limited</span>
<span class="sd">    available RAM is not an issue.  For convenience, function |prepare_full_example_2|</span>
<span class="sd">    prepared |hland_inputs.T| (and the other input sequences) accordingly:</span>

<span class="sd">    &gt;&gt;&gt; inputs.t.ramflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag_reading</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag_writing</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(inputs.t.series)</span>
<span class="sd">    -0.7, -1.5, -4.6, -8.2</span>

<span class="sd">    |prepare_full_example_2| also activated the |IOSequence.ramflag| of all factor,</span>
<span class="sd">    flux, and state sequences, which is unnecessary to perform a successful simulation.</span>
<span class="sd">    However, it is required to directly access the complete time series of simulated</span>
<span class="sd">    values afterwards (otherwise, only the last computed value(s) were available in</span>
<span class="sd">    RAM after a simulation run):</span>

<span class="sd">    &gt;&gt;&gt; factors.tc.ramflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; factors.tc.diskflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; round_(factors.tc.series[:, 0])</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    Use |IOSequence.prepare_series| to force a sequence to handle time series data in</span>
<span class="sd">    RAM or to read or write it on the fly.  We now activate the reading functionality</span>
<span class="sd">    of input sequence |hland_inputs.T| (while still keeping its time series in RAM,</span>
<span class="sd">    which we set to zero beforehand) and the writing feature of the factor sequences</span>
<span class="sd">    |hland_factors.ContriArea| and |hland_factors.TC| (without handling their data in</span>
<span class="sd">    RAM) and the writing feature of the state sequences |hland_states.SM| and</span>
<span class="sd">    |hland_states.SP| (while handling their data in RAM simultaneously):</span>

<span class="sd">    &gt;&gt;&gt; inputs.t.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.prepare_series(allocate_ram=True, read_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; factors.contriarea.prepare_series(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; factors.tc.prepare_series(allocate_ram=False, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; states.sm.prepare_series(allocate_ram=True, write_jit=True)</span>
<span class="sd">    &gt;&gt;&gt; states.sp.prepare_series(allocate_ram=True, write_jit=True)</span>

<span class="sd">    Use the properties |IOSequence.ramflag|, |IOSequence.diskflag_reading|,</span>
<span class="sd">    |IOSequence.diskflag_writing|, and |IOSequence.diskflag| for querying the current</span>
<span class="sd">    configuration of individual |IOSequence| objects:</span>

<span class="sd">    &gt;&gt;&gt; inputs.t.ramflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag_reading</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag_writing</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; inputs.t.diskflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; round_(inputs.t.series)</span>
<span class="sd">    0.0, 0.0, 0.0, 0.0</span>

<span class="sd">    &gt;&gt;&gt; factors.contriarea.ramflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; factors.contriarea.diskflag_reading</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; factors.contriarea.diskflag_writing</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; factors.contriarea.diskflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; factors.contriarea.series</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Sequence `contriarea` of element \</span>
<span class="sd">`land_lahn_marb` is not requested to make any time series data available.</span>

<span class="sd">    &gt;&gt;&gt; states.sm.ramflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; states.sm.diskflag_reading</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; states.sm.diskflag_writing</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; states.sm.diskflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; round_(states.sm.series[:, 0])</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    Now we perform a simulation run.  Note that we need to change the current working</span>
<span class="sd">    directory to the `iotesting` directory temporarily (by using class |TestIO|)</span>
<span class="sd">    because the relevant NetCDF files are now read and written on the fly:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.threads(0):</span>
<span class="sd">    ...     hp.simulate()</span>

<span class="sd">    After the simulation run, the read (|hland_inputs.T|) and calculated</span>
<span class="sd">    (|hland_states.SM| and |hland_states.SP|) time series of the sequences with an</span>
<span class="sd">    activated |IOSequence.ramflag| are directly available:</span>

<span class="sd">    &gt;&gt;&gt; round_(inputs.t.series)</span>
<span class="sd">    -0.7, -1.5, -4.6, -8.2</span>
<span class="sd">    &gt;&gt;&gt; round_(states.sm.series[:, 0])</span>
<span class="sd">    99.1369, 99.01204, 98.93674, 98.91913</span>
<span class="sd">    &gt;&gt;&gt; round_(states.sp.series[:, 0, 0])</span>
<span class="sd">    0.0, 0.0, 0.0, 0.0</span>

<span class="sd">    To inspect the time series of |hland_factors.ContriArea| and |hland_factors.TC|,</span>
<span class="sd">    you must first activate their |IOSequence.ramflag| and then load their data</span>
<span class="sd">    manually with method |IOSequence.load_series|.  The latter requires some additional</span>
<span class="sd">    configuration effort (see the documentation on module |netcdftools| for further</span>
<span class="sd">    information):</span>

<span class="sd">    &gt;&gt;&gt; factors.contriarea.prepare_series()</span>
<span class="sd">    &gt;&gt;&gt; factors.tc.prepare_series()</span>
<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.filetype = &quot;nc&quot;</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     pub.sequencemanager.open_netcdfreader()</span>
<span class="sd">    ...     factors.contriarea.load_series()</span>
<span class="sd">    ...     factors.tc.load_series()</span>
<span class="sd">    ...     pub.sequencemanager.close_netcdfreader()</span>
<span class="sd">    &gt;&gt;&gt; round_(factors.contriarea.series)</span>
<span class="sd">    0.431311, 0.430524, 0.430049, 0.429938</span>
<span class="sd">    &gt;&gt;&gt; round_(factors.tc.series[:, 0])</span>
<span class="sd">    0.453086, -0.346914, -3.446914, -7.046914</span>

<span class="sd">    We also load time series of |hland_states.SM| and |hland_states.SP| to demonstrate</span>
<span class="sd">    that the data written to the respective NetCDF files are identical with the data</span>
<span class="sd">    directly stored in RAM:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     pub.sequencemanager.open_netcdfreader()</span>
<span class="sd">    ...     states.sm.load_series()</span>
<span class="sd">    ...     states.sp.load_series()</span>
<span class="sd">    ...     pub.sequencemanager.close_netcdfreader()</span>
<span class="sd">    &gt;&gt;&gt; round_(states.sm.series[:, 0])</span>
<span class="sd">    99.1369, 99.01204, 98.93674, 98.91913</span>
<span class="sd">    &gt;&gt;&gt; round_(states.sp.series[:, 0, 0])</span>
<span class="sd">    0.0, 0.0, 0.0, 0.0</span>

<span class="sd">    Writing the time series of input sequences on the fly is supported but not</span>
<span class="sd">    simultaneously with reading them (at best, one would overwrite the same file with</span>
<span class="sd">    the same data; at worst, one could corrupt it):</span>

<span class="sd">    &gt;&gt;&gt; inputs.t.prepare_series(read_jit=True, write_jit=True)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Reading from and writing into the same NetCDF file &quot;just in time&quot; \</span>
<span class="sd">during a simulation run is not supported but tried for sequence `t` of element \</span>
<span class="sd">`land_lahn_marb`.</span>

<span class="sd">    For simplifying the following examples, we now handle all model time series in RAM:</span>

<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.filetype = &quot;asc&quot;</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_modelseries()</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_inputseries()</span>

<span class="sd">    You cannot only access the time series data of individual |IOSequence| objects, but</span>
<span class="sd">    you can also modify it.  See, for example, the simulated time series for flux</span>
<span class="sd">    sequence |hland_fluxes.PC| (adjusted precipitation), which is zero because the</span>
<span class="sd">    values of input sequence |hland_inputs.P| (given precipitation) are also zero:</span>

<span class="sd">    &gt;&gt;&gt; round_(fluxes.pc.series[:, 0])</span>
<span class="sd">    0.0, 0.105611, 0.0, 0.0</span>

<span class="sd">    We can assign different values to attribute |IOSequence.series| of sequence</span>
<span class="sd">    |hland_inputs.P|, perform a new simulation run, and see that the newly calculated</span>
<span class="sd">    time series of sequence |hland_fluxes.PC| reflects our data modification:</span>

<span class="sd">    &gt;&gt;&gt; inputs.p.series = 10.0</span>
<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">    &gt;&gt;&gt; round_(fluxes.pc.series[:, 0])</span>
<span class="sd">    9.154557, 10.561131, 10.665633, 10.665633</span>

<span class="sd">    Another convenience property is |IOSequence.seriesshape|, which combines the length</span>
<span class="sd">    of the simulation period with the shape of the individual |IOSequence| object:</span>

<span class="sd">    &gt;&gt;&gt; inputs.p.seriesshape</span>
<span class="sd">    (4,)</span>
<span class="sd">    &gt;&gt;&gt; fluxes.pc.seriesshape</span>
<span class="sd">    (4, 13)</span>

<span class="sd">    Note that resetting the |IOSequence.shape| of an |IOSequence| object does not</span>
<span class="sd">    change how it handles its internal time series data but results in a loss of</span>
<span class="sd">    current information:</span>

<span class="sd">    &gt;&gt;&gt; factors.tc.seriesshape</span>
<span class="sd">    (4, 13)</span>
<span class="sd">    &gt;&gt;&gt; factors.fastaccess._tc_length</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; round_(factors.tc.series[:, 0], 1)</span>
<span class="sd">    0.5, -0.3, -3.4, -7.0</span>

<span class="sd">    &gt;&gt;&gt; factors.tc.shape = 2,</span>
<span class="sd">    &gt;&gt;&gt; factors.tc.seriesshape</span>
<span class="sd">    (4, 2)</span>
<span class="sd">    &gt;&gt;&gt; factors.fastaccess._tc_length</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; round_(factors.tc.series[:, 0])</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    Resetting the |IOSequence.shape| of |IOSequence| objects with a deactivated</span>
<span class="sd">    |IOSequence.ramflag| data works likewise:</span>

<span class="sd">    &gt;&gt;&gt; fluxes.pc.prepare_series(allocate_ram=False)</span>

<span class="sd">    &gt;&gt;&gt; fluxes.pc.seriesshape</span>
<span class="sd">    (4, 13)</span>
<span class="sd">    &gt;&gt;&gt; fluxes.fastaccess._pc_length</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; fluxes.pc.series</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Sequence `pc` of element \</span>
<span class="sd">`land_lahn_marb` is not requested to make any time series data available.</span>

<span class="sd">    &gt;&gt;&gt; fluxes.pc.shape = (2,)</span>
<span class="sd">    &gt;&gt;&gt; fluxes.pc.seriesshape</span>
<span class="sd">    (4, 2)</span>
<span class="sd">    &gt;&gt;&gt; fluxes.fastaccess._pc_length</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; fluxes.pc.series = 1.0</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: Sequence `pc` of element \</span>
<span class="sd">`land_lahn_marb` is not requested to make any time series data available.</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">IOSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">IOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">IOSequences</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">IOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the IO sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="p">(</span>
        <span class="n">IOSequences</span><span class="p">[</span><span class="n">Sequences</span><span class="p">,</span> <span class="n">IOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">IOSequences</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">IOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |IOSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess</span><span class="p">:</span> <span class="n">FastAccessIOSequence</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object for accessing the IO sequence&#39;s data with little overhead.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ramflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_reading&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_writing&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finalise_connections</span><span class="p">()</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertySeriesFileType</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filetype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SeriesFileType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;Ending of the time series data file.</span>

<span class="sd">        Usually, |IOSequence| objects query the current file type from the</span>
<span class="sd">        |SequenceManager| object available in the global |pub| module:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.filetools import SequenceManager</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager = SequenceManager()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import InputSequence</span>
<span class="sd">        &gt;&gt;&gt; inputsequence = InputSequence(None)</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype</span>
<span class="sd">        &#39;asc&#39;</span>

<span class="sd">        Alternatively, you can specify the file type for each |IOSequence| object</span>
<span class="sd">        individually:</span>

<span class="sd">        &gt;&gt;&gt; inputsequence.filetype = &quot;npy&quot;</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype</span>
<span class="sd">        &#39;npy&#39;</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype = &quot;nc&quot;</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype</span>
<span class="sd">        &#39;nc&#39;</span>

<span class="sd">        Use the `del` statement to reset the object-specific setting:</span>

<span class="sd">        &gt;&gt;&gt; del inputsequence.filetype</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype</span>
<span class="sd">        &#39;asc&#39;</span>

<span class="sd">        If neither a specific definition nor a |SequenceManager| object is available,</span>
<span class="sd">        property |IOSequence.filetype| raises the following error:</span>

<span class="sd">        &gt;&gt;&gt; del pub.sequencemanager</span>
<span class="sd">        &gt;&gt;&gt; inputsequence.filetype</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Sequence `inputsequence` does \</span>
<span class="sd">not know its file type.  Either set it manually or prepare `pub.sequencemanager` \</span>
<span class="sd">correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">SeriesFileType</span><span class="p">,</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">filetype</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not know its file &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type.  Either set it manually or prepare `pub.sequencemanager` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;correctly.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertySeriesAggregationType</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">aggregation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SeriesAggregationType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type of aggregation for writing the time series to a data file.</span>

<span class="sd">        Usually, |IOSequence| objects query the current aggregation mode from the</span>
<span class="sd">        |SequenceManager| object available in the global |pub| module:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.filetools import SequenceManager</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager = SequenceManager()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import FluxSequence</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence = FluxSequence(None)</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.aggregation</span>
<span class="sd">        &#39;none&#39;</span>

<span class="sd">        Alternatively, you can specify the aggregation for each |IOSequence| object</span>
<span class="sd">        individually:</span>

<span class="sd">        &gt;&gt;&gt; fluxsequence.aggregation = &quot;mean&quot;</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.aggregation</span>
<span class="sd">        &#39;mean&#39;</span>

<span class="sd">        Use the `del` statement to reset the object-specific setting:</span>

<span class="sd">        &gt;&gt;&gt; del fluxsequence.aggregation</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.aggregation</span>
<span class="sd">        &#39;none&#39;</span>

<span class="sd">        If neither a specific definition nor a |SequenceManager| object is available,</span>
<span class="sd">        property |IOSequence.aggregation| raises the following error:</span>

<span class="sd">        &gt;&gt;&gt; del pub.sequencemanager</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.aggregation</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Sequence `fluxsequence` does not \</span>
<span class="sd">know its aggregation mode.  Either set it manually or prepare `pub.sequencemanager` \</span>
<span class="sd">correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">SeriesAggregationType</span><span class="p">,</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">aggregation</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not know its &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;aggregation mode.  Either set it manually or prepare &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`pub.sequencemanager` correctly.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertyBool</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True/False flag indicating if overwriting an existing data file is allowed</span>
<span class="sd">        or not.</span>

<span class="sd">        Usually, |IOSequence| objects query the current overwrite flag from the</span>
<span class="sd">        |SequenceManager| object available in the global |pub| module:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.filetools import SequenceManager</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager = SequenceManager()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import FluxSequence</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence = FluxSequence(None)</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.overwrite</span>
<span class="sd">        0</span>

<span class="sd">        Alternatively, you can specify the overwrite flag for each |IOSequence| object</span>
<span class="sd">        individually:</span>

<span class="sd">        &gt;&gt;&gt; fluxsequence.overwrite = True</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.overwrite</span>
<span class="sd">        1</span>

<span class="sd">        Use the `del` statement to reset the object-specific setting:</span>

<span class="sd">        &gt;&gt;&gt; del fluxsequence.overwrite</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.overwrite</span>
<span class="sd">        0</span>

<span class="sd">        If neither a specific definition nor a |SequenceManager| object is available,</span>
<span class="sd">        property |IOSequence.overwrite| raises the following error:</span>

<span class="sd">        &gt;&gt;&gt; del pub.sequencemanager</span>
<span class="sd">        &gt;&gt;&gt; fluxsequence.overwrite</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Sequence `fluxsequence` does not \</span>
<span class="sd">know its overwrite flag.  Either set it manually or prepare `pub.sequencemanager` \</span>
<span class="sd">correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not know its &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;overwrite flag.  Either set it manually or prepare &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`pub.sequencemanager` correctly.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertyStr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The filename of the relevant time series file.</span>

<span class="sd">        By default, the filenames of file types that store time series of single</span>
<span class="sd">        sequence instance consists of |IOSequence.descr_device|,</span>
<span class="sd">        |IOSequence.descr_sequence|, and |IOSequence.filetype|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; class S(StateSequence):</span>
<span class="sd">        ...     descr_device = &quot;device&quot;</span>
<span class="sd">        ...     descr_sequence = &quot;group_sequence&quot;</span>
<span class="sd">        ...     filetype = &quot;npy&quot;</span>
<span class="sd">        ...     aggregation = &quot;none&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = S(None)</span>
<span class="sd">        &gt;&gt;&gt; s.filename</span>
<span class="sd">        &#39;device_group_sequence.npy&#39;</span>

<span class="sd">        For file types that store time series of multiple sequence instances,</span>
<span class="sd">        |IOSequence.descr_device| is omitted:</span>

<span class="sd">        &gt;&gt;&gt; s.filetype = &quot;nc&quot;</span>
<span class="sd">        &gt;&gt;&gt; s.filename</span>
<span class="sd">        &#39;group_sequence.nc&#39;</span>

<span class="sd">        When dealing with aggregated time series, the aggregation mode is suffixed:</span>

<span class="sd">        &gt;&gt;&gt; s.aggregation = &quot;mean&quot;</span>
<span class="sd">        &gt;&gt;&gt; s.filename</span>
<span class="sd">        &#39;group_sequence_mean.nc&#39;</span>
<span class="sd">        &gt;&gt;&gt; s.filetype = &quot;asc&quot;</span>
<span class="sd">        &gt;&gt;&gt; s.filename</span>
<span class="sd">        &#39;device_group_sequence_mean.asc&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">agg</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregation</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">aggregation</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aggregation</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">agg</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">filetype</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filetype</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;nc&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">descr_sequence</span><span class="si">}{</span><span class="n">aggregation</span><span class="si">}</span><span class="s2">.nc&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">descr_device</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">descr_sequence</span><span class="si">}{</span><span class="n">aggregation</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">filetype</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertyStr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dirpath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The absolute path to the time series directory.</span>

<span class="sd">        As long as it is not overwritten, |IOSequence.dirpath| is identical to the</span>
<span class="sd">        attribute |FileManager.currentpath| of the |SequenceManager| object available</span>
<span class="sd">        in module |pub|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub, repr_</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.filetools import SequenceManager</span>
<span class="sd">        &gt;&gt;&gt; class SM(SequenceManager):</span>
<span class="sd">        ...     currentpath = &quot;temp&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager = SM()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; repr_(StateSequence(None).dirpath)</span>
<span class="sd">        &#39;temp&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">currentpath</span>

    <span class="nd">@propertytools</span><span class="o">.</span><span class="n">DefaultPropertyStr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The absolute path to the time series file.</span>

<span class="sd">        The path pointing to the file consists of |IOSequence.dirpath| and</span>
<span class="sd">        |IOSequence.filename|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; seq = StateSequence(None)</span>
<span class="sd">        &gt;&gt;&gt; seq.dirpath = &quot;path&quot;</span>
<span class="sd">        &gt;&gt;&gt; seq.filename = &quot;file.npy&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import repr_</span>
<span class="sd">        &gt;&gt;&gt; repr_(seq.filepath)</span>
<span class="sd">        &#39;path/file.npy&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirpath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="IOSequence.update_fastaccess">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.update_fastaccess">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_fastaccess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the |FastAccessIOSequence| object handled by the actual |IOSequence|</span>
<span class="sd">        object.</span>

<span class="sd">        Users do not need to apply the method |IOSequence.update_fastaccess| directly.</span>
<span class="sd">        The following information should be relevant for framework developers only.</span>

<span class="sd">        The main documentation on class |Sequence_| mentions that the</span>
<span class="sd">        |FastAccessIOSequence| attribute handles some information about its sequences,</span>
<span class="sd">        but it needs to be kept up-to-date by the sequences themselves.  This updating</span>
<span class="sd">        is the task of method |IOSequence.update_fastaccess|, being called by some</span>
<span class="sd">        other methods class |IOSequence| call.  We show this via the hidden attribute</span>
<span class="sd">        `length`, which is 0 after initialisation, and automatically set to another</span>
<span class="sd">        value when assigning it to property |IOSequence.shape| of |IOSequence|</span>
<span class="sd">        subclasses as |lland_fluxes.NKor|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;lland_dd&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nkor = model.sequences.fluxes.nkor</span>
<span class="sd">        &gt;&gt;&gt; nkor.fastaccess._nkor_length</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; nkor.shape = (3,)</span>
<span class="sd">        &gt;&gt;&gt; nkor.fastaccess._nkor_length</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.connect_netcdf">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.connect_netcdf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncarray</span><span class="p">:</span> <span class="n">NDArrayFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Connect the current |IOSequence| object to the given buffer array for</span>
<span class="sd">        reading from or writing to a NetCDF file on the fly during a simulation run.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ncarray&quot;</span><span class="p">,</span> <span class="n">ncarray</span><span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.prepare_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.prepare_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">allocate_ram</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">read_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">write_jit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define how to handle the time series data of the current |IOSequence| object.</span>

<span class="sd">        See the main documentation on class |IOSequence| for general information on</span>
<span class="sd">        method |IOSequence.prepare_series|.  Here, we only discuss the special case of</span>
<span class="sd">        passing |None| to it to preserve predefined settings.</span>

<span class="sd">        When leaving out certain arguments, |IOSequence.prepare_series| takes their</span>
<span class="sd">        boolean defaults.  That means subsequent calls overwrite previous ones:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; t = hp.elements.land_lahn_marb.model.sequences.inputs.t</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(allocate_ram=False, read_jit=True)</span>
<span class="sd">        &gt;&gt;&gt; t.ramflag, t.diskflag_reading, t.diskflag_writing</span>
<span class="sd">        (False, True, False)</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(write_jit=True)</span>
<span class="sd">        &gt;&gt;&gt; t.ramflag, t.diskflag_reading, t.diskflag_writing</span>
<span class="sd">        (True, False, True)</span>

<span class="sd">        If you want to change one setting without modifying the others, pass |None| to</span>
<span class="sd">        the latter:</span>

<span class="sd">        &gt;&gt;&gt; t.prepare_series(allocate_ram=False, read_jit=None, write_jit=None)</span>
<span class="sd">        &gt;&gt;&gt; t.ramflag, t.diskflag_reading, t.diskflag_writing</span>
<span class="sd">        (False, False, True)</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(allocate_ram=None, read_jit=True, write_jit=False)</span>
<span class="sd">        &gt;&gt;&gt; t.ramflag, t.diskflag_reading, t.diskflag_writing</span>
<span class="sd">        (False, True, False)</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(allocate_ram=None, read_jit=None, write_jit=None)</span>
<span class="sd">        &gt;&gt;&gt; t.ramflag, t.diskflag_reading, t.diskflag_writing</span>
<span class="sd">        (False, True, False)</span>

<span class="sd">        The check for configurations attempting to both read and write &quot;just in time&quot;</span>
<span class="sd">        takes predefined flags into account:</span>

<span class="sd">        &gt;&gt;&gt; t.prepare_series(read_jit=None, write_jit=True)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Reading from and writing into the same NetCDF file &quot;just in time&quot; \</span>
<span class="sd">during a simulation run is not supported but tried for sequence `t` of element \</span>
<span class="sd">`land_lahn_marb`.</span>

<span class="sd">        &gt;&gt;&gt; t.prepare_series(read_jit=False, write_jit=True)</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(read_jit=True, write_jit=None)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Reading from and writing into the same NetCDF file &quot;just in time&quot; \</span>
<span class="sd">during a simulation run is not supported but tried for sequence `t` of element \</span>
<span class="sd">`land_lahn_marb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">readflag</span> <span class="o">=</span> <span class="n">read_jit</span> <span class="ow">or</span> <span class="p">((</span><span class="n">read_jit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">diskflag_reading</span><span class="p">)</span>
        <span class="n">writeflag</span> <span class="o">=</span> <span class="n">write_jit</span> <span class="ow">or</span> <span class="p">((</span><span class="n">write_jit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">diskflag_writing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readflag</span> <span class="ow">and</span> <span class="n">writeflag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Reading from and writing into the same NetCDF file &quot;just in time&quot; &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;during a simulation run is not supported but tried for sequence &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">allocate_ram</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ramflag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span>
            <span class="k">if</span> <span class="n">allocate_ram</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ramflag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__set_array</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seriesshape</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">ramflag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allocate_ram</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ramflag&quot;</span><span class="p">,</span> <span class="n">allocate_ram</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">read_jit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inflag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;inputflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                <span class="s2">&quot;diskflag_reading&quot;</span><span class="p">,</span> <span class="n">read_jit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inflag</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">write_jit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_writing&quot;</span><span class="p">,</span> <span class="n">write_jit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_fastaccess</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ramflag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if the actual |IOSequence| object makes its time series data</span>
<span class="sd">        directly available in RAM.</span>

<span class="sd">        See the main documentation on class |IOSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ramflag&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">diskflag_reading</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if the actual |IOSequence| reads its time series data on the</span>
<span class="sd">        fly from a NetCDF file during a simulation run.</span>

<span class="sd">        See the main documentation on class |IOSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_reading&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">diskflag_writing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if the actual |IOSequence| writes its time series data on the</span>
<span class="sd">        fly to a NetCDF file during a simulation run.</span>

<span class="sd">        See the main documentation on class |IOSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_writing&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">diskflag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if |IOSequence.diskflag_reading| and/or</span>
<span class="sd">        |IOSequence.diskflag_writing| of the current |IOSequence| object is |True|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; for reading in (False, True):</span>
<span class="sd">        ...     for writing in (False, True):</span>
<span class="sd">        ...         class S(StateSequence):</span>
<span class="sd">        ...             diskflag_reading = reading</span>
<span class="sd">        ...             diskflag_writing = writing</span>
<span class="sd">        ...         print(reading, writing, S(None).diskflag)</span>
<span class="sd">        False False False</span>
<span class="sd">        False True True</span>
<span class="sd">        True False True</span>
<span class="sd">        True True True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diskflag_reading</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">diskflag_writing</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">memoryflag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if either |IOSequence.ramflag| and/or |IOSequence.diskflag|</span>
<span class="sd">        of the current |IOSequence| object is |True|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; for ram in (False, True):</span>
<span class="sd">        ...     for disk in (False, True):</span>
<span class="sd">        ...         class S(StateSequence):</span>
<span class="sd">        ...             ramflag = ram</span>
<span class="sd">        ...             diskflag = disk</span>
<span class="sd">        ...         print(ram, disk, S(None).memoryflag)</span>
<span class="sd">        False False False</span>
<span class="sd">        False True True</span>
<span class="sd">        True False True</span>
<span class="sd">        True True True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">diskflag</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seriesmode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SeriesMode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A combination of property |IOSequence.ramflag|,</span>
<span class="sd">        |IOSequence.diskflag_reading|, and |IOSequence.diskflag_writing|.</span>

<span class="sd">        |IOSequence.seriesmode| allows querying and changing all mentioned properties in</span>
<span class="sd">        one step:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; t = hp.elements.land_lahn_marb.model.sequences.inputs.t</span>
<span class="sd">        &gt;&gt;&gt; t.prepare_series(read_jit=True)</span>
<span class="sd">        &gt;&gt;&gt; sm_t = t.seriesmode</span>
<span class="sd">        &gt;&gt;&gt; sm_t</span>
<span class="sd">        SeriesMode(ramflag=True, diskflag_reading=True, diskflag_writing=False)</span>
<span class="sd">        &gt;&gt;&gt; p = hp.elements.land_lahn_marb.model.sequences.inputs.p</span>
<span class="sd">        &gt;&gt;&gt; p.prepare_series(allocate_ram=False, write_jit=True)</span>
<span class="sd">        &gt;&gt;&gt; sm_p = p.seriesmode</span>
<span class="sd">        &gt;&gt;&gt; sm_p</span>
<span class="sd">        SeriesMode(ramflag=False, diskflag_reading=False, diskflag_writing=True)</span>

<span class="sd">        &gt;&gt;&gt; t.seriesmode = sm_p</span>
<span class="sd">        &gt;&gt;&gt; t.seriesmode</span>
<span class="sd">        SeriesMode(ramflag=False, diskflag_reading=False, diskflag_writing=True)</span>
<span class="sd">        &gt;&gt;&gt; p.seriesmode = sm_t</span>
<span class="sd">        &gt;&gt;&gt; p.seriesmode</span>
<span class="sd">        SeriesMode(ramflag=True, diskflag_reading=True, diskflag_writing=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SeriesMode</span><span class="p">(</span>
            <span class="n">ramflag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span><span class="p">,</span>
            <span class="n">diskflag_reading</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diskflag_reading</span><span class="p">,</span>
            <span class="n">diskflag_writing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diskflag_writing</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@seriesmode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seriesmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sm</span><span class="p">:</span> <span class="n">SeriesMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_series</span><span class="p">(</span>
            <span class="n">allocate_ram</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">ramflag</span><span class="p">,</span>
            <span class="n">read_jit</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">diskflag_reading</span><span class="p">,</span>
            <span class="n">write_jit</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">diskflag_writing</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A tuple containing the actual lengths of all dimensions.</span>

<span class="sd">        When setting a new |IOSequence.shape| of an |IOSequence| object, one</span>
<span class="sd">        automatically calls method |IOSequence.update_fastaccess| and, if necessary,</span>
<span class="sd">        prepares the new internal |IOSequence.series| array.</span>

<span class="sd">        See the main documentation on class |IOSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seriesshape</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_fastaccess</span><span class="p">()</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_shape</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seriesshape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the whole time series (time being the first dimension).&quot;&quot;&quot;</span>
        <span class="n">seriesshape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="p">)]</span>
        <span class="n">seriesshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seriesshape</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The complete time series data of the current |IOSequence| object within an</span>
<span class="sd">        |InfoArray| covering the whole initialisation period (defined by the</span>
<span class="sd">        |Timegrids.init| |Timegrid| of the global |Timegrids| object available in</span>
<span class="sd">        module |pub|).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">InfoArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s2">&quot;unmodified&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not requested to make any &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;time series data available.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_array</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seriesshape</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_completeness</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not requested to make &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;any time series data available.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_del_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ramflag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ramflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">series</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_series</span><span class="p">,</span> <span class="n">_set_series</span><span class="p">,</span> <span class="n">_del_series</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read and write access to the subset of the data of property</span>
<span class="sd">        |IOSequence.series| covering the actual simulation period (defined by the</span>
<span class="sd">        |Timegrids.sim| |Timegrid| of the global |Timegrids| object available in module</span>
<span class="sd">        |pub|).</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; t = hp.elements.land_lahn_marb.model.sequences.inputs.t</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.dates = &quot;1996-01-02&quot;, &quot;1996-01-04&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import print_vector</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.series)</span>
<span class="sd">        -0.7, -1.5, -4.6, -8.2</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.simseries)</span>
<span class="sd">        -1.5, -4.6</span>
<span class="sd">        &gt;&gt;&gt; t.simseries = 1.0, 2.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.series)</span>
<span class="sd">        -0.7, 1.0, 2.0, -8.2</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Element, Node</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">simindices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">simindices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="n">simseries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_simseries</span><span class="p">,</span> <span class="n">_set_simseries</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_evalseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read and write access to the subset of the data of property |</span>
<span class="sd">        IOSequence.series| covering the actual evaluation period (defined by the</span>
<span class="sd">        |Timegrids.eval_| |Timegrid| of the global |Timegrids| object available in</span>
<span class="sd">        module |pub|).</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; t = hp.elements.land_lahn_marb.model.sequences.inputs.t</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.eval_.dates = &quot;1996-01-02&quot;, &quot;1996-01-04&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import print_vector</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.series)</span>
<span class="sd">        -0.7, -1.5, -4.6, -8.2</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.evalseries)</span>
<span class="sd">        -1.5, -4.6</span>
<span class="sd">        &gt;&gt;&gt; t.evalseries = 1.0, 2.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(t.series)</span>
<span class="sd">        -0.7, 1.0, 2.0, -8.2</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Element, Node</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">evalindices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_evalseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">evalindices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="n">evalseries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_evalseries</span><span class="p">,</span> <span class="n">_set_evalseries</span><span class="p">)</span>

<div class="viewcode-block" id="IOSequence.load_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.load_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read time series data from a file.</span>

<span class="sd">        Method |IOSequence.load_series| only calls method |SequenceManager.load_file|</span>
<span class="sd">        of class |SequenceManager| passing itself as the only argument.  Hence, see the</span>
<span class="sd">        documentation on the class |SequenceManager| for further information.  The</span>
<span class="sd">        following example only shows the error messages when |SequenceManager.load_file|</span>
<span class="sd">        is missing due to incomplete project configurations:</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.sequencemanager</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; StateSequence(None).load_series()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: While trying to load the time \</span>
<span class="sd">series data of `statesequence`, the following error occurred: Attribute \</span>
<span class="sd">sequencemanager of module `pub` is not defined at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequencemanager</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to load the time series data of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">sequencemanager</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.adjust_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.adjust_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timegrid_data</span><span class="p">:</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Timegrid</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArrayFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust a time series to the current initialisation period.</span>

<span class="sd">        Note that, in most *HydPy* applications, method |IOSequence.adjust_series| is</span>
<span class="sd">        called by other methods related to reading data from files and does not need to</span>
<span class="sd">        be called by the user directly.  However, if  you want to call it directly for</span>
<span class="sd">        some reason, you need to make sure that the shape of the given |numpy|</span>
<span class="sd">        |numpy.ndarray| fits the given |Timegrid| object.</span>

<span class="sd">        Often, time series data available in data files cover a longer period than</span>
<span class="sd">        required for an actual simulation run.  Method |IOSequence.adjust_series|</span>
<span class="sd">        selects the relevant data by comparing the initialisation |Timegrid| available</span>
<span class="sd">        in module |pub| and the given &quot;data&quot; |Timegrid| object.  We explain this</span>
<span class="sd">        behaviour by using the `HydPy-H-Lahn` example project and focussing on the</span>
<span class="sd">        |Obs| sequence of |Node| `dill_assl`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; obs = hp.nodes.dill_assl.sequences.obs</span>

<span class="sd">        With identical initialisation and data time grids, method</span>
<span class="sd">        |IOSequence.adjust_series| returns the given data completely:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import print_vector, Timegrid</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">        ...     print_vector(obs.adjust_series(</span>
<span class="sd">        ...         Timegrid(&quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;),</span>
<span class="sd">        ...         numpy.arange(4, dtype=float)))</span>
<span class="sd">        0.0, 1.0, 2.0, 3.0</span>

<span class="sd">        For &quot;too long&quot; data, it only returns the relevant one:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">        ...     print_vector(obs.adjust_series(</span>
<span class="sd">        ...         Timegrid(&quot;1995-12-31&quot;, &quot;1996-01-07&quot;, &quot;1d&quot;),</span>
<span class="sd">        ...         numpy.arange(7, dtype=float)))</span>
<span class="sd">        1.0, 2.0, 3.0, 4.0</span>

<span class="sd">        For &quot;too short&quot; data, the behaviour differs depending on option</span>
<span class="sd">        |Options.checkseries|.  With |Options.checkseries| being enabled, method</span>
<span class="sd">        |IOSequence.adjust_series| raises a |RuntimeError|.  With |Options.checkseries|</span>
<span class="sd">        being disabled, it extends the given array with |numpy.nan| values (using</span>
<span class="sd">        method |IOSequence.adjust_short_series|):</span>

<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.options.checkseries(True):</span>
<span class="sd">        ...     obs.adjust_series(Timegrid(&quot;1996-01-02&quot;, &quot;1996-01-04&quot;, &quot;1d&quot;),</span>
<span class="sd">        ...                       numpy.zeros((3,)))  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: For sequence `obs` of node `dill_assl` the initialisation time \</span>
<span class="sd">grid (Timegrid(&quot;1996-01-01 00:00:00&quot;, &quot;1996-01-05 00:00:00&quot;, &quot;1d&quot;)) does not define a \</span>
<span class="sd">subset of the time grid of the data file `...dill_assl_obs_q.asc` \</span>
<span class="sd">(Timegrid(&quot;1996-01-02 00:00:00&quot;, &quot;1996-01-04 00:00:00&quot;, &quot;1d&quot;)).</span>

<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">        ...     print_vector(obs.adjust_series(</span>
<span class="sd">        ...         Timegrid(&quot;1996-01-02&quot;, &quot;1996-01-04&quot;, &quot;1d&quot;), numpy.zeros((2,))))</span>
<span class="sd">        nan, 0.0, 0.0, nan</span>

<span class="sd">        Additional checks raise errors in case of non-matching shapes or time</span>
<span class="sd">        information:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     obs.adjust_series(Timegrid(&quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;),</span>
<span class="sd">        ...                       numpy.zeros((5, 2)))  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The shape of sequence `obs` of node `dill_assl` is `()` but \</span>
<span class="sd">according to the data file `...dill_assl_obs_q.asc` it should be `(2,)`.</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     obs.adjust_series(Timegrid(&quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1h&quot;),</span>
<span class="sd">        ...                       numpy.zeros((24*5,)))  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: According to data file `...dill_assl_obs_q.asc`, the date time \</span>
<span class="sd">step of sequence `obs` of node `dill_assl` is `1h` but the actual simulation time \</span>
<span class="sd">step is `1d`.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">` but according to the data file `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="si">}</span><span class="s2">` it &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;should be `</span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">!=</span> <span class="n">timegrid_data</span><span class="o">.</span><span class="n">stepsize</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;According to data file `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="si">}</span><span class="s2">`, the date time step of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">timegrid_data</span><span class="o">.</span><span class="n">stepsize</span><span class="si">}</span><span class="s2">` but the actual simulation time step is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">stepsize</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">timegrid_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">checkseries</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;For sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> the initialisation &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;time grid (</span><span class="si">{</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="si">}</span><span class="s2">) does not define a subset &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of the time grid of the data file `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">timegrid_data</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_short_series</span><span class="p">(</span><span class="n">timegrid_data</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">idx1</span> <span class="o">=</span> <span class="n">timegrid_data</span><span class="p">[</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">firstdate</span><span class="p">]</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="n">timegrid_data</span><span class="p">[</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">lastdate</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span></div>


<div class="viewcode-block" id="IOSequence.adjust_short_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.adjust_short_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_short_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timegrid</span><span class="p">:</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Timegrid</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArrayFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust a short time series to a longer time grid.</span>

<span class="sd">        Mostly, time series data to be read from files should span (at least) the whole</span>
<span class="sd">        initialisation period of a *HydPy* project.  However, incomplete time series</span>
<span class="sd">        might also be helpful for some variables used only for comparison (e.g.</span>
<span class="sd">        observed runoff used for calibration).  Method |IOSequence.adjust_short_series|</span>
<span class="sd">        adjusts such incomplete series to the public initialisation time grid stored in</span>
<span class="sd">        module |pub|.  It is automatically called in method |IOSequence.adjust_series|</span>
<span class="sd">        when necessary, provided that the option |Options.checkseries| is disabled.</span>

<span class="sd">        Assume the initialisation period of a HydPy project spans five days:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000.01.10&quot;, &quot;2000.01.15&quot;, &quot;1d&quot;</span>

<span class="sd">        Prepare a node series object for observational data:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import Obs</span>
<span class="sd">        &gt;&gt;&gt; obs = Obs(None)</span>

<span class="sd">        Prepare a test function that expects the time grid of the data and the data</span>
<span class="sd">        itself, which returns the adjusted array through invoking the method</span>
<span class="sd">        |IOSequence.adjust_short_series|:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; def test(timegrid):</span>
<span class="sd">        ...     values = numpy.ones(len(timegrid))</span>
<span class="sd">        ...     return obs.adjust_short_series(timegrid, values)</span>

<span class="sd">        The following calls to the test function show the arrays returned for different</span>
<span class="sd">        kinds of misalignments:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import print_vector, Timegrid</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.05&quot;, &quot;2000.01.20&quot;, &quot;1d&quot;)))</span>
<span class="sd">        1.0, 1.0, 1.0, 1.0, 1.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.12&quot;, &quot;2000.01.15&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, 1.0, 1.0, 1.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.12&quot;, &quot;2000.01.17&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, 1.0, 1.0, 1.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.10&quot;, &quot;2000.01.13&quot;, &quot;1d&quot;)))</span>
<span class="sd">        1.0, 1.0, 1.0, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.08&quot;, &quot;2000.01.13&quot;, &quot;1d&quot;)))</span>
<span class="sd">        1.0, 1.0, 1.0, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.12&quot;, &quot;2000.01.13&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, 1.0, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.05&quot;, &quot;2000.01.10&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, nan, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.05&quot;, &quot;2000.01.08&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, nan, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.15&quot;, &quot;2000.01.18&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, nan, nan, nan</span>
<span class="sd">        &gt;&gt;&gt; print_vector(test(Timegrid(&quot;2000.01.16&quot;, &quot;2000.01.18&quot;, &quot;1d&quot;)))</span>
<span class="sd">        nan, nan, nan, nan, nan</span>

<span class="sd">        After enabling option |Options.usedefaultvalues|, the missing values are</span>
<span class="sd">        initialised with zero instead of nan:</span>

<span class="sd">        &gt;&gt;&gt; with pub.options.usedefaultvalues(True):</span>
<span class="sd">        ...     print_vector(test(Timegrid(&quot;2000.01.12&quot;, &quot;2000.01.17&quot;, &quot;1d&quot;)))</span>
<span class="sd">        0.0, 0.0, 1.0, 1.0, 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">timegrid</span><span class="p">[</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">firstdate</span><span class="p">],</span>
            <span class="n">timegrid</span><span class="p">[</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">lastdate</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="n">valcopy</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seriesshape</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valcopy</span><span class="p">)</span>
        <span class="n">jdxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">jdxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">len_</span><span class="p">:</span>
                <span class="n">jdxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jdxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">len_</span><span class="p">)</span>
        <span class="n">valcopy</span> <span class="o">=</span> <span class="n">valcopy</span><span class="p">[</span><span class="n">jdxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">jdxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">zdx1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">zdx2</span> <span class="o">=</span> <span class="n">zdx1</span> <span class="o">+</span> <span class="n">jdxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">jdxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">values</span><span class="p">[</span><span class="n">zdx1</span><span class="p">:</span><span class="n">zdx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">valcopy</span>
        <span class="k">return</span> <span class="n">values</span></div>


<div class="viewcode-block" id="IOSequence.apply_adjusted_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.apply_adjusted_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_adjusted_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timegrid_data</span><span class="p">:</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Timegrid</span><span class="p">,</span> <span class="n">series</span><span class="p">:</span> <span class="n">NDArrayFloat</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take the values of the given &quot;adjusted series&quot;.</span>

<span class="sd">        The &quot;adjusted series&quot; is usually returned by method |IOSequence.adjust_series|.</span>
<span class="sd">        The behaviour of method |IOSequence.apply_adjusted_series| depends on option</span>
<span class="sd">        |SequenceManager.reset|.  By default, &quot;resetting&quot; is enabled, meaning that</span>
<span class="sd">        |numpy.nan| values due to incomplete time series files overwrite previously</span>
<span class="sd">        available data.  We demonstrate this using the NetCDF data provided by function</span>
<span class="sd">        |prepare_full_example_2| but changing the initialisation period (only advised</span>
<span class="sd">        for testing purposes):</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.init.firstdate = &quot;1989-10-30&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.init.lastdate = &quot;1989-11-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; t = hp.elements.land_dill_assl.model.sequences.inputs.t</span>
<span class="sd">        &gt;&gt;&gt; t.series = -99.9</span>
<span class="sd">        &gt;&gt;&gt; opt = pub.options</span>
<span class="sd">        &gt;&gt;&gt; sm = pub.sequencemanager</span>
<span class="sd">        &gt;&gt;&gt; with (</span>
<span class="sd">        ...     TestIO(), sm.filetype(&quot;nc&quot;), opt.checkseries(False), sm.netcdfreading()</span>
<span class="sd">        ... ):</span>
<span class="sd">        ...     t.load_series()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(t.series)</span>
<span class="sd">        nan, nan, 10.1, 10.0</span>

<span class="sd">        With option |SequenceManager.reset| disabled, method</span>
<span class="sd">        |IOSequence.apply_adjusted_series| keeps the already available data:</span>

<span class="sd">        &gt;&gt;&gt; t.series = 99.9</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), sm.reset(False), sm.filetype(&quot;nc&quot;), opt.checkseries(False):</span>
<span class="sd">        ...     with sm.netcdfreading():</span>
<span class="sd">        ...         t.load_series()</span>
<span class="sd">        &gt;&gt;&gt; round_(t.series)</span>
<span class="sd">        99.9, 99.9, 10.1, 10.0</span>

<span class="sd">        If the available data covers the complete initialisation period, option</span>
<span class="sd">        |SequenceManager.reset| does not make a difference:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.init.firstdate = &quot;1990-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.init.lastdate = &quot;2020-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), sm.filetype(&quot;nc&quot;), opt.checkseries(False):</span>
<span class="sd">        ...     t.series = -99.9</span>
<span class="sd">        ...     with sm.netcdfreading():</span>
<span class="sd">        ...         t.load_series()</span>
<span class="sd">        ...     values = t.series.copy()</span>
<span class="sd">        ...     t.series = 99.9</span>
<span class="sd">        ...     with sm.reset(False), sm.netcdfreading():</span>
<span class="sd">        ...         t.load_series()</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; assert numpy.array_equal(values, t.series)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">reset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">series</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="n">timegrid_data</span><span class="o">.</span><span class="n">firstdate</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="n">timegrid_data</span><span class="o">.</span><span class="n">lastdate</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">init</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span></div>


<div class="viewcode-block" id="IOSequence.check_completeness">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.check_completeness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_completeness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a |RuntimeError| if the |IOSequence.series| contains at least one</span>
<span class="sd">        |numpy.nan| value and if the option |Options.checkseries| is enabled.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-01-11&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence, StateSequences</span>
<span class="sd">        &gt;&gt;&gt; class Seq(StateSequence):</span>
<span class="sd">        ...     NDIM = 0</span>
<span class="sd">        ...     NUMERIC = False</span>
<span class="sd">        &gt;&gt;&gt; class StateSequences(StateSequences):</span>
<span class="sd">        ...     CLASSES = (Seq,)</span>
<span class="sd">        &gt;&gt;&gt; seq = Seq(StateSequences(None))</span>
<span class="sd">        &gt;&gt;&gt; seq.__hydpy__connect_variable2subgroup__()</span>
<span class="sd">        &gt;&gt;&gt; seq.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; seq.check_completeness()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The series array of sequence `seq` contains 10 nan values.</span>

<span class="sd">        &gt;&gt;&gt; seq.series = 1.0</span>
<span class="sd">        &gt;&gt;&gt; seq.check_completeness()</span>

<span class="sd">        &gt;&gt;&gt; seq.series[3] = numpy.nan</span>
<span class="sd">        &gt;&gt;&gt; seq.check_completeness()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The series array of sequence `seq` contains 1 nan value.</span>

<span class="sd">        &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">        ...     seq.check_completeness()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">checkseries</span><span class="p">:</span>
            <span class="n">isnan</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isnan</span><span class="p">):</span>
                <span class="n">nmb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">isnan</span><span class="p">)</span>
                <span class="n">valuestring</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span> <span class="k">if</span> <span class="n">nmb</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;values&quot;</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The series array of sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;contains </span><span class="si">{</span><span class="n">nmb</span><span class="si">}</span><span class="s2"> nan </span><span class="si">{</span><span class="n">valuestring</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.save_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.save_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the time series data of the current |IOSequence| object to a file.</span>

<span class="sd">        Method |IOSequence.save_series| only calls method |SequenceManager.save_file|</span>
<span class="sd">        of class |SequenceManager|, passing itself as the only argument.  Hence, see</span>
<span class="sd">        the documentation on class the |SequenceManager| for further information.  The</span>
<span class="sd">        following example only shows the error messages when |SequenceManager.save_file|</span>
<span class="sd">        is missing due to incomplete project configurations:</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.sequencemanager</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence</span>
<span class="sd">        &gt;&gt;&gt; StateSequence(None).save_series()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: While trying to save the time \</span>
<span class="sd">series data of `statesequence`, the following error occurred: Attribute \</span>
<span class="sd">sequencemanager of module `pub` is not defined at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequencemanager</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to save the time series data of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">sequencemanager</span><span class="o">.</span><span class="n">save_file</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.save_mean">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.save_mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Average the time series data with method |IOSequence.average_series| of</span>
<span class="sd">        class |IOSequence| and write the result to file using method</span>
<span class="sd">        |SequenceManager.save_file| of class |SequenceManager|.</span>

<span class="sd">        The main documentation on class |SequenceManager| provides some examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">InfoArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">average_series</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">aggregation</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">aggregation</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">save_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seriesmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MatrixFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The actual |IOSequence| object&#39;s time series, arranged in a 2-dimensional</span>
<span class="sd">        matrix.</span>

<span class="sd">        For a 1-dimensional sequence object, property |IOSequence.seriesmatrix| returns</span>
<span class="sd">        the original values without modification:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-01-04&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.models.hland import *</span>
<span class="sd">        &gt;&gt;&gt; parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nmbzones(2)</span>
<span class="sd">        &gt;&gt;&gt; fluxes.pc.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; fluxes.pc.series = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import print_vector</span>
<span class="sd">        &gt;&gt;&gt; for values in fluxes.pc.seriesmatrix:</span>
<span class="sd">        ...     print_vector(values)</span>
<span class="sd">        1.0, 2.0</span>
<span class="sd">        3.0, 4.0</span>
<span class="sd">        5.0, 6.0</span>

<span class="sd">        For all other sequences, |IOSequence.seriesmatrix| raises the following error</span>
<span class="sd">        by default:</span>

<span class="sd">        &gt;&gt;&gt; inputs.p.seriesmatrix</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        NotImplementedError: Sequence `p` does not implement a method for converting \</span>
<span class="sd">its series to a 2-dimensional matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement a method &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;for converting its series to a 2-dimensional matrix.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="IOSequence.average_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.average_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Average the actual time series of the |IOSequence| object for all time</span>
<span class="sd">        points.</span>

<span class="sd">        Method |IOSequence.average_series| works similarly to method</span>
<span class="sd">        |Variable.average_values| of class |Variable|, from which we borrow some</span>
<span class="sd">        examples. However, we must first prepare a |Timegrids| object to define the</span>
<span class="sd">        |IOSequence.series| length:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-01-04&quot;, &quot;1d&quot;</span>

<span class="sd">        As shown for method |Variable.average_values|, for 0-dimensional |IOSequence|</span>
<span class="sd">        objects, the result of method |IOSequence.average_series| equals</span>
<span class="sd">        |IOSequence.series| itself:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.sequencetools import StateSequence, StateSequences</span>
<span class="sd">        &gt;&gt;&gt; class SoilMoisture(StateSequence):</span>
<span class="sd">        ...     NDIM = 0</span>
<span class="sd">        ...     NUMERIC = False</span>
<span class="sd">        &gt;&gt;&gt; class StateSequences(StateSequences):</span>
<span class="sd">        ...     CLASSES = (SoilMoisture,)</span>
<span class="sd">        &gt;&gt;&gt; sm = SoilMoisture(StateSequences(None))</span>
<span class="sd">        &gt;&gt;&gt; sm.__hydpy__connect_variable2subgroup__()</span>
<span class="sd">        &gt;&gt;&gt; sm.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; sm.series = numpy.array([190.0, 200.0, 210.0])</span>
<span class="sd">        &gt;&gt;&gt; sm.average_series()</span>
<span class="sd">        InfoArray([190., 200., 210.])</span>

<span class="sd">        We require a weighting parameter for |IOSequence| objects with an increased</span>
<span class="sd">        dimensionality:</span>

<span class="sd">        &gt;&gt;&gt; SoilMoisture.NDIM = 1</span>
<span class="sd">        &gt;&gt;&gt; sm.shape = 3</span>
<span class="sd">        &gt;&gt;&gt; sm.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; sm.series = ([190.0, 390.0, 490.0],</span>
<span class="sd">        ...              [200.0, 400.0, 500.0],</span>
<span class="sd">        ...              [210.0, 410.0, 510.0])</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.parametertools import Parameter</span>
<span class="sd">        &gt;&gt;&gt; class Area(Parameter):</span>
<span class="sd">        ...     NDIM = 1</span>
<span class="sd">        ...     shape = (3,)</span>
<span class="sd">        ...     value = numpy.array([1.0, 1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; area = Area(None)</span>
<span class="sd">        &gt;&gt;&gt; SoilMoisture.refweights = property(lambda self: area)</span>
<span class="sd">        &gt;&gt;&gt; sm.average_series()</span>
<span class="sd">        InfoArray([390., 400., 410.])</span>

<span class="sd">        The documentation on method |Variable.average_values| provides many examples of</span>
<span class="sd">        using different masks in different ways.  Here, we only show the results of</span>
<span class="sd">        method |IOSequence.average_series| for a mask selecting the first two entries,</span>
<span class="sd">        for a mask selecting no entry at all, and for an ill-defined mask:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.masktools import DefaultMask</span>
<span class="sd">        &gt;&gt;&gt; class Soil(DefaultMask):</span>
<span class="sd">        ...     @classmethod</span>
<span class="sd">        ...     def new(cls, variable, **kwargs):</span>
<span class="sd">        ...         return cls.array2mask(maskvalues)</span>
<span class="sd">        &gt;&gt;&gt; SoilMoisture.mask = Soil()</span>

<span class="sd">        &gt;&gt;&gt; maskvalues = [True, True, False]</span>
<span class="sd">        &gt;&gt;&gt; sm.average_series()</span>
<span class="sd">        InfoArray([290., 300., 310.])</span>

<span class="sd">        &gt;&gt;&gt; maskvalues = [False, False, False]</span>
<span class="sd">        &gt;&gt;&gt; sm.average_series()</span>
<span class="sd">        InfoArray([nan, nan, nan])</span>

<span class="sd">        &gt;&gt;&gt; maskvalues = [True, True]</span>
<span class="sd">        &gt;&gt;&gt; sm.average_series()  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        IndexError: While trying to calculate the mean value of the internal time \</span>
<span class="sd">series of sequence `soilmoisture`, the following error occurred: While trying to \</span>
<span class="sd">access the value(s) of variable `area` with key `[ True  True]`, the following error \</span>
<span class="sd">occurred: boolean index did not match indexed array ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_submask</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refweights</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                    <span class="n">weights</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
                    <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seriesmatrix</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">InfoArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to calculate the mean value of the internal time &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;series of sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="IOSequence.aggregate_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.IOSequence.aggregate_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">aggregate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InfoArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aggregate the time series data based on the actual |IOSequence.aggregation|</span>
<span class="sd">        attribute of the current |IOSequence| object.</span>

<span class="sd">        We prepare some nodes and elements with the help of method</span>
<span class="sd">        |prepare_io_example_1| and select a 1-dimensional flux sequence of type</span>
<span class="sd">        |lland_fluxes.NKor|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_io_example_1</span>
<span class="sd">        &gt;&gt;&gt; nodes, elements = prepare_io_example_1()</span>
<span class="sd">        &gt;&gt;&gt; seq = elements.element3.model.sequences.fluxes.nkor</span>

<span class="sd">        If |IOSequence.aggregation| is `none`, the original time series values are</span>
<span class="sd">        returned:</span>

<span class="sd">        &gt;&gt;&gt; seq.aggregation</span>
<span class="sd">        &#39;none&#39;</span>
<span class="sd">        &gt;&gt;&gt; seq.aggregate_series()</span>
<span class="sd">        InfoArray([[24., 25., 26.],</span>
<span class="sd">                   [27., 28., 29.],</span>
<span class="sd">                   [30., 31., 32.],</span>
<span class="sd">                   [33., 34., 35.]])</span>

<span class="sd">        If |IOSequence.aggregation| is `mean`, method |IOSequence.aggregate_series| is</span>
<span class="sd">        called:</span>

<span class="sd">        &gt;&gt;&gt; seq.aggregation = &quot;mean&quot;</span>
<span class="sd">        &gt;&gt;&gt; seq.aggregate_series()</span>
<span class="sd">        InfoArray([25., 28., 31., 34.])</span>

<span class="sd">        In case the state of the sequence is invalid:</span>

<span class="sd">        &gt;&gt;&gt; seq.aggregation = &quot;nonexistent&quot;</span>
<span class="sd">        &gt;&gt;&gt; seq.aggregate_series()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: Unknown aggregation mode `nonexistent` for sequence `nkor` of \</span>
<span class="sd">element `element3`.</span>

<span class="sd">        The following technical test confirms the propr passing of all potential</span>
<span class="sd">        positional and keyword arguments:</span>

<span class="sd">        &gt;&gt;&gt; seq.aggregation = &quot;mean&quot;</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; seq.average_series = mock.MagicMock()</span>
<span class="sd">        &gt;&gt;&gt; _ = seq.aggregate_series(1, x=2)</span>
<span class="sd">        &gt;&gt;&gt; seq.average_series.assert_called_with(1, x=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregation</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>  <span class="c1"># pylint: disable=comparison-with-callable</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>  <span class="c1"># pylint: disable=comparison-with-callable</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_series</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown aggregation mode `</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">` for sequence &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |IOSequence| object and its context.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |Device| object the |IOSequence| object belongs to.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ModelSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelSequence</span><span class="p">(</span><span class="n">Sequence_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for sequences to be handled by |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">ModelSequences</span><span class="p">[</span><span class="n">ModelSequence</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the model sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">ModelSequences</span><span class="p">[</span><span class="n">ModelSequence</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |ModelSequence.subvars|.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">subvars</span><span class="p">:</span> <span class="n">ModelSequences</span><span class="p">[</span><span class="n">ModelSequence</span><span class="p">,</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">subvars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span> <span class="o">=</span> <span class="n">subvars</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |ModelSequence| object itself and the |Model| type and</span>
<span class="sd">        |SubSequences| group it belongs to.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.models import test_stiff0d</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(test_stiff0d)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.q.descr_sequence</span>
<span class="sd">        &#39;test_stiff0d_flux_q&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |Model| the |ModelSequence| object belongs to.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.models import test, test_stiff0d</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(test)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.q.descr_model</span>
<span class="sd">        &#39;test&#39;</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(test_stiff0d)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.q.descr_model</span>
<span class="sd">        &#39;test_stiff0d&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |Element| object the |ModelSequence| object belongs to.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model, pub, Element</span>
<span class="sd">        &gt;&gt;&gt; element = Element(&quot;my_element&quot;, outlets=&quot;outlet&quot;)</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.models.lland_knauf import *</span>
<span class="sd">        &gt;&gt;&gt; parameterstep()</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inputs.windspeed.descr_device</span>
<span class="sd">        &#39;?&#39;</span>
<span class="sd">        &gt;&gt;&gt; element.model = model</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inputs.windspeed.descr_device</span>
<span class="sd">        &#39;my_element&#39;</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2001-01-02&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; nhru(1)</span>
<span class="sd">        &gt;&gt;&gt; ft(1.0)</span>
<span class="sd">        &gt;&gt;&gt; fhru(1.0)</span>
<span class="sd">        &gt;&gt;&gt; gh(100.0)</span>
<span class="sd">        &gt;&gt;&gt; lnk(ACKER)</span>
<span class="sd">        &gt;&gt;&gt; measuringheightwindspeed(10.0)</span>
<span class="sd">        &gt;&gt;&gt; lai(10.0)</span>
<span class="sd">        &gt;&gt;&gt; wmax(300.0)</span>
<span class="sd">        &gt;&gt;&gt; with model.add_aetmodel_v1(&quot;evap_aet_morsim&quot;):</span>
<span class="sd">        ...     pass</span>
<span class="sd">        &gt;&gt;&gt; model.aetmodel.sequences.inputs.windspeed.descr_device</span>
<span class="sd">        &#39;my_element&#39;</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">AttributeNotReady</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;?&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">numericshape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the array of temporary values required for the relevant</span>
<span class="sd">        numerical solver.</span>

<span class="sd">        The class |ELSModel|, being the base of the &quot;dam_llake&quot; model, uses the</span>
<span class="sd">        &quot;Explicit Lobatto Sequence&quot; for solving differential equations and therefore</span>
<span class="sd">        requires up to eleven array fields for storing temporary values.  Hence, the</span>
<span class="sd">        |ModelSequence.numericshape| of the 0-dimensional sequence |dam_fluxes.Inflow|</span>
<span class="sd">        is eleven:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;dam_llake&quot;)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.inflow.numericshape</span>
<span class="sd">        (11,)</span>

<span class="sd">        Changing the |IOSequence.shape| through a little trick (just for demonstration</span>
<span class="sd">        purposes) shows that there are eleven entries for each &quot;normal&quot;</span>
<span class="sd">        |dam_fluxes.Inflow| value:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.models.dam.dam_fluxes import Inflow</span>
<span class="sd">        &gt;&gt;&gt; shape = Inflow.shape</span>
<span class="sd">        &gt;&gt;&gt; Inflow.shape = (2,)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.inflow.numericshape</span>
<span class="sd">        (11, 2)</span>
<span class="sd">        &gt;&gt;&gt; Inflow.shape = shape</span>

<span class="sd">        Erroneous configurations result in the following error:</span>

<span class="sd">        &gt;&gt;&gt; del model.numconsts</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.fluxes.inflow.numericshape</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The `numericshape` of a sequence like `inflow` depends on the \</span>
<span class="sd">configuration of the actual integration algorithm.  While trying to query the \</span>
<span class="sd">required configuration data `nmb_stages` of the model associated with element `?`, \</span>
<span class="sd">the following error occurred: &#39;Model&#39; object has no attribute &#39;numconsts&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">modeltools</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">ELSModel</span><span class="p">)</span>  <span class="c1"># ToDo</span>
            <span class="n">numericshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">numconsts</span><span class="o">.</span><span class="n">nmb_stages</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The `numericshape` of a sequence like `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` depends on the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;configuration of the actual integration algorithm.  While trying to &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;query the required configuration data `nmb_stages` of the model &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;associated with element `</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span>
            <span class="p">)</span>
        <span class="n">numericshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numericshape</span><span class="p">)</span></div>



<div class="viewcode-block" id="ModelIOSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ModelIOSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelIOSequence</span><span class="p">(</span><span class="n">ModelSequence</span><span class="p">,</span> <span class="n">IOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for sequences with time series functionalities to be handled by</span>
<span class="sd">    |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">ModelIOSequences</span><span class="p">[</span><span class="n">ModelIOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the model IO sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">ModelIOSequences</span><span class="p">[</span><span class="n">ModelIOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |ModelIOSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">node2idx</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The connected |Node| instances and, for 1-dimensional link sequences, the </span>
<span class="sd">    corresponding column&#39;s indices.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">subvars</span><span class="p">:</span> <span class="n">ModelIOSequences</span><span class="p">[</span><span class="n">ModelIOSequence</span><span class="p">,</span> <span class="n">FastAccessIOSequence</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">subvars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node2idx</span> <span class="o">=</span> <span class="p">{}</span></div>



<div class="viewcode-block" id="BaseLinkInputSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.BaseLinkInputSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseLinkInputSequence</span><span class="p">(</span><span class="n">ModelIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for |LinkSequence| and |InputSequence|.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseLinkInputSequence.connect_to_nodes">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.BaseLinkInputSequence.connect_to_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect_to_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">LinkInputSequenceGroup</span><span class="p">,</span>
        <span class="n">available_nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
        <span class="n">applied_nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
        <span class="n">report_noconnect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Establish pointer connections with the relevant nodes.</span>

<span class="sd">        See the documentation on method |modeltools.Model.connect| for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node2idx</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">selected_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">available_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span> <span class="o">:=</span> <span class="n">node</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">FusedVariable</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="n">selected_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">selected_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">selected_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;inputs&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">report_noconnect</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> cannot be connected &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;due to no available node handling variable &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Sequence `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` cannot be connected as it is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;0-dimensional but multiple nodes are available which are &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;handling variable `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">selected_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">applied_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">InputSequence</span><span class="p">,</span> <span class="n">LinkSequence</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_pointer</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_double</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node2idx</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_nodes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selected_nodes</span><span class="p">):</span>
                <span class="n">applied_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LinkSequence</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_pointer</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_double</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node2idx</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span></div>
</div>



<div class="viewcode-block" id="InputSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InputSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InputSequence</span><span class="p">(</span><span class="n">BaseLinkInputSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for input sequences of |Model| objects.</span>

<span class="sd">    |InputSequence| objects provide their master model with input data, which is</span>
<span class="sd">    possible in two ways: either by providing their individually managed data (usually</span>
<span class="sd">    read from a file) or data shared with an input node (usually calculated by another</span>
<span class="sd">    model).  This flexibility allows, for example, to let application model |hland_96|</span>
<span class="sd">    read already preprocessed precipitation time series or to couple it with</span>
<span class="sd">    application models like |conv_nn|, which interpolates precipitation during the</span>
<span class="sd">    simulation run.</span>

<span class="sd">    The second mechanism (coupling |InputSequence| objects with input nodes) is</span>
<span class="sd">    relatively new, and we might adjust the relevant interfaces in the future.  As soon</span>
<span class="sd">    as we finally settle things, we will improve the following example and place it</span>
<span class="sd">    more prominently.  In short, it shows that working with both types of input data</span>
<span class="sd">    sources at the same time works well and that the different |Node.deploymode|</span>
<span class="sd">    options are supported:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_1</span>
<span class="sd">    &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Element, FusedVariable, HydPy, Node, print_vector, pub, TestIO</span>
<span class="sd">    &gt;&gt;&gt; from hydpy.aliases import  hland_inputs_T, hland_inputs_P</span>
<span class="sd">    &gt;&gt;&gt; hp = HydPy(&quot;HydPy-H-Lahn&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-06&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_t = Node(&quot;node_t&quot;, variable=hland_inputs_T)</span>
<span class="sd">    &gt;&gt;&gt; node_p = Node(&quot;node_p&quot;, variable=FusedVariable(&quot;Precip&quot;, hland_inputs_P))</span>
<span class="sd">    &gt;&gt;&gt; node_q = Node(&quot;node_q&quot;)</span>
<span class="sd">    &gt;&gt;&gt; land_dill_assl = Element(&quot;land_dill_assl&quot;, inputs=[node_t, node_p],</span>
<span class="sd">    ...                          outlets=node_q)</span>

<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     os.chdir(&quot;HydPy-H-Lahn/control/default&quot;)</span>
<span class="sd">    ...     with open(&quot;land_dill_assl.py&quot;) as controlfile:</span>
<span class="sd">    ...         exec(controlfile.read(), {}, locals())</span>
<span class="sd">    ...     parameters.update()</span>
<span class="sd">    ...     land_dill_assl.model = model</span>

<span class="sd">    &gt;&gt;&gt; aetmodel = model.aetmodel</span>
<span class="sd">    &gt;&gt;&gt; petmodel = model.aetmodel.petmodel</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.inputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.p.inputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; petmodel.sequences.inputs.normalevapotranspiration.inputflag</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; hp.update_devices(nodes=[node_t, node_p, node_q], elements=land_dill_assl)</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_inputseries()</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_factorseries()</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_fluxseries()</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_inputseries()</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.prepare_allseries()</span>
<span class="sd">    &gt;&gt;&gt; node_t.deploymode = &quot;oldsim&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_t.sequences.sim.series = 1.0, 2.0, 3.0, 4.0, 5.0</span>
<span class="sd">    &gt;&gt;&gt; node_p.deploymode = &quot;obs&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_p.sequences.obs.series = 0.0, 4.0, 0.0, 8.0, 0.0</span>

<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>

<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.inputs.t.series)</span>
<span class="sd">    1.0, 2.0, 3.0, 4.0, 5.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.factors.tc.series[:, 0])</span>
<span class="sd">    2.323207, 3.323207, 4.323207, 5.323207, 6.323207</span>
<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.inputs.p.series)</span>
<span class="sd">    0.0, 4.0, 0.0, 8.0, 0.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.fluxes.pc.series[:, 0])</span>
<span class="sd">    0.0, 3.2514, 0.0, 6.5028, 0.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(petmodel.sequences.inputs.normalevapotranspiration.series)</span>
<span class="sd">    0.3, 0.3, 0.3, 0.3, 0.3</span>
<span class="sd">    &gt;&gt;&gt; print_vector(</span>
<span class="sd">    ...     aetmodel.sequences.fluxes.potentialsoilevapotranspiration.series[:, 0])</span>
<span class="sd">    0.309, 0.317657, 0.369, 0.352975, 0.432</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; FusedVariable.clear_registry()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">InputSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the input sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">InputSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |InputSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess</span><span class="p">:</span> <span class="n">FastAccessInputSequence</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object for accessing the input sequence&#39;s data with little overhead.&quot;&quot;&quot;</span>

    <span class="n">STANDARD_NAME</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">StandardInputNames</span><span class="p">]</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessInputSequence</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__connect_variable2subgroup__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__hydpy__connect_variable2subgroup__</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;inputflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Either a model-specific or a standard HydPy string describing the input</span>
<span class="sd">        sequence instance.</span>

<span class="sd">        By default, the returned string equals those of other |ModelSequence|</span>
<span class="sd">        subclasses:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.filetools import SequenceManager</span>
<span class="sd">        &gt;&gt;&gt; pub.sequencemanager = SequenceManager()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.models.hland_96 import *</span>
<span class="sd">        &gt;&gt;&gt; parameterstep()</span>
<span class="sd">        &gt;&gt;&gt; inputs.t.descr_sequence</span>
<span class="sd">        &#39;hland_96_input_t&#39;</span>

<span class="sd">        When activating the standard &quot;HydPy&quot; convention instead of the &quot;model-specific&quot;</span>
<span class="sd">        convention, |InputSequence.descr_sequence| returns the standard name selected</span>
<span class="sd">        by the respective |InputSequence| subclass:</span>

<span class="sd">        &gt;&gt;&gt; with pub.sequencemanager.convention(&quot;HydPy&quot;):</span>
<span class="sd">        ...     inputs.t.descr_sequence</span>
<span class="sd">        &lt;StandardInputNames.AIR_TEMPERATURE: &#39;air_temperature&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span><span class="o">.</span><span class="n">convention</span> <span class="o">==</span> <span class="s2">&quot;model-specific&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">descr_sequence</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">STANDARD_NAME</span>

<div class="viewcode-block" id="InputSequence.set_pointer">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InputSequence.set_pointer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">double</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a pointer referencing the given |Double| object.</span>

<span class="sd">        Method |InputSequence.set_pointer| should be relevant for framework developers</span>
<span class="sd">        and eventually for some model developers only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdouble</span> <span class="o">=</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PDouble</span><span class="p">(</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">set_pointerinput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;inputflag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_reading&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_writing&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inputflag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if the actual |InputSequence| object queries its data from an</span>
<span class="sd">        input node (|True|) or uses individually managed data, usually read from a data</span>
<span class="sd">        file (|False|).</span>

<span class="sd">        See the main documentation on class |InputSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;inputflag&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="OutputSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutputSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OutputSequence</span><span class="p">(</span><span class="n">ModelIOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for |FactorSequence|, |FluxSequence| and |StateSequence|.</span>

<span class="sd">    |OutputSequence| subclasses implement an optional output mechanism.  Generally, as</span>
<span class="sd">    all instances of |ModelSequence| subclasses, output sequences handle values</span>
<span class="sd">    calculated within a simulation time step.  With an activated</span>
<span class="sd">    |OutputSequence.outputflag|, they also pass their internal values to an output node</span>
<span class="sd">    (see the documentation on class |Element|), which makes them accessible to other</span>
<span class="sd">    models.</span>

<span class="sd">    This output mechanism (coupling |OutputSequence| objects with output nodes) is</span>
<span class="sd">    relatively new, and we might adjust the relevant interfaces in the future.</span>
<span class="sd">    Additionally, it works for 0-dimensional output sequences only so far.  As soon as</span>
<span class="sd">    we finally settle things, we will improve the following example and place it more</span>
<span class="sd">    prominently.  In short, it shows that everything works well for the different</span>
<span class="sd">    |Node.deploymode| options:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_1</span>
<span class="sd">    &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Element, HydPy, Node, print_vector, pub, Selection, TestIO</span>
<span class="sd">    &gt;&gt;&gt; from hydpy.aliases import (</span>
<span class="sd">    ...     hland_fluxes_Perc, hland_fluxes_Q0, hland_fluxes_Q1, hland_states_UZ)</span>
<span class="sd">    &gt;&gt;&gt; hp = HydPy(&quot;HydPy-H-Lahn&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-06&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_q0 = Node(&quot;node_q0&quot;, variable=hland_fluxes_Q0)</span>
<span class="sd">    &gt;&gt;&gt; node_q1 = Node(&quot;node_q1&quot;, variable=hland_fluxes_Q1)</span>
<span class="sd">    &gt;&gt;&gt; node_perc = Node(&quot;node_perc&quot;, variable=hland_fluxes_Perc)</span>
<span class="sd">    &gt;&gt;&gt; node_uz = Node(&quot;node_uz&quot;, variable=hland_states_UZ)</span>
<span class="sd">    &gt;&gt;&gt; node_q = Node(&quot;node_q&quot;)</span>
<span class="sd">    &gt;&gt;&gt; land_dill_assl = Element(&quot;land_dill_assl&quot;,</span>
<span class="sd">    ...                     outlets=node_q,</span>
<span class="sd">    ...                     outputs=[node_q0, node_q1, node_perc, node_uz])</span>

<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     os.chdir(&quot;HydPy-H-Lahn/control/default&quot;)</span>
<span class="sd">    ...     with open(&quot;land_dill_assl.py&quot;) as controlfile:</span>
<span class="sd">    ...         exec(controlfile.read(), {}, locals())</span>
<span class="sd">    ...     parameters.update()</span>
<span class="sd">    ...     land_dill_assl.model = model</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.q0.outputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.q1.outputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.perc.outputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt.outputflag</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.uz.outputflag</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.lz.outputflag</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; hp.update_devices(nodes=[node_q, node_q0, node_q1, node_perc, node_uz],</span>
<span class="sd">    ...                   elements=land_dill_assl)</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_conditions()</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_inputseries()</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_inputseries()</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_fluxseries()</span>
<span class="sd">    &gt;&gt;&gt; hp.prepare_stateseries()</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.prepare_allseries()</span>

<span class="sd">    &gt;&gt;&gt; node_q0.deploymode = &quot;oldsim&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_q0.sequences.sim.series = 1.0</span>
<span class="sd">    &gt;&gt;&gt; node_q0.sequences.obs.series = 2.0</span>
<span class="sd">    &gt;&gt;&gt; node_q1.deploymode = &quot;obs&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_q1.sequences.obs.series = 3.0</span>
<span class="sd">    &gt;&gt;&gt; node_perc.deploymode = &quot;newsim&quot;</span>
<span class="sd">    &gt;&gt;&gt; node_perc.sequences.obs.series = 4.0</span>
<span class="sd">    &gt;&gt;&gt; node_uz.sequences.obs.series = 5.0</span>

<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>

<span class="sd">    &gt;&gt;&gt; print_vector(node_q0.sequences.sim.series)</span>
<span class="sd">    1.0, 1.0, 1.0, 1.0, 1.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_q0.sequences.obs.series)</span>
<span class="sd">    2.0, 2.0, 2.0, 2.0, 2.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.fluxes.q1.series)</span>
<span class="sd">    0.530782, 0.539976, 0.548629, 0.556786, 0.564477</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_q1.sequences.sim.series)</span>
<span class="sd">    0.530782, 0.539976, 0.548629, 0.556786, 0.564477</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_q1.sequences.obs.series)</span>
<span class="sd">    3.0, 3.0, 3.0, 3.0, 3.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.fluxes.perc.series)</span>
<span class="sd">    0.694084, 0.693611, 0.693239, 0.693098, 0.693012</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_perc.sequences.sim.series)</span>
<span class="sd">    0.694084, 0.693611, 0.693239, 0.693098, 0.693012</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_perc.sequences.obs.series)</span>
<span class="sd">    4.0, 4.0, 4.0, 4.0, 4.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(model.sequences.states.uz.series)</span>
<span class="sd">    5.628278, 4.368269, 3.337343, 2.452946, 1.662766</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_uz.sequences.sim.series)</span>
<span class="sd">    5.628278, 4.368269, 3.337343, 2.452946, 1.662766</span>
<span class="sd">    &gt;&gt;&gt; print_vector(node_uz.sequences.obs.series)</span>
<span class="sd">    5.0, 5.0, 5.0, 5.0, 5.0</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">OutputSequences</span><span class="p">[</span><span class="n">OutputSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the output sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">OutputSequences</span><span class="p">[</span><span class="n">OutputSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |OutputSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess</span><span class="p">:</span> <span class="n">FastAccessOutputSequence</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object for accessing the output sequence&#39;s data with little overhead.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessOutputSequence</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__connect_variable2subgroup__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__hydpy__connect_variable2subgroup__</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;outputflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="OutputSequence.set_pointer">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutputSequence.set_pointer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">double</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a pointer referencing the given |Double| object.</span>

<span class="sd">        Method |OutputSequence.set_pointer| should be relevant for framework developers</span>
<span class="sd">        and eventually for some model developers only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdouble</span> <span class="o">=</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PDouble</span><span class="p">(</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">set_pointeroutput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pdouble</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;outputflag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">outputflag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A flag telling if the actual |OutputSequence| object passes its data to an</span>
<span class="sd">        output node (|True|) or not (|False|).</span>

<span class="sd">        See the main documentation on class |OutputSequence| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__get_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;outputflag&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="DependentSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.DependentSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DependentSequence</span><span class="p">(</span><span class="n">OutputSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for |FactorSequence| and |FluxSequence|.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">modeltools</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finalise_connections</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUMERIC</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">ELSModel</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;integrals&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A tuple containing the actual lengths of all dimensions.</span>

<span class="sd">        |FactorSequence| and |FluxSequence| objects come with some additional</span>
<span class="sd">        `fastaccess` attributes, which should only be of interest to framework</span>
<span class="sd">        developers.  One such attribute is the `results` array, handling the</span>
<span class="sd">        (intermediate or final) calculation results for factor and flux sequences, as</span>
<span class="sd">        shown in the following example for the 0-dimensional flux sequence</span>
<span class="sd">        |wland_fluxes.RH| of the |wland_wag| model:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model, print_vector, pub</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;wland_wag&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print_vector(model.sequences.fluxes.rh.fastaccess._rh_results)</span>
<span class="sd">        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0</span>

<span class="sd">        For 1-dimensional numerical factor and flux sequences, the `results` attribute</span>
<span class="sd">        is |None| initially, as property |ModelSequence.numericshape| is unknown.</span>
<span class="sd">        Setting the |DependentSequence.shape| attribute of the respective</span>
<span class="sd">        |FactorSequence| or |FluxSequence| object (we select |wland_fluxes.EI| as an</span>
<span class="sd">        example) prepares all &quot;fastaccess attributes&quot; automatically:</span>

<span class="sd">        &gt;&gt;&gt; ei = model.sequences.fluxes.ei</span>
<span class="sd">        &gt;&gt;&gt; ei.fastaccess._ei_results</span>

<span class="sd">        &gt;&gt;&gt; ei.shape = (2,)</span>
<span class="sd">        &gt;&gt;&gt; ei.shape</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; ei.fastaccess._ei_results.shape</span>
<span class="sd">        (11, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUMERIC</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                <span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                <span class="s2">&quot;integrals&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                <span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_shape</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="FactorSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FactorSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FactorSequence</span><span class="p">(</span><span class="n">DependentSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for factor sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">FactorSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the factor sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">FactorSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |FactorSequence.subvars|.&quot;&quot;&quot;</span>

    <span class="n">NUMERIC</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Changing this requires implementing the related functionalites</span></div>

    <span class="c1"># in modules `modeltools` and `modeltutils`.</span>


<div class="viewcode-block" id="FluxSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.FluxSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FluxSequence</span><span class="p">(</span><span class="n">DependentSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for flux sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">FluxSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the flux sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">FluxSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |FluxSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ConditionSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ConditionSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConditionSequence</span><span class="p">(</span><span class="n">ModelSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for |StateSequence| and |LogSequence|.</span>

<span class="sd">    Class |ConditionSequence| should not be subclassed by model developers directly.</span>
<span class="sd">    Inherit from |StateSequence| or |LogSequence| instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_oldargs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The prefered way to pass values to |Sequence_| instances within initial</span>
<span class="sd">        condition files.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_oldargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionSequence.trim">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ConditionSequence.trim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply |trim| of module |variabletools|.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConditionSequence.reset">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ConditionSequence.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the value of the actual |StateSequence| or |LogSequence| object to the</span>
<span class="sd">        last value defined by &quot;calling&quot; the object.</span>

<span class="sd">        We use the |lland_knauf| application model, which handles sequences derived</span>
<span class="sd">        from |StateSequence| (taking |lland_states.Inzp| as an example) and from</span>
<span class="sd">        |LogSequence| (taking |lland_logs.LoggedSunshineDuration| as an example):</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model, pub</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;lland_knauf&quot;)</span>

<span class="sd">        After defining their shapes, both sequences contain |numpy.nan| values:</span>

<span class="sd">        &gt;&gt;&gt; inzp = model.sequences.states.inzp</span>
<span class="sd">        &gt;&gt;&gt; inzp.shape = (2,)</span>
<span class="sd">        &gt;&gt;&gt; inzp</span>
<span class="sd">        inzp(nan, nan)</span>
<span class="sd">        &gt;&gt;&gt; lsd = model.sequences.logs.loggedsunshineduration</span>
<span class="sd">        &gt;&gt;&gt; lsd.shape = 2</span>
<span class="sd">        &gt;&gt;&gt; lsd</span>
<span class="sd">        loggedsunshineduration(nan, nan)</span>

<span class="sd">        Before &quot;calling&quot; the sequences method |ConditionSequence.reset| does nothing:</span>

<span class="sd">        &gt;&gt;&gt; inzp.values = 0.0</span>
<span class="sd">        &gt;&gt;&gt; inzp.reset()</span>
<span class="sd">        &gt;&gt;&gt; inzp</span>
<span class="sd">        inzp(0.0, 0.0)</span>
<span class="sd">        &gt;&gt;&gt; lsd.values = 0.0</span>
<span class="sd">        &gt;&gt;&gt; lsd.reset()</span>
<span class="sd">        &gt;&gt;&gt; lsd</span>
<span class="sd">        loggedsunshineduration(0.0, 0.0)</span>

<span class="sd">        After &quot;calling&quot; the sequences method |ConditionSequence.reset| reuses the</span>
<span class="sd">        respective arguments:</span>

<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(False):</span>
<span class="sd">        ...     inzp(0.0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; inzp.values = 0.0</span>
<span class="sd">        &gt;&gt;&gt; inzp</span>
<span class="sd">        inzp(0.0, 0.0)</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(False):</span>
<span class="sd">        ...     inzp.reset()</span>
<span class="sd">        &gt;&gt;&gt; inzp</span>
<span class="sd">        inzp(0.0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; lsd(1.0, 2.0)</span>
<span class="sd">        &gt;&gt;&gt; lsd.values = 3.0</span>
<span class="sd">        &gt;&gt;&gt; lsd</span>
<span class="sd">        loggedsunshineduration(3.0, 3.0)</span>
<span class="sd">        &gt;&gt;&gt; lsd.reset()</span>
<span class="sd">        &gt;&gt;&gt; lsd</span>
<span class="sd">        loggedsunshineduration(1.0, 2.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_oldargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_oldargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="StateSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StateSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StateSequence</span><span class="p">(</span><span class="n">OutputSequence</span><span class="p">,</span> <span class="n">ConditionSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for state sequences of |Model| objects.</span>

<span class="sd">    Each |StateSequence| object can handle states at two different &quot;time points&quot;: at</span>
<span class="sd">    the beginning of a simulation step via property |StateSequence.old| and the end of</span>
<span class="sd">    a simulation step via property |StateSequence.new|.  These properties are reflected</span>
<span class="sd">    by two different `fastaccess` attributes.  `fastaccess_new` is an alias for the</span>
<span class="sd">    standard `fastaccess` attribute storing the customary information. `fastaccess_old`</span>
<span class="sd">    is an additional feature for keeping the supplemental information.</span>

<span class="sd">    We demonstrate the above explanations using state sequence |hland_states.SM| of the</span>
<span class="sd">    base model |hland_96| with a shape of two:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import prepare_model, print_vector</span>
<span class="sd">    &gt;&gt;&gt; model = prepare_model(&quot;hland&quot;)</span>
<span class="sd">    &gt;&gt;&gt; model.parameters.control.fc.shape = (2,)</span>
<span class="sd">    &gt;&gt;&gt; model.parameters.control.fc = 100.0</span>
<span class="sd">    &gt;&gt;&gt; sm = model.sequences.states.sm</span>
<span class="sd">    &gt;&gt;&gt; sm.shape = (2,)</span>

<span class="sd">    Initially, no values are available at all:</span>

<span class="sd">    &gt;&gt;&gt; sm</span>
<span class="sd">    sm(nan, nan)</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.values)</span>
<span class="sd">    nan, nan</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.new)</span>
<span class="sd">    nan, nan</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.old)</span>
<span class="sd">    nan, nan</span>

<span class="sd">    The typical way to define state values, especially within condition files, is to</span>
<span class="sd">    &quot;call&quot; state sequence objects, which sets both the &quot;old&quot; and the &quot;new&quot; states to</span>
<span class="sd">    the given value(s):</span>

<span class="sd">    &gt;&gt;&gt; sm(1.0)</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.values)</span>
<span class="sd">    1.0, 1.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.new)</span>
<span class="sd">    1.0, 1.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.old)</span>
<span class="sd">    1.0, 1.0</span>

<span class="sd">    Alternatively, one can assign values to property |StateSequence.new| or property</span>
<span class="sd">    |StateSequence.old| (note that using |StateSequence.new|  is identical with using</span>
<span class="sd">    the |Variable.value| property):</span>

<span class="sd">    &gt;&gt;&gt; sm.new = 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; sm</span>
<span class="sd">    sm(2.0, 3.0)</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.values)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.new)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.old)</span>
<span class="sd">    1.0, 1.0</span>

<span class="sd">    &gt;&gt;&gt; sm.old = 200.0</span>
<span class="sd">    &gt;&gt;&gt; sm</span>
<span class="sd">    sm(2.0, 3.0)</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.values)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.new)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.old)</span>
<span class="sd">    200.0, 200.0</span>

<span class="sd">    If you assign problematic values to property |StateSequence.old|, it raises similar</span>
<span class="sd">    error messages as property |Variable.value|:</span>

<span class="sd">    &gt;&gt;&gt; sm.old = 1.0, 2.0, 3.0</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to set the old value(s) of state sequence `sm`, the \</span>
<span class="sd">following error occurred: While trying to convert the value(s) `(1.0, 2.0, 3.0)` to a \</span>
<span class="sd">numpy ndarray with shape `(2,)` and type `float`, the following error occurred: could \</span>
<span class="sd">not broadcast input array from shape (3,) into shape (2,)</span>

<span class="sd">    Just for completeness:  Method |StateSequence.new2old| effectively takes the new</span>
<span class="sd">    values as old ones, but more efficiently than using the properties</span>
<span class="sd">    |StateSequence.new| and |StateSequence.old| (the Python method</span>
<span class="sd">    |StateSequence.new2old| is usually replaced by model-specific, cythonized version</span>
<span class="sd">    when working in Cython mode):</span>

<span class="sd">    &gt;&gt;&gt; sm.new2old()</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.values)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.new)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sm.old)</span>
<span class="sd">    2.0, 3.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">StateSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the state sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">StateSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |StateSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess_new</span><span class="p">:</span> <span class="n">FastAccessOutputSequence</span>
    <span class="n">fastaccess_old</span><span class="p">:</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The prefered way to pass values to |Sequence_| instances within initial</span>
<span class="sd">        condition files.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new2old</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">modeltools</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finalise_connections</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUMERIC</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">ELSModel</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">fastaccess_old</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">fastaccess_new</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A tuple containing the actual lengths of all dimensions.</span>

<span class="sd">        |StateSequence| objects come with some additional `fastaccess` attributes,</span>
<span class="sd">        which should only be of interest to framework developers.  One such attribute</span>
<span class="sd">        is the `results` array, handling the (intermediate or final) calculation</span>
<span class="sd">        results for state sequence, as shown in the following example for the</span>
<span class="sd">        0-dimensional sequence |wland_states.HS| of the |wland_wag| model:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import prepare_model, print_vector, pub</span>
<span class="sd">        &gt;&gt;&gt; model = prepare_model(&quot;wland_wag&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print_vector(model.sequences.states.hs.fastaccess._hs_results)</span>
<span class="sd">        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0</span>

<span class="sd">        For 1-dimensional numerical state sequences, the `results` attribute is |None|</span>
<span class="sd">        initially, as property |ModelSequence.numericshape| is unknown.  Setting the</span>
<span class="sd">        |StateSequence.shape| attribute of the respective |StateSequence| object (we</span>
<span class="sd">        select |wland_states.IC| as an example) prepares all  &quot;fastaccess attributes&quot;</span>
<span class="sd">        automatically:</span>

<span class="sd">        &gt;&gt;&gt; ic = model.sequences.states.ic</span>
<span class="sd">        &gt;&gt;&gt; ic.fastaccess._ic_results</span>

<span class="sd">        &gt;&gt;&gt; ic.shape = (2,)</span>
<span class="sd">        &gt;&gt;&gt; ic.shape</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; ic.fastaccess._ic_results.shape</span>
<span class="sd">        (11, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">modeltools</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUMERIC</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">seqs</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">ELSModel</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                    <span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span>
                    <span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numericshape</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_shape</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;State(s) after calling a |Model| calculation method. (Alias for property</span>
<span class="sd">        |Variable.value|).</span>

<span class="sd">        Property |StateSequence.new| handles, in contrast to property</span>
<span class="sd">        |StateSequence.old|, the newly calculated state values during each simulation</span>
<span class="sd">        step.  It supports testing and debugging of individual |Model| methods but is</span>
<span class="sd">        typically irrelevant when scripting *HydPy* workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@new</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">old</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;State(s) before calling a |Model| calculation method.</span>

<span class="sd">        Note the similarity to property |StateSequence.new|. However, property</span>
<span class="sd">        |StateSequence.old| references the initial states of the respective simulation</span>
<span class="sd">        step, which should not be changed by |Model| calculation methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_getvalue</span><span class="p">(</span>
            <span class="kc">True</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@old</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_setvalue</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to set the old value(s) of state sequence &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="StateSequence.new2old">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.StateSequence.new2old">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">new2old</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign the |StateSequence.new| state values to the |StateSequence.old|</span>
<span class="sd">        values.</span>

<span class="sd">        See the main documentation on class |StateSequence| for further information.</span>

<span class="sd">        Note that method |StateSequence.new2old| is replaced by a model-specific,</span>
<span class="sd">        cythonized method when working in Cython mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">old</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span></div>
</div>



<div class="viewcode-block" id="LogSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LogSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogSequence</span><span class="p">(</span><span class="n">ConditionSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for logging values required for later calculations.</span>

<span class="sd">    Class |LogSequence| serves similar purposes as |StateSequence|  but is less strict</span>
<span class="sd">    in its assumptions.  While |StateSequence| objects always handle two states (the</span>
<span class="sd">    |StateSequence.old| and the |StateSequence.new| one), |LogSequence| objects are</span>
<span class="sd">    supposed to remember an arbitrary or sequence-specific number of values, which can</span>
<span class="sd">    be state values but, for example, also flux values.  A typical use case is to store</span>
<span class="sd">    &quot;old&quot; values of effective precipitation to calculate &quot;new&quot; values of direct</span>
<span class="sd">    discharge using the unit hydrograph concept in later simulation steps.</span>

<span class="sd">    It is up to the model developer to ensure that a |LogSequence| subclass has the</span>
<span class="sd">    correct dimensionality and shape to store the required information.  By convention,</span>
<span class="sd">    the &quot;memory&quot; of each |LogSequence| should be placed on the first axis for</span>
<span class="sd">    non-scalar properties.</span>

<span class="sd">    As |StateSequence| objects, |LogSequence| objects store relevant information to</span>
<span class="sd">    start a new simulation run where another one has ended and are thus written into</span>
<span class="sd">    and read from condition files.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">LogSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the log sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">LogSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |LogSequence.subvars|.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span></div>



<div class="viewcode-block" id="LogSequenceFixed">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LogSequenceFixed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogSequenceFixed</span><span class="p">(</span><span class="n">LogSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for log sequences with a fixed shape.&quot;&quot;&quot;</span>

    <span class="n">NDIM</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">SHAPE</span><span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SHAPE</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sequences derived from |LogSequenceFixed| initialise themselves with a</span>
<span class="sd">        predefined shape.</span>

<span class="sd">        We take parameter |dam_logs.LoggedRequiredRemoteRelease| of base model |dam| as</span>
<span class="sd">        an example:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.models.dam import *</span>
<span class="sd">        &gt;&gt;&gt; parameterstep()</span>
<span class="sd">        &gt;&gt;&gt; logs.loggedrequiredremoterelease.shape</span>
<span class="sd">        (1,)</span>

<span class="sd">        Property |LogSequenceFixed.shape| results in the following exception when you</span>
<span class="sd">        try to set a new shape:</span>

<span class="sd">        &gt;&gt;&gt; logs.loggedrequiredremoterelease.shape = 2</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The shape of sequence `loggedrequiredremoterelease` cannot be \</span>
<span class="sd">changed, but this was attempted for element `?`.</span>

<span class="sd">        See the documentation on property |Variable.shape| of class |Variable| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">attrready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of sequence `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` cannot be changed, but this was &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attempted for element `</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">devicename</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_shape</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="AideSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.AideSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AideSequence</span><span class="p">(</span><span class="n">ModelSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for aide sequences of |Model| objects.</span>

<span class="sd">    Aide sequences store data only relevant for calculating an individual simulation</span>
<span class="sd">    time step but must be shared between different calculation methods of a |Model|</span>
<span class="sd">    object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">AideSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the aide sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">AideSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |AideSequence.subvars|.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">FastAccess</span></div>



<div class="viewcode-block" id="LinkSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LinkSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LinkSequence</span><span class="p">(</span><span class="n">BaseLinkInputSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for link sequences of |Model| objects.</span>

<span class="sd">    |LinkSequence| objects do not only handle values themselves but also point to the</span>
<span class="sd">    values handled by |NodeSequence| objects, using the functionalities provided by the</span>
<span class="sd">    Cython module |pointerutils|.  Multiple |LinkSequence| objects of different</span>
<span class="sd">    application models can query and modify the same |NodeSequence| values, allowing</span>
<span class="sd">    different |Model| objects to share information and interact with each other.</span>

<span class="sd">    A note for developers: |LinkSequence| subclasses must be either 0-dimensional or</span>
<span class="sd">    1-dimensional.</span>

<span class="sd">    We demonstrate the pointer functionalities by using the `HydPy-H-Lahn` example</span>
<span class="sd">    project by invoking function |prepare_full_example_2|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">    We focus on the |musk_classic| application model `stream_lahn_marb_lahn_leun`</span>
<span class="sd">    routing inflow from node `lahn_marb` to node `lahn_leun`:</span>

<span class="sd">    &gt;&gt;&gt; model = hp.elements.stream_lahn_marb_lahn_leun.model</span>

<span class="sd">    The first example shows that the 0-dimensional outlet sequence |musk_outlets.Q|</span>
<span class="sd">    points to the |Sim| sequence of node `lahn_leun`:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.lahn_leun.sequences.sim</span>
<span class="sd">    sim(0.0)</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.discharge</span>
<span class="sd">    discharge(10.0, 10.0)</span>
<span class="sd">    &gt;&gt;&gt; model.update_outlets()</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.lahn_leun.sequences.sim</span>
<span class="sd">    sim(10.0)</span>

<span class="sd">    The second example shows that the 1-dimensional inlet sequence |musk_inlets.Q|</span>
<span class="sd">    points to the |Sim| sequence of node `lahn_marb`:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inlets.q</span>
<span class="sd">    q(nan)</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.lahn_marb.sequences.sim = 1.0</span>
<span class="sd">    &gt;&gt;&gt; model.update_inlets()</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.inlets.q</span>
<span class="sd">    q(1.0)</span>

<span class="sd">    In the example above, the 1-dimensional inlet sequence |musk_inlets.Q| only points</span>
<span class="sd">    to a single |NodeSequence| value.  We now prepare a |exch_branch_hbv96| application</span>
<span class="sd">    model instance to show what happens when connecting a 1-dimensional |LinkSequence|</span>
<span class="sd">    object (|exch_outlets.Branched|) with three |NodeSequence| objects (see the</span>
<span class="sd">    documentation of application model |exch_branch_hbv96| for more details):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Element, Nodes, prepare_model</span>
<span class="sd">    &gt;&gt;&gt; model = prepare_model(&quot;exch_branch_hbv96&quot;)</span>
<span class="sd">    &gt;&gt;&gt; nodes = Nodes(&quot;input1&quot;, &quot;input2&quot;, &quot;output1&quot;, &quot;output2&quot;, &quot;output3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; branch = Element(&quot;branch&quot;,</span>
<span class="sd">    ...                  inlets=[&quot;input1&quot;, &quot;input2&quot;],</span>
<span class="sd">    ...                  outlets=[&quot;output1&quot;, &quot;output2&quot;, &quot;output3&quot;])</span>
<span class="sd">    &gt;&gt;&gt; model.parameters.control.xpoints(0.0, 2.0, 4.0, 6.0)</span>
<span class="sd">    &gt;&gt;&gt; model.parameters.control.ypoints(</span>
<span class="sd">    ...     output1=[0.0, 1.0, 2.0, 3.0],</span>
<span class="sd">    ...     output2=[0.0, 1.0, 0.0, 0.0],</span>
<span class="sd">    ...     output3=[0.0, 0.0, 2.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; branch.model = model</span>

<span class="sd">    Each field of the values of a 1-dimensional |LinkSequence| object points to</span>
<span class="sd">    another |NodeSequence| object:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.outlets.branched = 1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; model.update_outlets()</span>
<span class="sd">    &gt;&gt;&gt; nodes.output1.sequences.sim</span>
<span class="sd">    sim(1.0)</span>
<span class="sd">    &gt;&gt;&gt; nodes.output2.sequences.sim</span>
<span class="sd">    sim(2.0)</span>
<span class="sd">    &gt;&gt;&gt; nodes.output3.sequences.sim</span>
<span class="sd">    sim(3.0)</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">LinkSequences</span><span class="p">[</span><span class="n">LinkSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the link sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">LinkSequences</span><span class="p">[</span><span class="n">LinkSequence</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |LinkSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess</span><span class="p">:</span> <span class="n">FastAccessLinkSequence</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object for accessing the link sequence&#39;s data with little overhead.&quot;&quot;&quot;</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessLinkSequence</span>

    <span class="n">_isready</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="LinkSequence.set_pointer">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.LinkSequence.set_pointer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">double</span><span class="p">:</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a pointer referencing the given |Double| object.</span>

<span class="sd">        For 1-dimensional sequence objects, one also needs to specify the relevant</span>
<span class="sd">        index position of the pointer via argument `idx`.</span>

<span class="sd">        Method |LinkSequence.set_pointer| should be relevant for framework developers</span>
<span class="sd">        and eventually for some model developers only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">set_pointer0d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">double</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">set_pointer1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isready</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finalise_connections</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">PPDouble</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;pointer&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;len_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A tuple containing the actual lengths of all dimensions.</span>

<span class="sd">        Property |LinkSequence.shape| of class |LinkSequence| works similarly to the</span>
<span class="sd">        general |Variable.shape| property of class |Variable|. Still, you need to be</span>
<span class="sd">        extra careful due to the pointer mechanism underlying class |LinkSequence|.</span>
<span class="sd">        Change the shape of a link sequence for good reasons only.  Please read the</span>
<span class="sd">        main documentation on class |LinkSequence| first and then see the following</span>
<span class="sd">        examples, which are, again, based on the `HydPy-H-Lahn` example project and</span>
<span class="sd">        application model |musk_classic|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; element = hp.elements.stream_lahn_marb_lahn_leun</span>
<span class="sd">        &gt;&gt;&gt; model = element.model</span>

<span class="sd">        The default mechanisms of *HydPy* prepare both 0-dimensional and 1-dimensional</span>
<span class="sd">        link sequences with a proper shape (which, for inlet sequence |musk_inlets.Q|,</span>
<span class="sd">        depends on the number of connected |Node| objects):</span>

<span class="sd">        &gt;&gt;&gt; model.sequences.outlets.q.shape</span>
<span class="sd">        ()</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inlets.q.shape</span>
<span class="sd">        (1,)</span>

<span class="sd">        You can use the property |LinkSequence.pointervalue| to investigate whether the</span>
<span class="sd">        link to node sequence connections are as you expect it:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; element.inlets.lahn_marb.sequences.sim = 1.0</span>
<span class="sd">        &gt;&gt;&gt; element.outlets.lahn_leun.sequences.sim = 2.0</span>
<span class="sd">        &gt;&gt;&gt; round_(model.sequences.inlets.q.pointervalue)</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; round_(model.sequences.outlets.q.pointervalue)</span>
<span class="sd">        2.0</span>

<span class="sd">        Attempting to set the only possible shape of 0-dimensional link sequences or</span>
<span class="sd">        any different shape results in the standard behaviour:</span>

<span class="sd">        &gt;&gt;&gt; model.sequences.outlets.q.shape = ()</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.outlets.q.shape = (1,)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: While trying to set the shape of link sequence`q` of element \</span>
<span class="sd">`stream_lahn_marb_lahn_leun`, the following error occurred: The shape information of \</span>
<span class="sd">0-dimensional variables as `q` of element `stream_lahn_marb_lahn_leun` can only \</span>
<span class="sd">be `()`, but `(1,)` is given.</span>

<span class="sd">        Changing the shape of 1-dimensional link sequences is supported but destroys</span>
<span class="sd">        the connection to the |NodeSequence| values of the respective nodes.</span>
<span class="sd">        Therefore, the following exception prevents segmentation faults until proper</span>
<span class="sd">        connections are available:</span>

<span class="sd">        &gt;&gt;&gt; model.sequences.inlets.q.shape = (1,)</span>
<span class="sd">        &gt;&gt;&gt; model.update_inlets()</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inlets.q.shape</span>
<span class="sd">        (1,)</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inlets.q.shape = 2</span>
<span class="sd">        &gt;&gt;&gt; model.sequences.inlets.q.pointervalue</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The pointer of the actual `PPDouble` instance at index `0` \</span>
<span class="sd">requested, but not prepared yet via `set_pointer`.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">old_shape</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">getattr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">old_shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NDIM</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">dealloc_pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">alloc_pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="s2">&quot;len_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to set the shape of link sequence&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_shape</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pointervalue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">NDArrayFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The actual value(s) referenced by the pointer(s) of the |LinkSequence|</span>
<span class="sd">        object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">get_pointervalue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>



<div class="viewcode-block" id="InletSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.InletSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InletSequence</span><span class="p">(</span><span class="n">LinkSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for inlet link sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">InletSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the inlet sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">InletSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |InletSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="OutletSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.OutletSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OutletSequence</span><span class="p">(</span><span class="n">LinkSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for outlet link sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">OutletSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the outlet sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">OutletSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |OutletSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ObserverSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ObserverSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ObserverSequence</span><span class="p">(</span><span class="n">LinkSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for observer link sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">ObserverSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the observer sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">ObserverSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |ObserverSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ReceiverSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.ReceiverSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReceiverSequence</span><span class="p">(</span><span class="n">LinkSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for receiver link sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">ReceiverSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the receiver sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">ReceiverSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |ReceiverSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="SenderSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.SenderSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SenderSequence</span><span class="p">(</span><span class="n">LinkSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for sender link sequences of |Model| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">SenderSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the sender sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">SenderSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |SenderSequence.subvars|.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="NodeSequence">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeSequence</span><span class="p">(</span><span class="n">IOSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all sequences to be handled by |Node| objects.&quot;&quot;&quot;</span>

    <span class="n">subvars</span><span class="p">:</span> <span class="n">NodeSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The subgroup to which the node sequence belongs.&quot;&quot;&quot;</span>
    <span class="n">subseqs</span><span class="p">:</span> <span class="n">NodeSequences</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for |NodeSequence.subvars|.&quot;&quot;&quot;</span>
    <span class="n">fastaccess</span><span class="p">:</span> <span class="n">FastAccessNodeSequence</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object for accessing the node sequence&#39;s data with little overhead.&quot;&quot;&quot;</span>

    <span class="n">NDIM</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">NUMERIC</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessNodeSequence</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subvars</span><span class="p">:</span> <span class="n">NodeSequences</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">subvars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span> <span class="o">=</span> <span class="n">subvars</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">initinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a |Double| instead of a |float| object as the first tuple entry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">usedefaultvalues</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |NodeSequence| object, including the |Node.variable| to</span>
<span class="sd">        be represented.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">        &gt;&gt;&gt; Node(&quot;test_node_1&quot;, &quot;T&quot;).sequences.sim.descr_sequence</span>
<span class="sd">        &#39;sim_t&#39;</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import FusedVariable</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.aliases import hland_inputs_T, lland_inputs_TemL</span>
<span class="sd">        &gt;&gt;&gt; Temp = FusedVariable(&quot;Temp&quot;, hland_inputs_T, lland_inputs_TemL)</span>
<span class="sd">        &gt;&gt;&gt; Node(&quot;test_node_2&quot;, Temp).sequences.sim.descr_sequence</span>
<span class="sd">        &#39;sim_temp&#39;</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">descr_device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Description of the |Node| object the |NodeSequence| object belongs to.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">        &gt;&gt;&gt; Node(&quot;test_node_2&quot;).sequences.sim.descr_device</span>
<span class="sd">        &#39;test_node_2&#39;</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseqs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalise_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finalise_connections</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pointerutils</span><span class="o">.</span><span class="n">Double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="s2">&quot;_reset_obsdata&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The actual sequence value.</span>

<span class="sd">        For framework users, the property |NodeSequence.value| of class |NodeSequence|</span>
<span class="sd">        works as usual (explained in the documentation on property |Variable.shape| of</span>
<span class="sd">        class |Variable|).  However, framework developers should note that</span>
<span class="sd">        |NodeSequence| objects use |Double| objects for storing their values and making</span>
<span class="sd">        them accessible to |PDouble| and |PPDouble| objects as explained in detail in</span>
<span class="sd">        the documentation on class |LinkSequence|.  This mechanism is hidden for</span>
<span class="sd">        framework users via conversions to type |float| for safety reasons:</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">        &gt;&gt;&gt; sim = Node(&quot;node&quot;).sequences.sim</span>
<span class="sd">        &gt;&gt;&gt; sim(1.0)</span>
<span class="sd">        &gt;&gt;&gt; sim</span>
<span class="sd">        sim(1.0)</span>
<span class="sd">        &gt;&gt;&gt; sim.value</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; sim.fastaccess.sim</span>
<span class="sd">        Double(1.0)</span>

<span class="sd">        &gt;&gt;&gt; sim.value = 2.0</span>
<span class="sd">        &gt;&gt;&gt; sim</span>
<span class="sd">        sim(2.0)</span>

<span class="sd">        Node sequences return errors like the following if they receive misspecified</span>
<span class="sd">        values or are ill-configured:</span>

<span class="sd">        &gt;&gt;&gt; sim.value = 1.0, 2.0  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: While trying to assign the value `(1.0, 2.0)` to sequence `sim` of \</span>
<span class="sd">node `node`, the following error occurred: float() argument must be a string or a... \</span>
<span class="sd">number, not &#39;tuple&#39;</span>

<span class="sd">        &gt;&gt;&gt; sim.name = None</span>
<span class="sd">        &gt;&gt;&gt; sim.value  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: While trying to query the value of sequence `None` of node `node`, \</span>
<span class="sd">the following error occurred: ...attribute name must be string...</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to query the value of sequence &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">nodephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to assign the value `</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">` to sequence &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">nodephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_value</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seriescomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True/False flag indicating whether simulated or observed data is fully</span>
<span class="sd">        available or not.</span>

<span class="sd">        We use the observation series of node `dill_assl` of the `HydPy-H-Lahn` project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; obs = hp.nodes.dill_assl.sequences.obs</span>

<span class="sd">        When the sequence does not handle any time series data,</span>
<span class="sd">        |NodeSequence.seriescomplete| is |False|:</span>

<span class="sd">        &gt;&gt;&gt; obs.prepare_series(allocate_ram=False)</span>
<span class="sd">        &gt;&gt;&gt; obs.series</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Sequence `obs` of node \</span>
<span class="sd">`dill_assl` is not requested to make any time series data available.</span>
<span class="sd">        &gt;&gt;&gt; obs.seriescomplete</span>
<span class="sd">        False</span>

<span class="sd">        As long as any time series data is missing, |NodeSequence.seriescomplete| is</span>
<span class="sd">        still |False|:</span>

<span class="sd">        &gt;&gt;&gt; obs.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; obs.series[:-1] = 1.0</span>
<span class="sd">        &gt;&gt;&gt; obs.series</span>
<span class="sd">        InfoArray([ 1.,  1.,  1., nan])</span>
<span class="sd">        &gt;&gt;&gt; obs.seriescomplete</span>
<span class="sd">        False</span>

<span class="sd">        Only with all data being not |numpy.nan|, |NodeSequence.seriescomplete| is</span>
<span class="sd">        |True|:</span>

<span class="sd">        &gt;&gt;&gt; obs.series[-1] = 1.0</span>
<span class="sd">        &gt;&gt;&gt; obs.seriescomplete</span>
<span class="sd">        True</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memoryflag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">))</span></div>



<div class="viewcode-block" id="Sim">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sim">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sim</span><span class="p">(</span><span class="n">NodeSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for handling those values of |Node| objects that are &quot;simulated&quot;, meaning</span>
<span class="sd">    calculated by hydrological models.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Sim.load_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Sim.load_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read time series data like method |IOSequence.load_series| of class</span>
<span class="sd">        |IOSequence| but with special handling of missing data.</span>

<span class="sd">        The method&#39;s &quot;special handling&quot; is to convert errors to warnings.  We explain</span>
<span class="sd">        the reasons in the documentation on method |Obs.load_series| of class |Obs|,</span>
<span class="sd">        from which we borrow the following examples.  The only differences are that</span>
<span class="sd">        method |Sim.load_series| of class |Sim| does not disable property</span>
<span class="sd">        |IOSequence.memoryflag| and uses the option |Options.warnmissingsimfile|</span>
<span class="sd">        instead of |Options.warnmissingobsfile|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; hp = HydPy(&quot;HydPy-H-Lahn&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-06&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        ...     hp.prepare_simseries()</span>
<span class="sd">        &gt;&gt;&gt; sim = hp.nodes.dill_assl.sequences.sim</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     sim.load_series()  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: While trying to load the time series data of sequence `sim` of \</span>
<span class="sd">node `dill_assl`, the following error occurred: [Errno 2] No such file or directory: \</span>
<span class="sd">&#39;...dill_assl_sim_q.asc&#39;</span>
<span class="sd">        &gt;&gt;&gt; sim.series</span>
<span class="sd">        InfoArray([nan, nan, nan, nan, nan])</span>

<span class="sd">        &gt;&gt;&gt; sim.series = 1.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     sim.save_series()</span>
<span class="sd">        &gt;&gt;&gt; sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     sim.load_series()</span>
<span class="sd">        &gt;&gt;&gt; sim.series</span>
<span class="sd">        InfoArray([1., 1., 1., 1., 1.])</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; sim.series[2] = numpy.nan</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.overwrite(True):</span>
<span class="sd">        ...     sim.save_series()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     sim.load_series()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: While trying to load the time series data of sequence `sim` of \</span>
<span class="sd">node `dill_assl`, the following error occurred: The series array of sequence `sim` of \</span>
<span class="sd">node `dill_assl` contains 1 nan value.</span>
<span class="sd">        &gt;&gt;&gt; sim.series</span>
<span class="sd">        InfoArray([ 1.,  1., nan,  1.,  1.])</span>

<span class="sd">        &gt;&gt;&gt; sim.prepare_series(allocate_ram=False)</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.filetype(&quot;nc&quot;):</span>
<span class="sd">        ...     pub.sequencemanager.currentdir = &quot;new_series&quot;</span>
<span class="sd">        ...     hp.save_simseries()</span>
<span class="sd">        &gt;&gt;&gt; hp.prepare_simseries()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.filetype(&quot;nc&quot;):</span>
<span class="sd">        ...     hp.load_simseries()  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: While trying to read data from NetCDF file `...sim_q.nc`, the \</span>
<span class="sd">following error occurred: No data for (sub)device `dill_assl` is available in NetCDF \</span>
<span class="sd">file `...sim_q.nc`.</span>

<span class="sd">        &gt;&gt;&gt; sim.series = 2.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.options.warnmissingsimfile(False):</span>
<span class="sd">        ...         sim.load_series()</span>
<span class="sd">        &gt;&gt;&gt; sim.series</span>
<span class="sd">        InfoArray([2., 2., 2., 2., 2.])</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_series</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__handle_missing_series_error__</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__handle_missing_series_error__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warnmissingsimfile</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span></div>



<div class="viewcode-block" id="Obs">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Obs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Obs</span><span class="p">(</span><span class="n">NodeSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for handling those values of |Node| objects that are observed, meaning</span>
<span class="sd">    read from data files.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Obs.load_series">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.Obs.load_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read time series data like method |IOSequence.load_series| of class</span>
<span class="sd">        |IOSequence| but with special handling of missing data.</span>

<span class="sd">        When reading incomplete time series data, *HydPy* usually raises a</span>
<span class="sd">        |RuntimeError| to prevent from performing erroneous calculations.  This</span>
<span class="sd">        functionality makes sense for meteorological input data that is a strict</span>
<span class="sd">        requirement for hydrological simulations.  However, the same often does not</span>
<span class="sd">        hold for the time series of |Obs| sequences, e.g. representing measured</span>
<span class="sd">        discharge. Measured discharge is often an optional input or only used for</span>
<span class="sd">        comparison purposes.</span>

<span class="sd">        According to this reasoning, *HydPy* raises (at most) a |UserWarning| in case</span>
<span class="sd">        of missing or incomplete external time series data of |Obs| sequences.  The</span>
<span class="sd">        following examples show this based on the `HydPy-H-Lahn` project, mainly</span>
<span class="sd">        focussing on the |Obs| sequence of node `dill_assl`, which is ready for</span>
<span class="sd">        handling time series data at the end of the following steps:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; hp = HydPy(&quot;HydPy-H-Lahn&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-06&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        ...     hp.prepare_obsseries()</span>
<span class="sd">        &gt;&gt;&gt; obs = hp.nodes.dill_assl.sequences.obs</span>
<span class="sd">        &gt;&gt;&gt; obs.ramflag</span>
<span class="sd">        True</span>

<span class="sd">        Trying to read non-existing data raises the following warning and disables the</span>
<span class="sd">        sequence&#39;s ability to handle time series data:</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     os.remove(hp.nodes.dill_assl.sequences.obs.filepath)</span>
<span class="sd">        ...     hp.load_obsseries()  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: The `memory flag` of sequence `obs` of node `dill_assl` had to \</span>
<span class="sd">be set to `False` due to the following problem: While trying to load the time series \</span>
<span class="sd">data of sequence `obs` of node `dill_assl`, the following error occurred: [Errno 2] \</span>
<span class="sd">No such file or directory: &#39;...dill_assl_obs_q.asc&#39;</span>

<span class="sd">        &gt;&gt;&gt; obs.ramflag</span>
<span class="sd">        False</span>

<span class="sd">        After writing a complete data file, everything works fine:</span>

<span class="sd">        &gt;&gt;&gt; obs.prepare_series()</span>
<span class="sd">        &gt;&gt;&gt; obs.series = 1.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     obs.save_series()</span>
<span class="sd">        &gt;&gt;&gt; obs.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     obs.load_series()</span>
<span class="sd">        &gt;&gt;&gt; obs.series</span>
<span class="sd">        InfoArray([1., 1., 1., 1., 1.])</span>

<span class="sd">        Reading incomplete data also results in a warning message, but does not disable</span>
<span class="sd">        the |IOSequence.memoryflag|:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; obs.series[2] = numpy.nan</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.overwrite(True):</span>
<span class="sd">        ...     obs.save_series()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     obs.load_series()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: While trying to load the time series data of sequence `obs` of \</span>
<span class="sd">node `dill_assl`, the following error occurred: The series array of sequence `obs` of \</span>
<span class="sd">node `dill_assl` contains 1 nan value.</span>
<span class="sd">        &gt;&gt;&gt; obs.memoryflag</span>
<span class="sd">        True</span>

<span class="sd">        Option |Options.warnmissingobsfile| allows disabling the warning messages</span>
<span class="sd">        without altering the functionalities described above:</span>

<span class="sd">        &gt;&gt;&gt; hp.prepare_obsseries()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     os.remove(hp.nodes.lahn_marb.sequences.obs.filepath)</span>
<span class="sd">        ...     with pub.options.warnmissingobsfile(False):</span>
<span class="sd">        ...         hp.load_obsseries()</span>
<span class="sd">        &gt;&gt;&gt; obs.series</span>
<span class="sd">        InfoArray([ 1.,  1., nan,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_marb.sequences.obs.memoryflag</span>
<span class="sd">        False</span>

<span class="sd">        The same logic holds when trying to load observed time series from NetCDF files</span>
<span class="sd">        that are missing entirely:</span>

<span class="sd">        &gt;&gt;&gt; obs.series = 1.0</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.filetype(&quot;nc&quot;):</span>
<span class="sd">        ...     pub.sequencemanager.currentdir = &quot;new_series&quot;</span>
<span class="sd">        ...     hp.save_obsseries()</span>
<span class="sd">        &gt;&gt;&gt; hp.prepare_obsseries()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO(), pub.sequencemanager.filetype(&quot;nc&quot;):</span>
<span class="sd">        ...     hp.load_obsseries()  # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: While trying to read data from NetCDF file `...obs_q.nc`, the \</span>
<span class="sd">following error occurred: The `memory flag` of sequence `obs` of node `lahn_marb` had \</span>
<span class="sd">to be set to `False` due to the following problem: No data for (sub)device \</span>
<span class="sd">`lahn_marb` is available in NetCDF file `...obs_q.nc`.</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_marb.sequences.obs.memoryflag</span>
<span class="sd">        False</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import Node, Element</span>
<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">            &gt;&gt;&gt; Element.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_series</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__handle_missing_series_error__</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__hydpy__handle_missing_series_error__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;ramflag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__hydpy__set_fastaccessattribute__</span><span class="p">(</span><span class="s2">&quot;diskflag_reading&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warnmissingobsfile</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The `memory flag` of sequence </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">nodephrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;had to be set to `False` due to the following problem: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">exc_value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warnmissingobsfile</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc_value</span><span class="p">))</span></div>



<div class="viewcode-block" id="NodeSequences">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeSequences</span><span class="p">(</span>
    <span class="n">IOSequences</span><span class="p">[</span><span class="s2">&quot;devicetools.Node&quot;</span><span class="p">,</span> <span class="n">NodeSequence</span><span class="p">,</span> <span class="n">FastAccessNodeSequence</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for handling |Sim| and |Obs| sequence objects.</span>

<span class="sd">    Basically, |NodeSequences| works like the different |ModelSequences|  subclasses</span>
<span class="sd">    used for handling |ModelSequence| objects.  The main difference is that they do not</span>
<span class="sd">    reference a |Sequences| object (which is only handled by |Element| objects but not</span>
<span class="sd">    by |Node| objects).  Instead, they directly reference their master |Node| object</span>
<span class="sd">    via the attribute |NodeSequences.node|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Node</span>
<span class="sd">    &gt;&gt;&gt; node = Node(&quot;node&quot;)</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.node</span>
<span class="sd">    Node(&quot;node&quot;, variable=&quot;Q&quot;)</span>

<span class="sd">    The implemented methods just call the same method of the underlying `fastaccess`</span>
<span class="sd">    attribute, which is an instance of (a Cython extension class of) the Python class</span>
<span class="sd">    |sequencetools.FastAccessNodeSequence|.</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CLASSES</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sim</span><span class="p">,</span> <span class="n">Obs</span><span class="p">)</span>

    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">Sim</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">Obs</span>
    <span class="n">_cymodel</span><span class="p">:</span> <span class="n">CyModelProtocol</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_CLS_FASTACCESS_PYTHON</span> <span class="o">=</span> <span class="n">FastAccessNodeSequence</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">master</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">cls_fastaccess</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">FastAccessNodeSequence</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cymodel</span><span class="p">:</span> <span class="n">CyModelProtocol</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">master</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_fastaccess</span> <span class="o">=</span> <span class="n">cls_fastaccess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cymodel</span> <span class="o">=</span> <span class="n">cymodel</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_fastaccess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">usecython</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="n">sequenceutils</span><span class="o">.</span><span class="n">FastAccessNodeSequence</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CLS_FASTACCESS_PYTHON</span><span class="p">()</span>

<div class="viewcode-block" id="NodeSequences.load_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |sequencetools.FastAccessNodeSequence.load_data| of the current</span>
<span class="sd">        `fastaccess` attribute.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     node = Node(&quot;node&quot;)</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; method = &quot;hydpy.core.sequencetools.FastAccessNodeSequence.load_data&quot;</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch(method) as mocked:</span>
<span class="sd">        ...     node.sequences.load_data(5)</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call(5)]</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeSequences.load_simdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences.load_simdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_simdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |sequencetools.FastAccessNodeSequence.load_simdata| of the</span>
<span class="sd">        current `fastaccess` attribute.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     node = Node(&quot;node&quot;)</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; method = &quot;hydpy.core.sequencetools.FastAccessNodeSequence.load_simdata&quot;</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch(method) as mocked:</span>
<span class="sd">        ...     node.sequences.load_simdata(5)</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call(5)]</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_simdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeSequences.load_obsdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences.load_obsdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_obsdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |sequencetools.FastAccessNodeSequence.load_obsdata| of the</span>
<span class="sd">        current `fastaccess` attribute.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     node = Node(&quot;node&quot;)</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; method = &quot;hydpy.core.sequencetools.FastAccessNodeSequence.load_obsdata&quot;</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch(method) as mocked:</span>
<span class="sd">        ...     node.sequences.load_obsdata(5)</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call(5)]</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_obsdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeSequences.save_data">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences.save_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |sequencetools.FastAccessNodeSequence.save_data| of the current</span>
<span class="sd">        `fastaccess` attribute.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     node = Node(&quot;node&quot;)</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; method = &quot;hydpy.core.sequencetools.FastAccessNodeSequence.save_data&quot;</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch(method) as mocked:</span>
<span class="sd">        ...     node.sequences.save_data(5)</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call(5)]</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeSequences.save_simdata">
<a class="viewcode-back" href="../../../sequencetools.html#hydpy.core.sequencetools.NodeSequences.save_simdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_simdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call method |sequencetools.FastAccessNodeSequence.save_simdata|  of the</span>
<span class="sd">        current `fastaccess` attribute.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Node, pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     node = Node(&#39;node&#39;)</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; method = &quot;hydpy.core.sequencetools.FastAccessNodeSequence.save_simdata&quot;</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch(method) as mocked:</span>
<span class="sd">        ...     node.sequences.save_simdata(5)</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call(5)]</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; Node.clear_all()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_simdata</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.sequencetools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2026, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>