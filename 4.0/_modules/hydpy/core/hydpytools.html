
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.core.hydpytools &#8212; HydPy 4.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.hydpytools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.core.hydpytools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module implements the main features for managing *HydPy* projects.&quot;&quot;&quot;</span>
<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span> <span class="nn">networkx</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">import</span> <span class="nn">hydpy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">devicetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">filetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">modeltools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">printtools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">propertytools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">selectiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">sequencetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">timetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core.typingtools</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">auxfiletools</span>


<span class="n">ConditionsType</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span>
    <span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Vector</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Matrix</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]]</span>
<span class="p">]</span>


<div class="viewcode-block" id="HydPy"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy">[docs]</a><span class="k">class</span> <span class="nc">HydPy</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The main class for managing *HydPy* projects.</span>

<span class="sd">    In typical *HydPy* projects, one prepares a single instance of class</span>
<span class="sd">    |HydPy|.  This instance, which we name &quot;hp&quot; throughout this</span>
<span class="sd">    documentation instead of &quot;hydpy&quot; to avoid a naming collision with</span>
<span class="sd">    the `hydpy` site-package, provides many convenience methods to perform</span>
<span class="sd">    task like reading time-series data or starting simulation runs.</span>
<span class="sd">    Additionally, it serves as a root to access most of the details of</span>
<span class="sd">    a *HydPy* project, allowing for more granular control over the</span>
<span class="sd">    framework features.</span>

<span class="sd">    We elaborate these short explanations by using the `LahnH` example</span>
<span class="sd">    project.  Calling function |prepare_full_example_1| copies the</span>
<span class="sd">    complete example project `LahnH` into the `iotesting` directory of</span>
<span class="sd">    the *HydPy* site-package (alternatively, you can copy the `LahnH`</span>
<span class="sd">    example project, which can be found in subpackage `data`,  into a</span>
<span class="sd">    working directory of your choice):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">    &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">    At first, the |HydPy| instance needs to know the name of the relevant</span>
<span class="sd">    project, which is identical with the name of the project&#39;s root</span>
<span class="sd">    directory.  Pass `LahnH` to the constructor of class |HydPy|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">    &gt;&gt;&gt; hp = HydPy(&quot;LahnH&quot;)</span>

<span class="sd">    So far, our |HydPy| instance does not know any project configurations</span>
<span class="sd">    except its name.  Most of this information would be available via</span>
<span class="sd">    properties |HydPy.nodes| and |HydPy.elements|, but if we try to</span>
<span class="sd">    access them, we get the following error responses:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The actual HydPy instance does not handle any nodes \</span>
<span class="sd">at the moment.</span>

<span class="sd">    &gt;&gt;&gt; hp.elements</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The actual HydPy instance does not handle any elements \</span>
<span class="sd">at the moment.</span>

<span class="sd">    One now could continue rather quickly by calling method</span>
<span class="sd">    |HydPy.prepare_everything|, which would make our |HydPy| instance</span>
<span class="sd">    ready for its first simulation run in one go.  However, we prefer</span>
<span class="sd">    to continue step by step by calling the more specific preparation</span>
<span class="sd">    methods, which offers more flexibility.</span>

<span class="sd">    First, the |HydPy| instance needs to know the relevant |Node| and</span>
<span class="sd">    |Element| objects.  Method |HydPy.prepare_network| reads this</span>
<span class="sd">    information from so-called &quot;network files&quot;.  The |Node| and |Element|</span>
<span class="sd">    objects connect automatically and thereby define the topology or</span>
<span class="sd">    the network structure of the project (see the documentation on class</span>
<span class="sd">    |NetworkManager| and module |devicetools| for more detailed  explanations):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import TestIO</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_network()</span>

<span class="sd">    (Using the &quot;with&quot; statement in combination with class |TestIO|</span>
<span class="sd">    makes sure we are reading the network files from a subdirectory</span>
<span class="sd">    of the `iotesting` directory.  Here and in the following, you</span>
<span class="sd">    must omit such &quot;with blocks&quot; in case you copied the `LahnH` example</span>
<span class="sd">    project into your current working directory.)</span>

<span class="sd">    Now, our |HydPy| instance offers access to all |Node| objects</span>
<span class="sd">    defined within the `LahnH` example project, which are grouped</span>
<span class="sd">    by a |Nodes| object:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes</span>
<span class="sd">    Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">    Taking the node `dill` as an example, we can dive into the details</span>
<span class="sd">    and, for example, search for those elements which node `dill` is</span>
<span class="sd">    connected to (it receives water from element `land_dill` and passes</span>
<span class="sd">    it to element `stream_dill_lahn_2`), or inspect its simulated</span>
<span class="sd">    discharge value handled by a |Sim| sequence object (so far, zero):</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.entries</span>
<span class="sd">    Elements(&quot;land_dill&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">    Elements(&quot;stream_dill_lahn_2&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(0.0)</span>

<span class="sd">    All |Node| objects are ready to be used.  The same is only partly</span>
<span class="sd">    true for the |Element| objects, which are also accessible (via a</span>
<span class="sd">    |Elements| instance) and properly connected to the |Node| objects</span>
<span class="sd">    but do not handle workable |Model| objects, which is required to</span>
<span class="sd">    perform any simulation run:</span>

<span class="sd">    &gt;&gt;&gt; hp.elements</span>
<span class="sd">    Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">             &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">             &quot;stream_lahn_2_lahn_3&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.elements.stream_dill_lahn_2</span>
<span class="sd">    Element(&quot;stream_dill_lahn_2&quot;,</span>
<span class="sd">            inlets=&quot;dill&quot;,</span>
<span class="sd">            outlets=&quot;lahn_2&quot;,</span>
<span class="sd">            keywords=&quot;river&quot;)</span>

<span class="sd">    &gt;&gt;&gt; hp.elements.land_dill.model</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: The model object of \</span>
<span class="sd">element `land_dill` has been requested but not been prepared so far.</span>

<span class="sd">    Hence, we need to call method |HydPy.prepare_models|, which</span>
<span class="sd">    instructs all |Element| objects to read the relevant parameter</span>
<span class="sd">    control files and prepare their |Model| objects.  Note that</span>
<span class="sd">    the individual |Element| object does not know the relevant model</span>
<span class="sd">    type beforehand; both the information on the model type and</span>
<span class="sd">    the parameter settings is encoded in individual control files,</span>
<span class="sd">    making it easy to exchange individual models later (the</span>
<span class="sd">    documentation on method |Elements.prepare_models| of class</span>
<span class="sd">    |Elements| is a good starting point for a deeper understanding</span>
<span class="sd">    on configuring *HydPy* projects via control files):</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_models()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    hydpy.core.exceptiontools.AttributeNotReady: While trying to initialise \</span>
<span class="sd">the model object of element `land_dill`, the following error occurred: \</span>
<span class="sd">The initialisation period has not been defined via attribute `timegrids` \</span>
<span class="sd">of module `pub` yet but might be required to prepare the model properly.</span>

<span class="sd">    Oops, something went wrong.  We forgot to define the simulation</span>
<span class="sd">    period, which might be relevant for some time-dependent</span>
<span class="sd">    configurations.  We discuss some examples of such configurations</span>
<span class="sd">    below but now use this little accident to discuss the typical pattern</span>
<span class="sd">    of *HydPy* error messages.  First, we usually try to add some</span>
<span class="sd">    additional &quot;spatial&quot; information (in this case: the name of the related</span>
<span class="sd">    |Element| object).  Second, we try to explain in which program context</span>
<span class="sd">    an error occurs.  This context is already available in much</span>
<span class="sd">    more detail in the so-called &quot;stack trace&quot; (the middle part of the</span>
<span class="sd">    printed error response we do not show).  Stack trace descriptions</span>
<span class="sd">    are great for programmers but hard to read for others, which</span>
<span class="sd">    is why we often add &quot;While trying to...&quot; explanations to our error</span>
<span class="sd">    messages.  In our example, one can see that the error occurred</span>
<span class="sd">    while trying to initialise the |Model| object of element `land_dill`,</span>
<span class="sd">    which is quite evident in our example but could be less evident</span>
<span class="sd">    in more complex *HydPy* applications.</span>

<span class="sd">    The last sentence of the error message tells us that we need</span>
<span class="sd">    to define the attribute `timegrids` of module `pub`.  `pub`</span>
<span class="sd">    stands for &quot;public&quot;, meaning module `pub` handles all (or at</span>
<span class="sd">    least most of) the globally available configuration data.</span>
<span class="sd">    One example is that module `pub` handles a |Timegrids| instance</span>
<span class="sd">    defining both the initialisation and the simulation period,</span>
<span class="sd">    which can be done by the following assignment (see the</span>
<span class="sd">    documentation on class |Timegrid| and on class |Timegrids| for</span>
<span class="sd">    further information):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>

<span class="sd">    Now method |HydPy.prepare_models| does not complain anymore and</span>
<span class="sd">    adds an instance of the |hland_v1| application model to element</span>
<span class="sd">    `land_dill`, to which we set an additional reference to shorten</span>
<span class="sd">    the following examples:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_models()</span>

<span class="sd">    &gt;&gt;&gt; model = hp.elements.land_dill.model</span>
<span class="sd">    &gt;&gt;&gt; model.name</span>
<span class="sd">    &#39;hland_v1&#39;</span>

<span class="sd">    All control parameter values, defined in the corresponding control file,</span>
<span class="sd">    are correctly set.  As an example, we show the values of control parameter</span>
<span class="sd">    |hland_control.IcMax|, which in this case defines different values for</span>
<span class="sd">    hydrological response units of type |hland_constants.FIELD| (1.0 mm) and</span>
<span class="sd">    of type |hland_constants.FOREST| (1.5 mm):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.control.icmax</span>
<span class="sd">    icmax(field=1.0, forest=1.5)</span>

<span class="sd">    The appearance (or &quot;string representation&quot;) of all parameters that have a</span>
<span class="sd">    unit with a time reference (we call these parameters &quot;time-dependent&quot;)</span>
<span class="sd">    like |hland_control.PercMax| depends on the current setting of option</span>
<span class="sd">    |Options.parameterstep|, which is one day by default (see the documentation</span>
<span class="sd">    on class |Parameter| for more information on dealing with time-dependent</span>
<span class="sd">    parameters subclasses):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.control.percmax</span>
<span class="sd">    percmax(1.39636)</span>
<span class="sd">    &gt;&gt;&gt; pub.options.parameterstep(&quot;1h&quot;)</span>
<span class="sd">    Period(&quot;1d&quot;)</span>

<span class="sd">    The values of the derived parameters, which need to be calculated</span>
<span class="sd">    before starting a simulation run based on the control parameters</span>
<span class="sd">    and eventually based on some other settings (e.g. the initialisation</span>
<span class="sd">    period) are also ready.  Here we show the value of the derived</span>
<span class="sd">    parameter  |hland_derived.RelLandArea|, representing the relative</span>
<span class="sd">    area of &quot;land&quot; units (1.0 means there is no &quot;water&quot; unit at all):</span>

<span class="sd">    &gt;&gt;&gt; model.parameters.derived.rellandarea</span>
<span class="sd">    rellandarea(1.0)</span>

<span class="sd">    Note that we define all class names in &quot;CamelCase&quot; letters</span>
<span class="sd">    (which is a Python convention) and, whenever useful, name</span>
<span class="sd">    the related objects identically but in lower case letters.</span>
<span class="sd">    We hope that eases finding the relevant parts of the online</span>
<span class="sd">    documentation when in trouble with a particular object.  Three</span>
<span class="sd">    examples we already encountered are the |Timegrids| instance</span>
<span class="sd">    `timegrids` of module `pub`, the |Nodes| instance `nodes` of</span>
<span class="sd">    class `HydPy`, and the |hland_derived.RelLandArea| instance</span>
<span class="sd">    `rellandarea` of application model |hland_v1|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import classname</span>
<span class="sd">    &gt;&gt;&gt; classname(pub.timegrids)</span>
<span class="sd">    &#39;Timegrids&#39;</span>

<span class="sd">    &gt;&gt;&gt; classname(hp.nodes)</span>
<span class="sd">    &#39;Nodes&#39;</span>

<span class="sd">    &gt;&gt;&gt; classname(model.parameters.derived.rellandarea)</span>
<span class="sd">    &#39;RelLandArea&#39;</span>

<span class="sd">    As shown above, all |Parameter| objects of the model of element</span>
<span class="sd">    `land_dill` are ready to be used. However, all sequences (which</span>
<span class="sd">    handle the time variable properties) contain |numpy| |numpy.nan|</span>
<span class="sd">    values, which we use to indicate missing data.  We show this</span>
<span class="sd">    for the 0-dimensional input temperature sequence |hland_inputs.T|,</span>
<span class="sd">    for the 1-dimensional soil moisture state sequence |hland_states.SM|,</span>
<span class="sd">    and for the 0-dimensional discharge flux sequence |hland_fluxes.QT|:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(nan)</span>

<span class="sd">    There are some other sequence types (see the documentation on</span>
<span class="sd">    module |sequencetools| for more details) but |InputSequence|,</span>
<span class="sd">    |FluxSequence|, and |StateSequence| are the most common ones</span>
<span class="sd">    (besides the |NodeSequence| subtypes  |Obs| and especially |Sim|).</span>

<span class="sd">    |StateSequence| objects describe many aspects of the current state</span>
<span class="sd">    of a model (or, e.g., of a catchment).  Each simulation run requires</span>
<span class="sd">    proper initial states, which we call initial conditions in the</span>
<span class="sd">    following (also covering memory aspects represented by |LogSequence|</span>
<span class="sd">    objects).  We load all necessary initial conditions by calling the</span>
<span class="sd">    method |HydPy.load_conditions| (see the documentation on method</span>
<span class="sd">    |HydPy.load_conditions| for further details):</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_conditions()</span>

<span class="sd">    Now, the states of our model are also ready to be used.  However,</span>
<span class="sd">    one should note that state sequence |hland_states.SM| knows only</span>
<span class="sd">    the current soil moisture states for the twelve hydrological</span>
<span class="sd">    response units of element `land_dill` (more specifically, we</span>
<span class="sd">    loaded the soil moisture values related to the start date of the</span>
<span class="sd">    initialisation period, which is the first of January at zero</span>
<span class="sd">    o&#39;clock).  By default and for reasons of memory storage efficiency,</span>
<span class="sd">    sequences generally handle the currently relevant values only</span>
<span class="sd">    instead of complete time-series:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(nan)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">       222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(nan)</span>

<span class="sd">    For states like |hland_states.SM|, we need to know the values at</span>
<span class="sd">    the beginning of the simulation period only.  All following values</span>
<span class="sd">    are calculated subsequentially during the simulation run.  However,</span>
<span class="sd">    this is different for input sequences like |hland_inputs.T|.</span>
<span class="sd">    Time variable properties like the air temperature are external</span>
<span class="sd">    forcings. Hence they must be available over the whole simulation</span>
<span class="sd">    period apriori.  Such complete time-series can be made available</span>
<span class="sd">    via property |IOSequence.series| of class |IOSequence|, which</span>
<span class="sd">    has not happened for any sequence so far:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: Sequence `t` of element `land_dill` is not \</span>
<span class="sd">requested to make any internal data available.</span>

<span class="sd">    Before loading time-series data, we need to reserve the required</span>
<span class="sd">    memory storage.  We do this for all sequences at ones (not only</span>
<span class="sd">    the |ModelSequence| objects but also the |NodeSequence| objects</span>
<span class="sd">    as the |Sim| instance handled by node `dill`) through calling</span>
<span class="sd">    method |HydPy.prepare_allseries|:</span>

<span class="sd">    &gt;&gt;&gt; hp.prepare_allseries()</span>

<span class="sd">    Now property |IOSequence.series| returns an |InfoArray| object,</span>
<span class="sd">    which is a slight modification of the widely applied |numpy|</span>
<span class="sd">    |numpy.ndarray|.  The first axis (or the only axis) corresponds</span>
<span class="sd">    to the number of days of the initialisation period (a *HydPy*</span>
<span class="sd">    convention).  For the 1-dimensional soil moisture state sequence</span>
<span class="sd">    |hland_states.SM|, the second axis corresponds to the number of</span>
<span class="sd">    hydrological response units (a |hland| convention):</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series</span>
<span class="sd">    InfoArray([ nan,  nan,  nan,  nan])</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm.series</span>
<span class="sd">    InfoArray([[ nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,</span>
<span class="sd">                 nan,  nan],</span>
<span class="sd">               [ nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,</span>
<span class="sd">                 nan,  nan],</span>
<span class="sd">               [ nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,</span>
<span class="sd">                 nan,  nan],</span>
<span class="sd">               [ nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,  nan,</span>
<span class="sd">                 nan,  nan]])</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt.series</span>
<span class="sd">    InfoArray([ nan,  nan,  nan,  nan])</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim.series</span>
<span class="sd">    InfoArray([ nan,  nan,  nan,  nan])</span>

<span class="sd">    So far, each time-series array is empty.  The `LahnH` example</span>
<span class="sd">    project provides time-series files for the input sequences only,</span>
<span class="sd">    which is the minimum requirement for starting a simulation run.</span>
<span class="sd">    We use method |HydPy.load_inputseries| to load this data:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_inputseries()</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    Finally, we can perform the simulation run by calling the method</span>
<span class="sd">    |HydPy.simulate|:</span>

<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>

<span class="sd">    The time-series arrays of all sequences now contain calculated</span>
<span class="sd">    values --- except those of input sequence |hland_inputs.T|, of course</span>
<span class="sd">    (for state sequence |hland_states.SM|, we show the time-series</span>
<span class="sd">    of the first hydrological response unit only):</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    By comparison, you see that the lastly calculated (or read) time</span>
<span class="sd">    series value is the actual one for each |Sequence_| object.  This</span>
<span class="sd">    mechanism allows, for example, to write the final states of soil</span>
<span class="sd">    moisture sequence |hland_states.SM| and use them as initial</span>
<span class="sd">    conditions later, even if its complete time-series were not available:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t</span>
<span class="sd">    t(-5.968849)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">       208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">       235.597338, 234.329294)</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.fluxes.qt</span>
<span class="sd">    qt(6.017787)</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(6.017787)</span>

<span class="sd">    In many applications, the simulated time-series is the result</span>
<span class="sd">    we are interested in.  Hence we close our explanations with some</span>
<span class="sd">    detailed examples on this topic that also cover the potential</span>
<span class="sd">    problem of limited rapid access storage availability.</span>

<span class="sd">    By default, the *HydPy* framework does not overwrite already</span>
<span class="sd">    existing time-series files.  You can change such settings via</span>
<span class="sd">    the |SequenceManager| object available in module |pub| (module</span>
<span class="sd">    |pub| also handles |ControlManager| and |ConditionManager| objects</span>
<span class="sd">    for settings related to reading and writing control files and</span>
<span class="sd">    condition files).  We change the default behaviour by setting</span>
<span class="sd">    the `generaloverwrite` attribute to |True| and write all the time</span>
<span class="sd">    series (not only those of the flux and states sequences but</span>
<span class="sd">    also those of the input sequences) by calling method</span>
<span class="sd">    |HydPy.save_allseries|:</span>

<span class="sd">    &gt;&gt;&gt; pub.sequencemanager.generaloverwrite = True</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.save_allseries()</span>

<span class="sd">    Next, we show how the reading of time-series works.  We first set the</span>
<span class="sd">    time-series values of all considered sequences to zero for this purpose:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.inputs.t.series = 0.0</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim.series = 0.</span>

<span class="sd">    Now we can reload the time-series of all relevant sequences.</span>
<span class="sd">    However, doing so would result in a warning due to incomplete</span>
<span class="sd">    data (for example, of the observation data handled by the</span>
<span class="sd">    |Obs| sequence objects, which is not available in the `LahnH`</span>
<span class="sd">    example project).  To circumvent this problem, we disable</span>
<span class="sd">    the |Options.checkseries| option, which is one of the</span>
<span class="sd">    public options handled by the instance of class |Options|</span>
<span class="sd">    available as another attribute of module |pub|.  We again</span>
<span class="sd">    use a &quot;with block&quot;, making sure the option is changed only</span>
<span class="sd">    temporarily while loading the time-series (this time not by</span>
<span class="sd">    executing method |HydPy.load_allseries| but by the more</span>
<span class="sd">    specific methods |HydPy.load_inputseries|, |HydPy.load_fluxseries|,</span>
<span class="sd">    |HydPy.load_stateseries|, and |HydPy.load_simseries|):</span>

<span class="sd">    &gt;&gt;&gt; with TestIO(), pub.options.checkseries(False):</span>
<span class="sd">    ...     hp.load_inputseries()</span>
<span class="sd">    ...     hp.load_fluxseries()</span>
<span class="sd">    ...     hp.load_stateseries()</span>
<span class="sd">    ...     hp.load_simseries()</span>

<span class="sd">    The read time-series data equals the previously written one:</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    We mentioned the possibility for more granular control of</span>
<span class="sd">    *HydPy* by using the different objects handled by the |HydPy|</span>
<span class="sd">    object instead of using its convenience methods.</span>
<span class="sd">    Here is an elaborate example showing how to (re)load the states</span>
<span class="sd">    of an arbitrary simulation time step, which might be relevant</span>
<span class="sd">    for more complex workflows implementing data assimilation techniques:</span>

<span class="sd">    &gt;&gt;&gt; model.sequences.states.load_data(1)</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">       208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">       236.244147, 234.972621)</span>

<span class="sd">    Using the node sequence |Sim| as an example, we also show the</span>
<span class="sd">    inverse functionality of changing time-series values:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim = 0.0</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.save_data(2)</span>
<span class="sd">    &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 0.0, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.load_data(1)</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(8.901179)</span>

<span class="sd">    In the examples above, we keep all data in rapid access memory,</span>
<span class="sd">    which can be problematic when handling long time-series in huge</span>
<span class="sd">    *HydPy* projects.  When in trouble, first try to prepare only those</span>
<span class="sd">    time-series which are strictly required (very often, it is</span>
<span class="sd">    sufficient to call |HydPy.prepare_inputseries|,</span>
<span class="sd">    |HydPy.load_inputseries|, and |HydPy.prepare_simseries| only).</span>
<span class="sd">    If this does not work in your project, you can choose to handle</span>
<span class="sd">    some time-series on disk instead, which unavoidably increases</span>
<span class="sd">    computation times immensely.  To prepare the necessary space on</span>
<span class="sd">    disk, assign |False| to the `ramflag` argument of method</span>
<span class="sd">    |HydPy.prepare_allseries| or its more specific counterparts:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.prepare_inputseries(ramflag=False)</span>
<span class="sd">    ...     hp.prepare_stateseries(ramflag=False)</span>
<span class="sd">    ...     hp.prepare_fluxseries(ramflag=False)</span>
<span class="sd">    ...     hp.prepare_simseries(ramflag=False)</span>
<span class="sd">    ...     hp.prepare_obsseries(ramflag=False)</span>

<span class="sd">    By doing so, you lose the previously available time-series information:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.inputs.t.series)</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    nan, nan, nan, nan</span>

<span class="sd">    (Re)Loading the initial conditions and the input time-series</span>
<span class="sd">    and (re)performing the simulation run results, as to be expected,</span>
<span class="sd">    in the same simulation results:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.load_conditions()</span>
<span class="sd">    ...     hp.load_inputseries()</span>
<span class="sd">    ...     hp.simulate()</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    Writing and reading from external time-series files also works</span>
<span class="sd">    in combination with handling internal time-series data on disk:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.save_inputseries()</span>
<span class="sd">    ...     hp.save_stateseries()</span>
<span class="sd">    ...     hp.save_fluxseries()</span>
<span class="sd">    ...     hp.save_simseries()</span>
<span class="sd">    ...     hp.save_obsseries()</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     model.sequences.inputs.t.series = 0.0</span>
<span class="sd">    ...     model.sequences.states.sm.series = 0.0</span>
<span class="sd">    ...     model.sequences.fluxes.qt.series = 0.0</span>
<span class="sd">    ...     hp.nodes.dill.sequences.sim.series = 0.0</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     with pub.options.checkseries(False):</span>
<span class="sd">    ...         hp.load_allseries()</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.inputs.t.series)</span>
<span class="sd">    -0.298846, -0.811539, -2.493848, -5.968849</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.states.sm.series[:, 0])</span>
<span class="sd">    184.926173, 184.603966, 184.386666, 184.098541</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(model.sequences.fluxes.qt.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 7.131072, 6.017787</span>

<span class="sd">    Besides computation times, it usually makes no difference whether</span>
<span class="sd">    one handles internal time-series data in RAM or on disk.  However,</span>
<span class="sd">    there are some subtle differences when one dives into the details.</span>
<span class="sd">    Above, we have shown the possibility to (re)load the states of</span>
<span class="sd">    arbitrary simulation time steps when working in RAM.  The same is</span>
<span class="sd">    possible when working on the hard disk, but one has to call</span>
<span class="sd">    |IOSequences.open_files| first to prepare the necessary file</span>
<span class="sd">    object and pass the relevant time step index to this</span>
<span class="sd">    method instead to method |ModelIOSequences.load_data|:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     model.sequences.states.open_files(1)</span>
<span class="sd">    ...     model.sequences.states.load_data(-999)</span>
<span class="sd">    ...     model.sequences.states.close_files()</span>
<span class="sd">    &gt;&gt;&gt; model.sequences.states.sm</span>
<span class="sd">    sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">       208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">       236.244147, 234.972621)</span>

<span class="sd">    For the sake of completeness, we also repeat the |Sim| based example:</span>

<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim = 0.0</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.nodes.dill.sequences.open_files(2)</span>
<span class="sd">    ...     hp.nodes.dill.sequences.save_data(-999)</span>
<span class="sd">    ...     hp.nodes.dill.sequences.close_files()</span>
<span class="sd">    ...     round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">    11.78038, 8.901179, 0.0, 6.017787</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     hp.nodes.dill.sequences.open_files(1)</span>
<span class="sd">    ...     hp.nodes.dill.sequences.load_data(-999)</span>
<span class="sd">    ...     hp.nodes.dill.sequences.close_files()</span>
<span class="sd">    &gt;&gt;&gt; hp.nodes.dill.sequences.sim</span>
<span class="sd">    sim(8.901179)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">]</span>
    <span class="n">_elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">]</span>
    <span class="n">deviceorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Element</span><span class="p">]]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projectname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
                <span class="n">devicetools</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">projectname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">projectname</span> <span class="o">=</span> <span class="n">projectname</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">networkmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">NetworkManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">controlmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">ControlManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">sequencemanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">SequenceManager</span><span class="p">()</span>
            <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">conditionmanager</span> <span class="o">=</span> <span class="n">filetools</span><span class="o">.</span><span class="n">ConditionManager</span><span class="p">()</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span>
        <span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">,</span>
        <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">,</span>
    <span class="p">]()</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">_get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The currently handled |Node| objects.</span>

<span class="sd">        You are allowed to get, set and delete the currently handled nodes:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        &gt;&gt;&gt; del hp.nodes</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The actual HydPy instance does not handle any nodes \</span>
<span class="sd">at the moment.</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes = &quot;dill&quot;, &quot;lahn_1&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;)</span>

<span class="sd">        However, note that doing so might result in erroneous networks</span>
<span class="sd">        and that you, even in case of correctness, must most likely call</span>
<span class="sd">        method |HydPy.update_devices| before performing the next</span>
<span class="sd">        simulation run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The actual HydPy instance does not handle any &quot;</span> <span class="s2">&quot;nodes at the moment.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_set_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">_del_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">elements</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span>
        <span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">,</span>
        <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">,</span>
    <span class="p">]()</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">_get_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The currently handled |Element| objects.</span>

<span class="sd">        You are allowed to get, set and delete the currently handled elements:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                 &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">                 &quot;stream_lahn_2_lahn_3&quot;)</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: The actual HydPy instance does not handle any elements \</span>
<span class="sd">at the moment.</span>

<span class="sd">        &gt;&gt;&gt; hp.elements = &quot;land_dill&quot;, &quot;land_lahn_1&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>

<span class="sd">        However, note that doing so might result in erroneous networks</span>
<span class="sd">        and that you, even in case of correctness, must most likely call</span>
<span class="sd">        method |HydPy.update_devices| before performing the next</span>
<span class="sd">        simulation run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span>
        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The actual HydPy instance does not handle any elements at the moment.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">elements</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_set_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@elements</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">_del_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="HydPy.prepare_everything"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_everything">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_everything</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience method to make the actual |HydPy| instance runnable.</span>

<span class="sd">        Method |HydPy.prepare_everything| is the fastest approach to get a</span>
<span class="sd">        runnable |HydPy| object.  You only need to import class |Hydpy|,</span>
<span class="sd">        initialise it with the project name, define the simulation period</span>
<span class="sd">        via the |Timegrids| object of module |pub|, and call method</span>
<span class="sd">        |HydPy.prepare_everything| (in this documentation, we first need</span>
<span class="sd">        to prepare the example project via function |prepare_full_example_1|</span>
<span class="sd">        and change the current working directory via class |TestIO|):</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, round_, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp.prepare_everything()</span>

<span class="sd">        Now you can start a simulation run and inspect the calculated</span>
<span class="sd">        time-series of all relevant sequences.  We take the discharge</span>
<span class="sd">        values of the flux sequence |hland_fluxes.QT| of |Element| object</span>
<span class="sd">        `land_dill` and of the node sequence |Sim| of |Node| object `dill`</span>
<span class="sd">        as examples, which provide the same information:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.elements.land_dill.model.sequences.fluxes.qt.series)</span>
<span class="sd">        11.78038, 8.901179, 7.131072, 6.017787</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.dill.sequences.sim.series)</span>
<span class="sd">        11.78038, 8.901179, 7.131072, 6.017787</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_network</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_conditions</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warnmissingobsfile</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_nodeseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_inputseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.prepare_network"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_network">[docs]</a>    <span class="nd">@printtools</span><span class="o">.</span><span class="n">print_progress</span>
    <span class="k">def</span> <span class="nf">prepare_network</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load all network files as |Selections| (stored in module |pub|)</span>
<span class="sd">        and assign the &quot;complete&quot; selection to the |HydPy| object.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.selections</span>

<span class="sd">        First, we call function |prepare_full_example_1| to prepare</span>
<span class="sd">        the `LahnH` example project, including its network files</span>
<span class="sd">        `headwaters.py`, `nonheadwaters.py`, and `streams.py`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">        Directly after initialising class |HydPy|, neither the</span>
<span class="sd">        resulting object nor module |pub| contain any information</span>
<span class="sd">        stemming from the network files:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pub.selections</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute selections \</span>
<span class="sd">of module `pub` is not defined at the moment.</span>

<span class="sd">        By calling the method |HydPy.prepare_network|, one loads all three</span>
<span class="sd">        network files into separate |Selection| objects, all handled</span>
<span class="sd">        by the |Selections| object of module |pub|.  Additionally,</span>
<span class="sd">        there is a |Selection| object named `complete`, covering all</span>
<span class="sd">        |Node| and |Element| objects of the other |Selection| objects:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; pub.selections</span>
<span class="sd">        Selections(&quot;complete&quot;, &quot;headwaters&quot;, &quot;nonheadwaters&quot;, &quot;streams&quot;)</span>

<span class="sd">        &gt;&gt;&gt; pub.selections.headwaters &lt;= pub.selections.complete</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pub.selections.nonheadwaters &lt;= pub.selections.complete</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pub.selections.streams &lt;= pub.selections.complete</span>
<span class="sd">        True</span>

<span class="sd">        Initially, the |HydPy| object is aware of the complete set</span>
<span class="sd">        of |Node| and |Element| objects:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes == pub.selections.complete.nodes</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements == pub.selections.complete.elements</span>
<span class="sd">        True</span>

<span class="sd">        See the documentation on method |HydPy.update_devices| on</span>
<span class="sd">        how to &quot;activate| another selection in the safest manner.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">()</span>
        <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span> <span class="o">+=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">networkmanager</span><span class="o">.</span><span class="n">load_files</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_devices</span><span class="p">(</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span><span class="o">.</span><span class="n">complete</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_models"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_models">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_models</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Read all control files related to the current |Element| objects,</span>
<span class="sd">        initialise the defined models, and prepare their parameter values.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        First, we call function |prepare_full_example_1| to prepare the</span>
<span class="sd">        `LahnH` example project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>

<span class="sd">        Now we can initialise a |HydPy| instance accordingly and call</span>
<span class="sd">        its methods |HydPy.prepare_network| and |HydPy.prepare_models|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, round_, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>

<span class="sd">        As a result, each |Element| object handles a model of the type and</span>
<span class="sd">        with the parameter values defined in the relevant control file:</span>

<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.name</span>
<span class="sd">        &#39;hland_v1&#39;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.parameters.control.area</span>
<span class="sd">        area(692.3)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.model.name</span>
<span class="sd">        &#39;hstream_v1&#39;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.model.parameters.control.lag</span>
<span class="sd">        lag(0.583)</span>

<span class="sd">        The `LahnH` example project comes with one auxiliary file, named</span>
<span class="sd">        `land.py`.  This file defines general parameter values, valid</span>
<span class="sd">        for all single parameter objects of the different model instances</span>
<span class="sd">        which are referencing this file via the `auxfile` keyword argument.</span>
<span class="sd">        The following examples use the `land_dill` element to show that</span>
<span class="sd">        the affected parameters are also correctly prepared:</span>

<span class="sd">        &gt;&gt;&gt; control = hp.elements.land_dill.model.parameters.control</span>
<span class="sd">        &gt;&gt;&gt; control.alpha</span>
<span class="sd">        alpha(1.0)</span>
<span class="sd">        &gt;&gt;&gt; control.pcorr</span>
<span class="sd">        pcorr(1.0)</span>
<span class="sd">        &gt;&gt;&gt; control.resparea</span>
<span class="sd">        resparea(True)</span>
<span class="sd">        &gt;&gt;&gt; control.icmax</span>
<span class="sd">        icmax(field=1.0, forest=1.5)</span>

<span class="sd">        We show that the individual |hland_control.IcMax| values for two</span>
<span class="sd">        different elements are different, to demonstrate that parameter</span>
<span class="sd">        values defined within a master control file (|hland_control.ZoneType|)</span>
<span class="sd">        can affect the actual values of parameters defined in auxiliary</span>
<span class="sd">        control files:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(control.icmax.values)</span>
<span class="sd">        1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5</span>
<span class="sd">        &gt;&gt;&gt; round_(</span>
<span class="sd">        ...     hp.elements.land_lahn_2.model.parameters.control.icmax.values)</span>
<span class="sd">        1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5, 1.0, 1.5</span>

<span class="sd">        Missing parameter information in auxiliary files results in errors</span>
<span class="sd">        like the following:</span>

<span class="sd">        &gt;&gt;&gt; filepath = &quot;LahnH/control/default/land.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(filepath) as infile:</span>
<span class="sd">        ...         text = infile.read().replace(&quot;alpha(1.0)&quot;, &quot;&quot;)</span>
<span class="sd">        ...     with open(filepath, &quot;w&quot;) as outfile:</span>
<span class="sd">        ...         outfile.write(text)</span>
<span class="sd">        ...     hp.prepare_models()   # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to initialise the model object of \</span>
<span class="sd">element `land_dill`, the following error occurred: While trying to load \</span>
<span class="sd">the control file `...land_dill.py`, the following error occurred: \</span>
<span class="sd">While trying to extract information for parameter `alpha` from file \</span>
<span class="sd">`land`, the following error occurred: The selected auxiliary file \</span>
<span class="sd">does not define value(s) for parameter `alpha`.</span>

<span class="sd">        Completely wrong control files result in the following error:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(&quot;LahnH/control/default/land_dill.py&quot;, &quot;w&quot;):</span>
<span class="sd">        ...         pass</span>
<span class="sd">        ...     hp.prepare_models()   # doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to initialise the model object of \</span>
<span class="sd">element `land_dill`, the following error occurred: Model parameters \</span>
<span class="sd">cannot be loaded from control file `...land_dill.py`.  Please refer \</span>
<span class="sd">to the HydPy documentation on how to prepare control files properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.init_models"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.init_models">[docs]</a>    <span class="k">def</span> <span class="nf">init_models</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated! Use method |HydPy.prepare_models| instead.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch.object(HydPy, &quot;prepare_models&quot;) as mocked:</span>
<span class="sd">        ...     hp = HydPy(&quot;test&quot;)</span>
<span class="sd">        ...     hp.init_models()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.HydPyDeprecationWarning: \</span>
<span class="sd">Method `init_models` of class `HydPy` is deprecated.  \</span>
<span class="sd">Use method `prepare_models` instead.</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call()]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_models</span><span class="p">()</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Method `init_models` of class `HydPy` is deprecated.  &quot;</span>
            <span class="s2">&quot;Use method `prepare_models` instead.&quot;</span><span class="p">,</span>
            <span class="n">exceptiontools</span><span class="o">.</span><span class="n">HydPyDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.save_controls"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_controls">[docs]</a>    <span class="k">def</span> <span class="nf">save_controls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">simulationstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">auxfiler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;auxfiletools.Auxfiler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Write the control files of all current |Element| objects.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        We use the `LahnH` example project to demonstrate how to write</span>
<span class="sd">        a complete set of parameter control files.  For convenience, we</span>
<span class="sd">        let function |prepare_full_example_2| prepare a fully functional</span>
<span class="sd">        |HydPy| object, handling seven |Element| objects controlling</span>
<span class="sd">        four |hland_v1| and three |hstream_v1| application models:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        At first, there is only one control subfolder named &quot;default&quot;,</span>
<span class="sd">        containing the seven master control files used in the step above:</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     os.listdir(&quot;LahnH/control&quot;)</span>
<span class="sd">        [&#39;default&#39;]</span>

<span class="sd">        Next, we use the |ControlManager| to create a new directory</span>
<span class="sd">        and write analogue control files into it:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls()</span>
<span class="sd">        ...     sorted(os.listdir(&quot;LahnH/control&quot;))</span>
<span class="sd">        [&#39;default&#39;, &#39;newdir&#39;]</span>

<span class="sd">        We focus our examples on the (shorter) control files of</span>
<span class="sd">        application model |hstream_v1|.  The values of parameter</span>
<span class="sd">        |hstream_control.Lag| and |hstream_control.Damp| for the</span>
<span class="sd">        river channel connecting the outlets of subcatchment `lahn_1`</span>
<span class="sd">        and `lahn_2` are 0.583 days and 0.0, respectively:</span>

<span class="sd">        &gt;&gt;&gt; model = hp.elements.stream_lahn_1_lahn_2.model</span>
<span class="sd">        &gt;&gt;&gt; model.parameters.control</span>
<span class="sd">        lag(0.583)</span>
<span class="sd">        damp(0.0)</span>

<span class="sd">        The corresponding written control file defines the same values:</span>

<span class="sd">        &gt;&gt;&gt; dir_ = &quot;LahnH/control/newdir/&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(0.583)</span>
<span class="sd">        damp(0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        Its name equals the element name.  The time step information</span>
<span class="sd">        stems from the |Timegrid| object available via |pub|:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.stepsize</span>
<span class="sd">        Period(&quot;1d&quot;)</span>

<span class="sd">        Use the |Auxfiler| class to avoid redefining the same parameter</span>
<span class="sd">        values in multiple control files.  Here, we prepare an |Auxfiler|</span>
<span class="sd">        object which handles the two parameters of the model discussed</span>
<span class="sd">        above:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Auxfiler</span>
<span class="sd">        &gt;&gt;&gt; auxfiler = Auxfiler(&quot;hstream_v1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; auxfiler.hstream_v1.add_parameter(</span>
<span class="sd">        ...     model.parameters.control.damp, filename=&quot;stream&quot;)</span>
<span class="sd">        &gt;&gt;&gt; auxfiler.hstream_v1.add_parameter(</span>
<span class="sd">        ...     model.parameters.control.lag, filename=&quot;stream&quot;)</span>

<span class="sd">        When passing the |Auxfiler| object to the method |HydPy.save_controls|,</span>
<span class="sd">        the control file of element `stream_lahn_1_lahn_2` does not</span>
<span class="sd">        define the values of both parameters on its own, but references</span>
<span class="sd">        the auxiliary file `stream.py` instead:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls(auxfiler=auxfiler)</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(auxfile=&quot;stream&quot;)</span>
<span class="sd">        damp(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        `stream.py` contains the actual value definitions:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(0.583)</span>
<span class="sd">        damp(0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        The |hstream_v1| model of element `stream_lahn_2_lahn_3` defines</span>
<span class="sd">        the same value for parameter |hstream_control.Damp| but a different</span>
<span class="sd">        one for parameter |hstream_control.Lag|.  Hence, only</span>
<span class="sd">        |hstream_control.Damp| can reference control file `stream.py`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_2_lahn_3.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1d&quot;)</span>
<span class="sd">        parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(0.417)</span>
<span class="sd">        damp(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        Another option is to pass alternative step size information.</span>
<span class="sd">        The `simulationstep` information, which is no integral part of</span>
<span class="sd">        control files but useful for testing them, has no impact on the</span>
<span class="sd">        written data.  However, passing an alternative `parameterstep`</span>
<span class="sd">        information changes the written values of time-dependent</span>
<span class="sd">        parameters both in the primary and the auxiliary control files,</span>
<span class="sd">        as to be expected:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.controlmanager.currentdir = &quot;newdir&quot;</span>
<span class="sd">        ...     hp.save_controls(</span>
<span class="sd">        ...         auxfiler=auxfiler, parameterstep=&quot;2d&quot;, simulationstep=&quot;1h&quot;)</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_1_lahn_2.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(auxfile=&quot;stream&quot;)</span>
<span class="sd">        damp(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(0.2915)</span>
<span class="sd">        damp(0.0)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(dir_ + &quot;stream_lahn_2_lahn_3.py&quot;) as controlfile:</span>
<span class="sd">        ...         print(controlfile.read())</span>
<span class="sd">        # -*- coding: utf-8 -*-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        from hydpy.models.hstream_v1 import *</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        simulationstep(&quot;1h&quot;)</span>
<span class="sd">        parameterstep(&quot;2d&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        lag(0.2085)</span>
<span class="sd">        damp(auxfile=&quot;stream&quot;)</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_controls</span><span class="p">(</span>
            <span class="n">parameterstep</span><span class="o">=</span><span class="n">parameterstep</span><span class="p">,</span>
            <span class="n">simulationstep</span><span class="o">=</span><span class="n">simulationstep</span><span class="p">,</span>
            <span class="n">auxfiler</span><span class="o">=</span><span class="n">auxfiler</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.load_conditions"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">load_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load all currently relevant initial conditions.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">            &gt;&gt;&gt; del pub.options.parameterstep</span>

<span class="sd">        The following examples demonstrate both the functionality of</span>
<span class="sd">        method |HydPy.load_conditions| and |HydPy.save_conditions| based</span>
<span class="sd">        on the `LahnH` project, which we prepare via function</span>
<span class="sd">        |prepare_full_example_2|:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        Our |HydPy| instance `hp` is ready for the first simulation run,</span>
<span class="sd">        meaning the required initial conditions are available already.</span>
<span class="sd">        First, we start a simulation run covering the whole initialisation</span>
<span class="sd">        period and inspect the resulting soil moisture values of |Element|</span>
<span class="sd">        `land_dill`, handled by a sequence object of type |hland_states.SM|:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; sm = hp.elements.land_dill.model.sequences.states.sm</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">           208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">           235.597338, 234.329294)</span>

<span class="sd">        By default, method |HydPy.load_conditions| always (re)loads the</span>
<span class="sd">        initial conditions from the directory with its name matching the</span>
<span class="sd">        start date of the simulation period, which we prove by also</span>
<span class="sd">        showing the related content of the respective condition file</span>
<span class="sd">        `land_dill.py`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/init_1996_01_01_00_00_00/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>

<span class="sd">        Now we perform two consecutive runs, covering the first and the</span>
<span class="sd">        second half of the initialisation period, respectively, and</span>
<span class="sd">        write, in both cases, the resulting final conditions to disk:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.save_conditions()</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.save_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.098541, 180.176461, 198.689343, 195.462014, 210.856923,</span>
<span class="sd">           208.319571, 220.881637, 218.898327, 229.022364, 227.431521,</span>
<span class="sd">           235.597338, 234.329294)</span>

<span class="sd">        Analogous to method |HydPy.load_conditions|, method</span>
<span class="sd">        |HydPy.save_conditions| writes the resulting conditions to a</span>
<span class="sd">        directory with its name matching the end date of the simulation</span>
<span class="sd">        period, which we prove by reloading the conditions related</span>
<span class="sd">        to the middle of the initialisation period and showing the</span>
<span class="sd">        relevant file content:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/init_1996_01_03_00_00_00/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        ...         print(lines[12])</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        You can define another directory by assigning a different</span>
<span class="sd">        name to property |FileManager.currentdir| of the actual</span>
<span class="sd">        |ConditionManager| instance:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     pub.conditionmanager.currentdir = &quot;test&quot;</span>
<span class="sd">        ...     hp.save_conditions()</span>

<span class="sd">        &gt;&gt;&gt; path = &quot;LahnH/conditions/test/land_dill.py&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     with open(path, &quot;r&quot;) as file_:</span>
<span class="sd">        ...         lines = file_.read().split(&quot;\\n&quot;)</span>
<span class="sd">        ...         print(lines[10])</span>
<span class="sd">        ...         print(lines[11])</span>
<span class="sd">        ...         print(lines[12])</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        This change remains permanent until you undo it manually:</span>

<span class="sd">        &gt;&gt;&gt; sm(0.0)</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(184.603966, 180.671117, 199.234825, 195.998635, 211.435809,</span>
<span class="sd">           208.891492, 221.488046, 219.49929, 229.651122, 228.055912,</span>
<span class="sd">           236.244147, 234.972621)</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     del pub.conditionmanager.currentdir</span>
<span class="sd">        ...     hp.load_conditions()</span>
<span class="sd">        &gt;&gt;&gt; sm</span>
<span class="sd">        sm(185.13164, 181.18755, 199.80432, 196.55888, 212.04018, 209.48859,</span>
<span class="sd">           222.12115, 220.12671, 230.30756, 228.70779, 236.91943, 235.64427)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_conditions</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_conditions"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">save_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Save all currently relevant final conditions.</span>

<span class="sd">        See the documentation on method |HydPy.load_conditions| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_conditions</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.trim_conditions"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.trim_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">trim_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check all values of the condition sequences (|StateSequence|</span>
<span class="sd">        and |LogSequence| objects) for boundary violations and fix them</span>
<span class="sd">        if necessary.</span>

<span class="sd">        We use the `LahnH` example project to explain the functionality</span>
<span class="sd">        of method |HydPy.trim_conditions|, that gives no response at</span>
<span class="sd">        all when all conditions are correctly set:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True):</span>
<span class="sd">        ...     hp.trim_conditions()</span>

<span class="sd">        If you try, for example, to set interception capacities</span>
<span class="sd">        (|hland_states.Ic|) that violate the maximum capacity</span>
<span class="sd">        (|hland_control.IcMax|), you get a direct response based</span>
<span class="sd">        on function |trim|:</span>

<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True):</span>
<span class="sd">        ...     hp.elements.land_dill.model.sequences.states.ic(1.2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: For variable `ic` of element `land_dill` at least \</span>
<span class="sd">one value needed to be trimmed.  The old and the new value(s) are \</span>
<span class="sd">`1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2` and \</span>
<span class="sd">`1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2`, respectively.</span>

<span class="sd">        However, changing the boundaries themselves without adjusting</span>
<span class="sd">        the conditions cannot be detected automatically.  Whenever in</span>
<span class="sd">        doubt, call method |HydPy.trim_conditions| explicitly:</span>

<span class="sd">        &gt;&gt;&gt; hp.elements.land_dill.model.parameters.control.icmax(1.1)</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True):</span>
<span class="sd">        ...     hp.trim_conditions()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: For variable `ic` of element `land_dill` at least \</span>
<span class="sd">one value needed to be trimmed.  The old and the new value(s) are \</span>
<span class="sd">`1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2, 1.0, 1.2` and \</span>
<span class="sd">`1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1, 1.0, 1.1`, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">trim_conditions</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.reset_conditions"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.reset_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">reset_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset all currently relevant condition sequences.</span>

<span class="sd">        Method |HydPy.reset_conditions| is the most convenient way to</span>
<span class="sd">        perform simulations repeatedly for the same period, each time</span>
<span class="sd">        starting from the same initial conditions, e.g. for parameter</span>
<span class="sd">        calibration. Each |StateSequence| and |LogSequence| object</span>
<span class="sd">        remembers the last assigned values and can reactivate them</span>
<span class="sd">        for the mentioned purpose.</span>

<span class="sd">        For demonstration, we perform a simulation for the `LahnH`</span>
<span class="sd">        example project spanning four days:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import print_values</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        Just repeating the simulation gives different results due to</span>
<span class="sd">        applying the final states of the first simulation run as the</span>
<span class="sd">        initial states of the second run:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        26.218473, 25.039964, 24.205384, 23.296241</span>

<span class="sd">        Calling |HydPy.reset_conditions| first allows repeating the</span>
<span class="sd">        first simulation run exactly multiple times:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">reset_conditions</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConditionsType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;A nested dictionary, containing the values of all condition</span>
<span class="sd">        sequences of all currently handled models.</span>

<span class="sd">        The primary  purpose of property |HydPy.conditions| is similar to</span>
<span class="sd">        the one of method |HydPy.reset_conditions|, to allow to perform</span>
<span class="sd">        repeated calculations starting from the same initial conditions.</span>
<span class="sd">        Nevertheless, |HydPy.conditions| is more flexible when it comes</span>
<span class="sd">        to handling multiple conditions, which can, for example, be useful</span>
<span class="sd">        for applying ensemble based assimilation algorithms.</span>

<span class="sd">        For demonstration, we perform simulations for the `LahnH` example</span>
<span class="sd">        project spanning the first three months of 1996.  We begin with a</span>
<span class="sd">        preparation run beginning on the first day of January and ending</span>
<span class="sd">        on the 20th day of February:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO, print_values</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-04-01&quot;, &quot;1d&quot;</span>
<span class="sd">        ...     hp.prepare_everything()</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; print_values(hp.nodes.lahn_3.sequences.sim.series[48:52])</span>
<span class="sd">        70.553509, 94.344086, nan, nan</span>

<span class="sd">        At the end of the preparation run, a snow layer is covering the</span>
<span class="sd">        Lahn catchment.  In the `lahn_1` subcatchment, this snow layer</span>
<span class="sd">        contains 19.5 mm of frozen water and 1.7 mm of liquid water:</span>

<span class="sd">        &gt;&gt;&gt; lahn1_states = hp.elements.land_lahn_1.model.sequences.states</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        1.745963</span>

<span class="sd">        Now we save the current conditions and perform the first simulation</span>
<span class="sd">        run from the 20th day of February until the end of March:</span>

<span class="sd">        &gt;&gt;&gt; conditions = hp.conditions</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-04-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; first = hp.nodes.lahn_3.sequences.sim.series.copy()</span>
<span class="sd">        &gt;&gt;&gt; print_values(first[48:52])</span>
<span class="sd">        0.0, 0.0, 85.150677, 63.902098</span>

<span class="sd">        To exactly repeat the last simulation run, we assign the</span>
<span class="sd">        memorised conditions to property |HydPy.conditions|:</span>

<span class="sd">        &gt;&gt;&gt; hp.conditions = conditions</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        1.745963</span>

<span class="sd">        All discharge values of the second simulation run are identical</span>
<span class="sd">        with the ones of the first simulation run:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-02-20&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-04-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; second = hp.nodes.lahn_3.sequences.sim.series.copy()</span>
<span class="sd">        &gt;&gt;&gt; print_values(second[48:52])</span>
<span class="sd">        0.0, 0.0, 85.150677, 63.902098</span>
<span class="sd">        &gt;&gt;&gt; all(first == second)</span>
<span class="sd">        True</span>

<span class="sd">        We selected the snow period as an example due to potential</span>
<span class="sd">        problems with the limited water holding capacity of the</span>
<span class="sd">        snow layer, which depends on the ice content of the snow layer</span>
<span class="sd">        (|hland_states.SP|) and the relative water holding capacity</span>
<span class="sd">        (|hland_control.WHC|).  Due to this restriction, problems can</span>
<span class="sd">        occur.  To give an example, we set |hland_control.WHC| to zero</span>
<span class="sd">        temporarily, apply the memorised conditions, and finally reset</span>
<span class="sd">        the original values of |hland_control.WHC|:</span>

<span class="sd">        &gt;&gt;&gt; for element in hp.elements.catchment:</span>
<span class="sd">        ...     element.whc = element.model.parameters.control.whc.values</span>
<span class="sd">        ...     element.model.parameters.control.whc = 0.0</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(False):</span>
<span class="sd">        ...     hp.conditions = conditions</span>
<span class="sd">        &gt;&gt;&gt; for element in hp.elements.catchment:</span>
<span class="sd">        ...     element.model.parameters.control.whc = element.whc</span>

<span class="sd">        Without any water holding capacity of the snow layer, its water</span>
<span class="sd">        content is zero despite the actual memorised value of 1.7 mm:</span>

<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.sp.average_values()])</span>
<span class="sd">        19.543831</span>
<span class="sd">        &gt;&gt;&gt; print_values([lahn1_states.wc.average_values()])</span>
<span class="sd">        0.0</span>

<span class="sd">        What is happening in the case of such conflicts partly depends</span>
<span class="sd">        on the implementation of the respective application model.</span>
<span class="sd">        For safety, we suggest setting the option |Options.warntrim| to</span>
<span class="sd">        |True| before resetting conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">conditions</span>

    <span class="k">def</span> <span class="nf">_set_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">:</span> <span class="n">ConditionsType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="n">conditions</span>

    <span class="n">conditions</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_conditions</span><span class="p">,</span> <span class="n">_set_conditions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">networkproperties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="p">],</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Some properties of the network defined by the currently relevant</span>
<span class="sd">        |Node| and |Element| objects.</span>

<span class="sd">        See the documentation on method |HydPy.print_networkproperties|</span>
<span class="sd">        for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;Number of nodes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
            <span class="s2">&quot;Number of elements&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">),</span>
            <span class="s2">&quot;Number of end nodes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endnodes</span><span class="p">),</span>
            <span class="s2">&quot;Number of distinct networks&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segregatednetworks</span><span class="p">),</span>
            <span class="s2">&quot;Applied node variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="s2">&quot;Applied model types&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modeltypes</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="HydPy.print_networkproperties"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.print_networkproperties">[docs]</a>    <span class="k">def</span> <span class="nf">print_networkproperties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Print some properties of the network defined by the currently</span>
<span class="sd">        relevant |Node| and |Element| objects.</span>

<span class="sd">        |HydPy.print_networkproperties| is for convenience to summarise</span>
<span class="sd">        specific network measures like |HydPy.segregatednetworks|.</span>

<span class="sd">        The `LahnH` example project defines a small, single network,</span>
<span class="sd">        with all catchments ultimately discharging to node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        &gt;&gt;&gt; hp.print_networkproperties()</span>
<span class="sd">        Number of nodes: 4</span>
<span class="sd">        Number of elements: 7</span>
<span class="sd">        Number of end nodes: 1</span>
<span class="sd">        Number of distinct networks: 1</span>
<span class="sd">        Applied node variables: Q (4)</span>
<span class="sd">        Applied model types: hland_v1 (4) and hstream_v1 (3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">networkproperties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">nmb</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">nmb</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;All currently relevant |Node| objects which define a downstream</span>
<span class="sd">        endpoint of the network.</span>

<span class="sd">        The `LahnH` example project defines a small, single network,</span>
<span class="sd">        with all catchments ultimately discharging to node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_3&quot;)</span>

<span class="sd">        After breaking the connection between node `lahn_1` and its</span>
<span class="sd">        downstream river channel element `stream_lahn_1_lahn2`,</span>
<span class="sd">        `lahn_1` also becomes an end node:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_1.exits.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; del hp.nodes.lahn_1.exits.stream_lahn_1_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_lahn_1_lahn_2.inlets.lahn_1</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        Even with a proper connection to a downstream element, a node</span>
<span class="sd">        counts as an end node as long as these elements are not part</span>
<span class="sd">        of the currently relevant network (meaning, currently handled</span>
<span class="sd">        by the |HydPy| object):</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_dill_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">        Elements(&quot;stream_dill_lahn_2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>

<span class="sd">        Connections with &quot;remote&quot; elements are considered irrelevant:</span>

<span class="sd">        &gt;&gt;&gt; stream = hp.elements.stream_lahn_2_lahn_3</span>
<span class="sd">        &gt;&gt;&gt; stream.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers += stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endnodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">exits</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">receivers</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endnodes</span> <span class="o">+=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">endnodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segregatednetworks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;selectiontools.Selections&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of segregated networks defined by the currently</span>
<span class="sd">        relevant |Node| and |Element| objects.</span>

<span class="sd">        Each end node (as defined by property |HydPy.endnodes|) eventually</span>
<span class="sd">        defines a single network, segregated from the networks of other</span>
<span class="sd">        end nodes.  Due to the `LahnH` example project defining only a</span>
<span class="sd">        single end node, there can be only one segregate network,</span>
<span class="sd">        accordingly:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;,</span>
<span class="sd">                            &quot;land_lahn_3&quot;, &quot;stream_dill_lahn_2&quot;,</span>
<span class="sd">                            &quot;stream_lahn_1_lahn_2&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        Revisiting the examples of the documentation on property</span>
<span class="sd">        |HydPy.endnodes|, we get the similar results.  Note that</span>
<span class="sd">        the segregated networks are always |Selection| objects, that</span>
<span class="sd">        do not overlap each other (meaning, no |Node| or |Element| object</span>
<span class="sd">        occurs more than one time):</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_1.exits.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; hp.elements.stream_lahn_1_lahn_2.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; del hp.nodes.lahn_1.exits.stream_lahn_1_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_lahn_1_lahn_2.inlets.lahn_1</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                            &quot;stream_dill_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;,</span>
<span class="sd">                            &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        &gt;&gt;&gt; del hp.elements.stream_dill_lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.dill.exits</span>
<span class="sd">        Elements(&quot;stream_dill_lahn_2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.dill</span>
<span class="sd">        Selection(&quot;dill&quot;,</span>
<span class="sd">                  nodes=&quot;dill&quot;,</span>
<span class="sd">                  elements=&quot;land_dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=(&quot;lahn_2&quot;, &quot;lahn_3&quot;),</span>
<span class="sd">                  elements=(&quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;,</span>
<span class="sd">                            &quot;stream_lahn_1_lahn_2&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>


<span class="sd">        &gt;&gt;&gt; stream = hp.elements.stream_lahn_2_lahn_3</span>
<span class="sd">        &gt;&gt;&gt; stream.inlets.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers.mutable = True</span>
<span class="sd">        &gt;&gt;&gt; stream.receivers += stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; del stream.inlets.lahn_2</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;dill&quot;, &quot;lahn_1&quot;, &quot;lahn_2&quot;, &quot;lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.dill</span>
<span class="sd">        Selection(&quot;dill&quot;,</span>
<span class="sd">                  nodes=&quot;dill&quot;,</span>
<span class="sd">                  elements=&quot;land_dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_1</span>
<span class="sd">        Selection(&quot;lahn_1&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_1&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_2</span>
<span class="sd">        Selection(&quot;lahn_2&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_2&quot;,</span>
<span class="sd">                  elements=(&quot;land_lahn_2&quot;, &quot;stream_lahn_1_lahn_2&quot;))</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_3&quot;,</span>
<span class="sd">                  elements=(&quot;land_lahn_3&quot;, &quot;stream_lahn_2_lahn_3&quot;))</span>

<span class="sd">        In all examples above, the number of the end nodes and the number</span>
<span class="sd">        of the segregated networks are identical, which is not the case</span>
<span class="sd">        when two or more networks share the same network.  We restore</span>
<span class="sd">        our original network and add two additional end nodes, `nowhere`</span>
<span class="sd">        and `somewhere`,  linking the first one with element</span>
<span class="sd">        `stream_lahn_2_lahn_3` and the second one with the additional</span>
<span class="sd">        element `stream_lahn_1_nowhere`, which we connect to node `lahn_1`:</span>

<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Element</span>
<span class="sd">        &gt;&gt;&gt; _ = Element(&quot;stream_lahn_2_lahn_3&quot;, outlets=&quot;nowhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += &quot;nowhere&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.elements += Element(&quot;stream_lahn_1_nowhere&quot;,</span>
<span class="sd">        ...                        inlets=&quot;lahn_1&quot;,</span>
<span class="sd">        ...                        outlets=&quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += &quot;somewhere&quot;</span>

<span class="sd">        Now there are three end nodes but only two segregated networks,</span>
<span class="sd">        as node `nowhere` does not reference any upstream devices not</span>
<span class="sd">        also referenced by node `lahn_3`.  The unique feature of element</span>
<span class="sd">        `lahn_3` and `stream_lahn_1_nowhere` is that they drain to</span>
<span class="sd">        either node `lahn_3` or `somewhere` but not both, which is why</span>
<span class="sd">        they are the only members of selection `lahn_3` and `somewhere`,</span>
<span class="sd">        respectively:</span>

<span class="sd">        &gt;&gt;&gt; hp.endnodes</span>
<span class="sd">        Nodes(&quot;lahn_3&quot;, &quot;nowhere&quot;, &quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks</span>
<span class="sd">        Selections(&quot;lahn_3&quot;, &quot;somewhere&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.lahn_3</span>
<span class="sd">        Selection(&quot;lahn_3&quot;,</span>
<span class="sd">                  nodes=&quot;lahn_3&quot;,</span>
<span class="sd">                  elements=&quot;land_lahn_3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.segregatednetworks.somewhere</span>
<span class="sd">        Selection(&quot;somewhere&quot;,</span>
<span class="sd">                  nodes=&quot;somewhere&quot;,</span>
<span class="sd">                  elements=&quot;stream_lahn_1_nowhere&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sels1</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">()</span>
        <span class="n">sels2</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">()</span>
        <span class="n">complete</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">(</span><span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endnodes</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">select_upstream</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">sels1</span> <span class="o">+=</span> <span class="n">sel</span>
            <span class="n">sels2</span> <span class="o">+=</span> <span class="n">sel</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sel1</span> <span class="ow">in</span> <span class="n">sels1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sel2</span> <span class="ow">in</span> <span class="n">sels2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sel1</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">sel2</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">sel1</span> <span class="o">-=</span> <span class="n">sel2</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sels1</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sels1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sels1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sels1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodeVariableType</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Summary of all |Node.variable| properties of the currently</span>
<span class="sd">        relevant |Node| objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.variables</span>
<span class="sd">        {&#39;Q&#39;: 4}</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import FusedVariable, Node</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.inputs import hland_T</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes += Node(&quot;test&quot;, variable=FusedVariable(&quot;T&quot;, hland_T))</span>
<span class="sd">        &gt;&gt;&gt; hp.variables</span>
<span class="sd">        {&#39;Q&#39;: 4, FusedVariable(&quot;T&quot;, hland_T): 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">Type</span><span class="p">[</span><span class="n">sequencetools</span><span class="o">.</span><span class="n">InputSequence</span><span class="p">],</span>
                <span class="n">Type</span><span class="p">[</span><span class="n">sequencetools</span><span class="o">.</span><span class="n">OutputSequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span>
                <span class="n">devicetools</span><span class="o">.</span><span class="n">FusedVariable</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="nb">int</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tuple_</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">tuple_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">modeltypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Summary of all |Model| subclasses of the currently relevant</span>
<span class="sd">        |Element| objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_1</span>
<span class="sd">        &gt;&gt;&gt; prepare_full_example_1()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy, pub, TestIO</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp = HydPy(&quot;LahnH&quot;)</span>
<span class="sd">        ...     hp.prepare_network()</span>
<span class="sd">        &gt;&gt;&gt; hp.modeltypes</span>
<span class="sd">        {&#39;unprepared&#39;: 7}</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids = &quot;1996-01-01&quot;, &quot;1996-01-05&quot;, &quot;1d&quot;</span>
<span class="sd">        &gt;&gt;&gt; with TestIO():</span>
<span class="sd">        ...     hp.prepare_models()</span>
<span class="sd">        &gt;&gt;&gt; hp.modeltypes</span>
<span class="sd">        {&#39;hland_v1&#39;: 4, &#39;hstream_v1&#39;: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">modeltypes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">getattr_</span><span class="p">(</span>
                <span class="n">element</span><span class="p">,</span> <span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="s2">&quot;unprepared&quot;</span><span class="p">,</span> <span class="n">modeltools</span><span class="o">.</span><span class="n">Model</span>
            <span class="p">)</span>
            <span class="n">modeltypes</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">modeltypes</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

<div class="viewcode-block" id="HydPy.open_files"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.open_files">[docs]</a>    <span class="k">def</span> <span class="nf">open_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Open all required internal time-series files.</span>

<span class="sd">        This method is only required when storing internal time-series</span>
<span class="sd">        data on disk.  See the main documentation on class |HydPy| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">open_files</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">open_files</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.close_files"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.close_files">[docs]</a>    <span class="k">def</span> <span class="nf">close_files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close all previously opened internal time-series files.</span>

<span class="sd">        This method is only required when storing internal time-series</span>
<span class="sd">        data on disk.  See the main documentation on class |HydPy| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">selection</span><span class="p">:</span> <span class="s2">&quot;selectiontools.Selection&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Selection as input&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Devices as input&quot;&quot;&quot;</span>

<div class="viewcode-block" id="HydPy.update_devices"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.update_devices">[docs]</a>    <span class="k">def</span> <span class="nf">update_devices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;selectiontools.Selection&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">NodesConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">ElementsConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine the order, in which method |HydPy.simulate| processes</span>
<span class="sd">        the currently relevant |Node| and |Element| objects.</span>

<span class="sd">        Eventually passed |Node| and |Element| objects (for example,</span>
<span class="sd">        contained within a |Selection| object) replace existing ones.</span>

<span class="sd">        As described in the documentation on the method</span>
<span class="sd">        |HydPy.prepare_network|, a |HydPy| object usually starts with</span>
<span class="sd">        the &quot;complete&quot; network of the considered project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        The safest approach to &quot;activate&quot; another selection is to use</span>
<span class="sd">        the method |HydPy.update_devices|.  The first option is to pass</span>
<span class="sd">        a complete |Selection| object:</span>

<span class="sd">        &gt;&gt;&gt; pub.selections.headwaters</span>
<span class="sd">        Selection(&quot;headwaters&quot;,</span>
<span class="sd">                  nodes=(&quot;dill&quot;, &quot;lahn_1&quot;),</span>
<span class="sd">                  elements=(&quot;land_dill&quot;, &quot;land_lahn_1&quot;))</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;, &quot;lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>

<span class="sd">        Method |HydPy.update_devices| automatically updates the `deviceorder`,</span>
<span class="sd">        assuring method |HydPy.simulate| processes &quot;upstream&quot; model</span>
<span class="sd">        instances before it processes their &quot;downstream&quot; neighbours:</span>

<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        lahn_1</span>
<span class="sd">        land_dill</span>
<span class="sd">        dill</span>

<span class="sd">        Second, you can pass some nodes only, which by the way removes the</span>
<span class="sd">        old elements:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(nodes=&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements()</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        dill</span>

<span class="sd">        Third, you can pass some elements only, which by the way removes the</span>
<span class="sd">        old nodes:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes()</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        land_dill</span>

<span class="sd">        Fourth, you can pass nodes and elements at the same time:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(nodes=&quot;dill&quot;,</span>
<span class="sd">        ...                   elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes</span>
<span class="sd">        Nodes(&quot;dill&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hp.elements</span>
<span class="sd">        Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        land_dill</span>
<span class="sd">        dill</span>

<span class="sd">        Fifth, you can pass no argument at all, which only updates the</span>
<span class="sd">        device order:</span>

<span class="sd">        &gt;&gt;&gt; del hp.nodes.dill</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        land_dill</span>
<span class="sd">        dill</span>
<span class="sd">        &gt;&gt;&gt; hp.update_devices()</span>
<span class="sd">        &gt;&gt;&gt; for device in hp.deviceorder:</span>
<span class="sd">        ...     print(device)</span>
<span class="sd">        land_lahn_1</span>
<span class="sd">        land_dill</span>

<span class="sd">        Method |HydPy.update_devices| does not allow to pass single devices</span>
<span class="sd">        and devices contained within a selection at the same time:</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters,</span>
<span class="sd">        ...                   nodes=&quot;dill&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Method `update_devices` of class `HydPy` does not allow \</span>
<span class="sd">to use both the `selection` argument and the `nodes` or  the `elements` \</span>
<span class="sd">argument at the same time.</span>

<span class="sd">        &gt;&gt;&gt; hp.update_devices(selection=pub.selections.headwaters,</span>
<span class="sd">        ...                   elements=[&quot;land_lahn_1&quot;, &quot;land_dill&quot;])</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Method `update_devices` of class `HydPy` does not allow \</span>
<span class="sd">to use both the `selection` argument and the `nodes` or  the `elements` \</span>
<span class="sd">argument at the same time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">elements</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Method `update_devices` of class `HydPy` does not allow &quot;</span>
                    <span class="s2">&quot;to use both the `selection` argument and the `nodes` or  &quot;</span>
                    <span class="s2">&quot;the `elements` argument at the same time.&quot;</span>
                <span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
            <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span>
            <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">devices</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">create_directedgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">nodenames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">names</span>
        <span class="n">elementnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">device</span>
            <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">devices</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">nodenames</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">elementnames</span><span class="p">)</span>
        <span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">methodorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;All methods of the currently relevant |Node| and |Element|</span>
<span class="sd">        objects to be processed by method |HydPy.simulate| during a</span>
<span class="sd">        simulation time step, ordered in a correct execution sequence.</span>

<span class="sd">        Property |HydPy.methodorder| should be of interest for framework</span>
<span class="sd">        developers only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">funcs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;oldsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_simdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_newsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">load_obsdata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;oldsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">reset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviceorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">device</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;obs_newsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">fill_obsdata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">senders</span><span class="p">:</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update_senders</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">receivers</span><span class="p">:</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update_receivers</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">deploymode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;oldsim&quot;</span><span class="p">,</span> <span class="s2">&quot;obs_oldsim&quot;</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">fastaccess</span><span class="o">.</span><span class="n">save_simdata</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">funcs</span>

<div class="viewcode-block" id="HydPy.simulate"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.simulate">[docs]</a>    <span class="nd">@printtools</span><span class="o">.</span><span class="n">print_progress</span>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform a simulation run over the actual simulation period</span>
<span class="sd">        defined by the |Timegrids| object stored in module |pub|.</span>

<span class="sd">        We let function |prepare_full_example_2| prepare a runnable</span>
<span class="sd">        |HydPy| object related to the `LahnH` example project:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        First, we execute a default simulation run covering the whole</span>
<span class="sd">        simulation period and inspect the discharge series simulated</span>
<span class="sd">        at the outlet of the river basin, represented by node `lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        After resetting the initial conditions via method</span>
<span class="sd">        |HydPy.reset_conditions|, we repeat the simulation run and get</span>
<span class="sd">        the same results:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        Simulation runs do not need to cover the whole initialisation</span>
<span class="sd">        period at once.  After setting the |Timegrid.lastdate| property</span>
<span class="sd">        of the `sim` |Timegrid| of the |Timegrids| objects stored within</span>
<span class="sd">        module |pub| to the middle of the initialisation period, method</span>
<span class="sd">        |HydPy.simulate| calculates the first two discharge values only:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 0.0, 0.0</span>

<span class="sd">        After justing the both |Timegrid.firstdate| and |Timegrid.lastdate|</span>
<span class="sd">        of the `sim` |Timegrid| to the second half of the initialisation</span>
<span class="sd">        period, |HydPy.simulate| completes the time-series:</span>

<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-03&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>

<span class="sd">        In the above examples, each |Model| object (handled by an |Element|</span>
<span class="sd">        object) passes its simulated values via a |Node| object to its</span>
<span class="sd">        downstream |Model| object.  There are four ways to deviate from</span>
<span class="sd">        this default behaviour, that can be selected for each node</span>
<span class="sd">        individually via the property |Node.deploymode|.  We focus on node</span>
<span class="sd">        `lahn_2` in the following, being the upstream neighbour of node</span>
<span class="sd">        `lahn_3`.  So far, its deploy mode is `newsim`, meaning that the</span>
<span class="sd">        node passes newly calculated simulation values to the downstream</span>
<span class="sd">        element `stream_lahn_2_lahn_3`:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode</span>
<span class="sd">        &#39;newsim&#39;</span>

<span class="sd">        Under the second option `oldsim`, node `lahn_2` does not pass</span>
<span class="sd">        the discharge values simulated in the next simulation run but</span>
<span class="sd">        the &quot;old&quot; discharge values already available by the</span>
<span class="sd">        |IOSequence.series| array of the |Sim| sequence.  This behaviour</span>
<span class="sd">        can, for example, be useful when calibrating subsequent subareas</span>
<span class="sd">        of a river basin sequentially, beginning with the headwaters</span>
<span class="sd">        and continuing with their downstream neighbours.  For the</span>
<span class="sd">        clarity of this example, we decrease all values of the &quot;old&quot;</span>
<span class="sd">        simulated series of node `lahn_2` by 10 m/s:</span>

<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;oldsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.sim.series -= 10.0</span>

<span class="sd">        After performing another simulation run (over the whole</span>
<span class="sd">        initialisation period, again), the modified discharge values of</span>
<span class="sd">        node `lahn_2` are unchanged.  The simulated values of node</span>
<span class="sd">        `lahn_3` are, compared to the `newsim` runs, decreased by 10 m/s</span>
<span class="sd">        (there is no time delay or dampening of the discharge values</span>
<span class="sd">        between both nodes due to the |hstream_control.Lag| time of</span>
<span class="sd">        application model |hstream_v1| being smaller than the simulation</span>
<span class="sd">        time step):</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.firstdate = &quot;1996-01-01&quot;</span>
<span class="sd">        &gt;&gt;&gt; pub.timegrids.sim.lastdate = &quot;1996-01-05&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        32.3697, 17.210443, 12.930066, 10.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        44.043745, 27.320814, 21.922053, 18.413644</span>

<span class="sd">        The third option is `obs`, where node `lahn_2` receives</span>
<span class="sd">        and stores the values from its upstream models but passes</span>
<span class="sd">        other, observed values, handled by sequence |Obs|, which</span>
<span class="sd">        we, for simplicity, set to zero for the complete initialisation</span>
<span class="sd">        and simulation period (more often, one would read measured</span>
<span class="sd">        data from files via methods as |HydPy.load_obsseries|):</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.obs.series = 0.0</span>

<span class="sd">        Now the simulated values of node `lahn_2` are identical with</span>
<span class="sd">        the ones of the `newsim` example, but the simulated values</span>
<span class="sd">        of node `lahn_3` are lower due to receiving the observed</span>
<span class="sd">        instead of the simulated values from upstream:</span>

<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, 0.0, 0.0, 0.0</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 10.110371, 8.991987, 8.212314</span>

<span class="sd">        Unfortunately, observation time series are often incomplete.  *HydPy*</span>
<span class="sd">        generally uses |numpy| |numpy.nan| to represent missing values.</span>
<span class="sd">        Passing |numpy.nan| inputs to a model usually results in |numpy.nan|</span>
<span class="sd">        outputs.  Hence, after assigning |numpy.nan| to some entries of the</span>
<span class="sd">        observation series of node `lahn_2`, the simulation series of node</span>
<span class="sd">        `lahn_3` also contains |numpy.nan| values:</span>

<span class="sd">        &gt;&gt;&gt; from numpy import nan</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">        ...     hp.nodes.lahn_2.sequences.obs.series= 0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_3.sequences.sim.series = 0.0</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, nan, 8.991987, nan</span>

<span class="sd">        To avoid the calculation of |numpy.nan| values, one can select the</span>
<span class="sd">        fourth option `obs_newsim`.  Now the priority for node `lahn_2` is</span>
<span class="sd">        to deploy its observed values.  However, for each missing observation,</span>
<span class="sd">        it deploys its newly simulated value instead:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs_newsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 37.320814, 8.991987, 28.413644</span>

<span class="sd">        The fifth option `obs_oldsim` serves the same purpose as option</span>
<span class="sd">        `obs_newsim` but uses already available &quot;old&quot; simulation results</span>
<span class="sd">        as substitutes:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;obs_oldsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.sequences.sim.series = (</span>
<span class="sd">        ...     32.3697, 17.210443, 12.930066, 10.20133)</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.obs.series)</span>
<span class="sd">        0.0, nan, 0.0, nan</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        32.3697, 17.210443, 12.930066, 10.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        11.674045, 27.320814, 8.991987, 18.413644</span>

<span class="sd">        The last example shows that resetting option |Node.deploymode|</span>
<span class="sd">        to `newsim` results in the default behaviour of the method</span>
<span class="sd">        |HydPy.simulate|, again:</span>

<span class="sd">        &gt;&gt;&gt; hp.nodes.lahn_2.deploymode = &quot;newsim&quot;</span>
<span class="sd">        &gt;&gt;&gt; hp.reset_conditions()</span>
<span class="sd">        &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_2.sequences.sim.series)</span>
<span class="sd">        42.3697, 27.210443, 22.930066, 20.20133</span>
<span class="sd">        &gt;&gt;&gt; round_(hp.nodes.lahn_3.sequences.sim.series)</span>
<span class="sd">        54.043745, 37.320814, 31.922053, 28.413644</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">simindices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_files</span><span class="p">(</span><span class="n">idx_start</span><span class="p">)</span>
        <span class="n">methodorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">methodorder</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">printtools</span><span class="o">.</span><span class="n">progressbar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">methodorder</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.doit"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated! Use method |HydPy.simulate| instead.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import HydPy</span>
<span class="sd">        &gt;&gt;&gt; from unittest import mock</span>
<span class="sd">        &gt;&gt;&gt; with mock.patch.object(HydPy, &quot;simulate&quot;) as mocked:</span>
<span class="sd">        ...     hp = HydPy(&quot;test&quot;)</span>
<span class="sd">        ...     hp.doit()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.HydPyDeprecationWarning: \</span>
<span class="sd">Method `doit` of class `HydPy` is deprecated.  \</span>
<span class="sd">Use method `simulate` instead.</span>
<span class="sd">        &gt;&gt;&gt; mocked.call_args_list</span>
<span class="sd">        [call()]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Method `doit` of class `HydPy` is deprecated.  &quot;</span>
            <span class="s2">&quot;Use method `simulate` instead.&quot;</span><span class="p">,</span>
            <span class="n">exceptiontools</span><span class="o">.</span><span class="n">HydPyDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_allseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_allseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Allow all current |IOSequence| objects to handle time-series</span>
<span class="sd">        data via property |IOSequence.series|, depending on argument</span>
<span class="sd">        `ramflag` either in RAM (|True|) on disk (|False|).</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_modelseries</span><span class="p">(</span><span class="n">ramflag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_nodeseries</span><span class="p">(</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_modelseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_modelseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for model sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_allseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_inputseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_inputseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_inputseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for model input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_inputseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_fluxseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_fluxseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_fluxseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for model flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_fluxseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_stateseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_stateseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_stateseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for model state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">prepare_stateseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_nodeseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_nodeseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for node sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_allseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_simseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_simseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_simseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.prepare_obsseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.prepare_obsseries">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_obsseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ramflag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.prepare_allseries| specialised</span>
<span class="sd">        for observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">prepare_obsseries</span><span class="p">(</span><span class="n">ramflag</span><span class="o">=</span><span class="n">ramflag</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydPy.save_allseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_allseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Write the time-series data of all current |IOSequence| objects</span>
<span class="sd">        at once to the external data file(s).</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_nodeseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_modelseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_modelseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for model sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_allseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_inputseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_inputseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_inputseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for model input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_inputseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_fluxseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_fluxseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_fluxseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for model flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_fluxseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_stateseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_stateseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_stateseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for model state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_stateseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_nodeseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_nodeseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for node sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_allseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_simseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_simseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_simseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.save_obsseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.save_obsseries">[docs]</a>    <span class="k">def</span> <span class="nf">save_obsseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.save_modelseries| specialised</span>
<span class="sd">        for observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">save_obsseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_allseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_allseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_allseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Read the time-series data of all current |IOSequence| objects</span>
<span class="sd">        at once from the external data file(s).</span>

<span class="sd">        See the main documentation on class |HydPy| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_modelseries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_nodeseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_modelseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_modelseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_modelseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for model sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_allseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_inputseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_inputseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_inputseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for model input sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_inputseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_fluxseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_fluxseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_fluxseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for model flux sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">save_fluxseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_stateseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_stateseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_stateseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for model state sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">load_stateseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_nodeseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_nodeseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_nodeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for node sequences.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_allseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_simseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_simseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_simseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for simulation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_simseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="HydPy.load_obsseries"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.HydPy.load_obsseries">[docs]</a>    <span class="k">def</span> <span class="nf">load_obsseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An alternative method for |HydPy.load_modelseries| specialised</span>
<span class="sd">        for observation sequences of nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">load_obsseries</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="create_directedgraph"><a class="viewcode-back" href="../../../hydpytools.html#hydpy.core.hydpytools.create_directedgraph">[docs]</a><span class="k">def</span> <span class="nf">create_directedgraph</span><span class="p">(</span>
    <span class="n">devices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">HydPy</span><span class="p">,</span> <span class="s2">&quot;selectiontools.Selection&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a directed graph based on the given devices.&quot;&quot;&quot;</span>
    <span class="n">digraph</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">digraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">devices</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
    <span class="n">digraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">devices</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">devices</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">inlets</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">digraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">outlets</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
            <span class="n">digraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">digraph</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.core.hydpytools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>