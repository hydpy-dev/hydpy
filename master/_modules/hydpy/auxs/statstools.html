<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.auxs.statstools &#8212; HydPy 6.3dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=127cebf3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    
    <script src="../../../_static/documentation_options.js?v=6fd2034b"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.statstools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example_projects.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference_manual.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.statstools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module implements statistical functionalities frequently used in hydrological</span>
<span class="sd">modelling.&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hydpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">devicetools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.auxs</span><span class="w"> </span><span class="kn">import</span> <span class="n">validtools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">seriestools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">timetools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core.typingtools</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">special</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">pandas</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">OptionalImport</span><span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;pandas&quot;</span><span class="p">],</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="n">optimize</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">OptionalImport</span><span class="p">(</span><span class="s2">&quot;optimize&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;scipy.optimize&quot;</span><span class="p">],</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="n">special</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">OptionalImport</span><span class="p">(</span><span class="s2">&quot;special&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;scipy.special&quot;</span><span class="p">],</span> <span class="nb">locals</span><span class="p">())</span>


<div class="viewcode-block" id="SimObs">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SimObs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimObs</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A named tuple containing one array of simulated and one array of observed</span>
<span class="sd">    values.&quot;&quot;&quot;</span>

    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorFloat</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorFloat</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_series</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">date_ranges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">,</span> <span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs and date_ranges as arguments&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_series</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span> <span class="n">months</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs and month as arguments&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_series</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">date_ranges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">,</span> <span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node and date_ranges as arguments&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_series</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">months</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node and month as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="filter_series">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.filter_series">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;filter the given series&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_series</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">date_ranges</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="p">(</span>
        <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">,</span> <span class="n">timetools</span><span class="o">.</span><span class="n">DateConstrArg</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">months</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filter time series for the given date ranges or months.</span>

<span class="sd">    Often, we want to apply objective functions like |nse| on a subset of the available</span>
<span class="sd">    simulated and observed values.  The function |filter_series| helps to extract the</span>
<span class="sd">    relevant data either by data ranges or by months.  Common examples are to pass a</span>
<span class="sd">    single date range to ignore the first non-optimal values of a warm-up period, to</span>
<span class="sd">    pass a set of date ranges to focus on certain events or to pass a set of months to</span>
<span class="sd">    perform a seasonal analysis.</span>

<span class="sd">    To show how |filter_series| works, we prepare a daily initialisation time grid</span>
<span class="sd">    spanning two hydrological years:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import filter_series, pub, Node</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;2001-11-01&quot;, &quot;2003-11-01&quot;, &quot;1d&quot;</span>

<span class="sd">    Next, we prepare a |Node| object and assign some constantly increasing and</span>
<span class="sd">    decreasing values to its `simulation` and the `observation` series, respectively:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; node = Node(&quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; node.prepare_allseries()</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.sim.series = numpy.arange(1, 2*365+1)</span>
<span class="sd">    &gt;&gt;&gt; node.sequences.obs.series = numpy.arange(2*365, 0, -1)</span>

<span class="sd">    First, we select data of arbitrary sub-periods via the `data_ranges` argument.</span>
<span class="sd">    Each data range consists of the start-point and the end-point of a sub-period.</span>
<span class="sd">    Here, we choose all values that belong to 31 October or 1 November (note that</span>
<span class="sd">    unsorted data ranges are acceptable):</span>

<span class="sd">    &gt;&gt;&gt; date_ranges = [(&quot;2001-11-01&quot;, &quot;2001-11-02&quot;),</span>
<span class="sd">    ...                (&quot;2002-10-31&quot;, &quot;2002-11-02&quot;),</span>
<span class="sd">    ...                (&quot;2003-10-31&quot;, &quot;2003-11-01&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; results = filter_series(node=node, date_ranges=date_ranges)</span>

<span class="sd">    |filter_series| returns the data within index-sorted |pandas.Series| objects (note</span>
<span class="sd">    that the index addresses the left boundary of each time step):</span>

<span class="sd">    &gt;&gt;&gt; results.sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2001-11-01      1.0</span>
<span class="sd">    2002-10-31    365.0</span>
<span class="sd">    2002-11-01    366.0</span>
<span class="sd">    2003-10-31    730.0</span>
<span class="sd">    Name: sim...</span>
<span class="sd">    &gt;&gt;&gt; results.obs   # doctest: +ELLIPSIS</span>
<span class="sd">    2001-11-01    730.0</span>
<span class="sd">    2002-10-31    366.0</span>
<span class="sd">    2002-11-01    365.0</span>
<span class="sd">    2003-10-31      1.0</span>
<span class="sd">    Name: obs...</span>

<span class="sd">    To help avoiding possible hard-to-find errors, |filter_series| performs the</span>
<span class="sd">    following checks:</span>

<span class="sd">    &gt;&gt;&gt; date_ranges = [(&quot;2001-10-31&quot;, &quot;2003-11-01&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; filter_series(node=node, date_ranges=date_ranges)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to filter the given series, the following error occurred: \</span>
<span class="sd">The given date (2001-10-31 00:00:00) is before the first date of the initialisation \</span>
<span class="sd">period (2001-11-01 00:00:00).</span>

<span class="sd">    &gt;&gt;&gt; date_ranges = [(&quot;2001-11-01&quot;, &quot;2003-11-02&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; filter_series(node=node, date_ranges=date_ranges)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to filter the given series, the following error occurred: \</span>
<span class="sd">The given date (2003-11-02 00:00:00) is behind the last date of the initialisation \</span>
<span class="sd">period (2003-11-01 00:00:00).</span>

<span class="sd">    &gt;&gt;&gt; date_ranges = [(&quot;2001-11-02&quot;, &quot;2001-11-02&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; filter_series(node=node, date_ranges=date_ranges)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to filter the given series, the following error occurred: \</span>
<span class="sd">The given first date `2001-11-02 00:00:00` is not before than the given last date \</span>
<span class="sd">`2001-11-02 00:00:00`.</span>

<span class="sd">    Note that function |filter_series| does not remove any duplicates:</span>

<span class="sd">    &gt;&gt;&gt; date_ranges = [(&quot;2001-11-01&quot;, &quot;2001-11-05&quot;),</span>
<span class="sd">    ...                (&quot;2001-11-01&quot;, &quot;2001-11-02&quot;),</span>
<span class="sd">    ...                (&quot;2001-11-04&quot;, &quot;2001-11-06&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; sim = filter_series(node=node, date_ranges=date_ranges).sim</span>
<span class="sd">    &gt;&gt;&gt; sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2001-11-01    1.0</span>
<span class="sd">    2001-11-01    1.0</span>
<span class="sd">    2001-11-02    2.0</span>
<span class="sd">    2001-11-03    3.0</span>
<span class="sd">    2001-11-04    4.0</span>
<span class="sd">    2001-11-04    4.0</span>
<span class="sd">    2001-11-05    5.0</span>
<span class="sd">    Name: sim...</span>

<span class="sd">    Instead of date ranges, one can specify months via integer numbers.  We begin with</span>
<span class="sd">    selecting October (10) and November (11) individually:</span>

<span class="sd">    &gt;&gt;&gt; sim = filter_series(node=node, months=[11]).sim</span>
<span class="sd">    &gt;&gt;&gt; len(sim)</span>
<span class="sd">    60</span>
<span class="sd">    &gt;&gt;&gt; sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2001-11-01      1.0</span>
<span class="sd">    2001-11-02      2.0</span>
<span class="sd">    ...</span>
<span class="sd">    2002-11-29    394.0</span>
<span class="sd">    2002-11-30    395.0</span>
<span class="sd">    Name: sim...</span>

<span class="sd">    &gt;&gt;&gt; sim = filter_series(node=node, months=[10]).sim</span>
<span class="sd">    &gt;&gt;&gt; len(sim)</span>
<span class="sd">    62</span>
<span class="sd">    &gt;&gt;&gt; sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2002-10-01    335.0</span>
<span class="sd">    2002-10-02    336.0</span>
<span class="sd">    ...</span>
<span class="sd">    2003-10-30    729.0</span>
<span class="sd">    2003-10-31    730.0</span>
<span class="sd">    Name: sim...</span>

<span class="sd">    One can select multiple months, which neither need to be sorted nor consecutive:</span>

<span class="sd">    &gt;&gt;&gt; sim = filter_series(node=node, months=[4, 1]).sim</span>
<span class="sd">    &gt;&gt;&gt; len(sim)</span>
<span class="sd">    122</span>
<span class="sd">    &gt;&gt;&gt; sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2002-01-01     62.0</span>
<span class="sd">    2002-01-02     63.0</span>
<span class="sd">    ...</span>
<span class="sd">    2003-04-29    545.0</span>
<span class="sd">    2003-04-30    546.0</span>
<span class="sd">    Name: sim...</span>

<span class="sd">    Note that you are also free to either pass the `sim` and `obs` series directly</span>
<span class="sd">    instead of a `node` (see function |prepare_arrays| for further information):</span>

<span class="sd">    &gt;&gt;&gt; xs = node.sequences.sim.series</span>
<span class="sd">    &gt;&gt;&gt; ys = node.sequences.obs.series</span>
<span class="sd">    &gt;&gt;&gt; filter_series(sim=xs, obs=ys, months=[4, 1]).sim   # doctest: +ELLIPSIS</span>
<span class="sd">    2002-01-01     62.0</span>
<span class="sd">    2002-01-02     63.0</span>
<span class="sd">    ...</span>
<span class="sd">    2003-04-29    545.0</span>
<span class="sd">    2003-04-30    546.0</span>
<span class="sd">    Name: sim...</span>

<span class="sd">    Missing or double information for arguments `date_ranges` and `months` results in</span>
<span class="sd">    the following error messages:</span>

<span class="sd">    &gt;&gt;&gt; filter_series(node=node)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to filter the given series, the following error occurred: \</span>
<span class="sd">You need to define either the `date_ranges` or `months` argument, but none of them is \</span>
<span class="sd">given.</span>

<span class="sd">    &gt;&gt;&gt; filter_series(node=node, date_ranges=[], months=[])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to filter the given series, the following error occurred: \</span>
<span class="sd">You need to define either the `date_ranges` or `months` argument, but both of them are \</span>
<span class="sd">given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataframe</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">init</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">tg</span><span class="o">.</span><span class="n">firstdate</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">tg</span><span class="o">.</span><span class="n">lastdate</span><span class="o">.</span><span class="n">datetime</span> <span class="o">-</span> <span class="n">tg</span><span class="o">.</span><span class="n">stepsize</span><span class="o">.</span><span class="n">timedelta</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">tg</span><span class="o">.</span><span class="n">stepsize</span><span class="o">.</span><span class="n">timedelta</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dataframe_selected</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">date_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">months</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">date_range</span> <span class="ow">in</span> <span class="n">date_ranges</span><span class="p">:</span>
            <span class="n">date0</span> <span class="o">=</span> <span class="n">tg</span><span class="p">[</span><span class="n">tg</span><span class="p">[</span><span class="n">date_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">date1</span> <span class="o">=</span> <span class="n">tg</span><span class="p">[</span><span class="n">tg</span><span class="p">[</span><span class="n">date_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="k">if</span> <span class="n">date0</span> <span class="o">&lt;</span> <span class="n">tg</span><span class="o">.</span><span class="n">firstdate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given date (</span><span class="si">{</span><span class="n">date0</span><span class="si">}</span><span class="s2">) is before the first date of the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;initialisation period (</span><span class="si">{</span><span class="n">tg</span><span class="o">.</span><span class="n">firstdate</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">date1</span> <span class="o">&gt;</span> <span class="n">tg</span><span class="o">.</span><span class="n">lastdate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given date (</span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2">) is behind the last date of the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;initialisation period (</span><span class="si">{</span><span class="n">tg</span><span class="o">.</span><span class="n">lastdate</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">date0</span> <span class="o">&gt;=</span> <span class="n">date1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given first date `</span><span class="si">{</span><span class="n">date0</span><span class="si">}</span><span class="s2">` is not before than the given &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;last date `</span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">date0</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;iso1&quot;</span><span class="p">)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="p">(</span><span class="n">date1</span> <span class="o">-</span> <span class="n">tg</span><span class="o">.</span><span class="n">stepsize</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;iso1&quot;</span><span class="p">)</span>
            <span class="n">selected_dates</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>  <span class="c1"># type: ignore[misc]</span>
            <span class="n">dataframe_selected</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">selected_dates</span><span class="p">,</span> <span class="n">dataframe_selected</span><span class="p">])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">date_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">months</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="n">months</span><span class="p">:</span>
            <span class="n">selected_dates</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">month</span><span class="p">)]</span>
            <span class="n">dataframe_selected</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">selected_dates</span><span class="p">,</span> <span class="n">dataframe_selected</span><span class="p">])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">date_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">months</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You need to define either the `date_ranges` or `months` &quot;</span>
            <span class="s2">&quot;argument, but none of them is given.&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You need to define either the `date_ranges` or `months` argument, but &quot;</span>
            <span class="s2">&quot;both of them are given.&quot;</span>
        <span class="p">)</span>
    <span class="n">dataframe_selected</span> <span class="o">=</span> <span class="n">dataframe_selected</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">SimObs</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">dataframe_selected</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">],</span> <span class="n">obs</span><span class="o">=</span><span class="n">dataframe_selected</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">])</span></div>



<div class="viewcode-block" id="prepare_arrays">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.prepare_arrays">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prepare_arrays</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimObs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare and return two |numpy| arrays based on the given arguments.</span>

<span class="sd">    Note that many functions provided by module |statstools| apply function</span>
<span class="sd">    |prepare_arrays| internally (e.g. |nse|).  But you can also use it manually, as</span>
<span class="sd">    shown in the following examples.</span>

<span class="sd">    Function |prepare_arrays| can extract time series data from |Node| objects.  To set</span>
<span class="sd">    up an example for this, we define an initialisation period and prepare a |Node|</span>
<span class="sd">    object:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub, Node, round_, nan</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;01.01.2000&quot;, &quot;07.01.2000&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; node = Node(&quot;test&quot;)</span>

<span class="sd">    Next, we assign some values to the `simulation` and the `observation` sequences of</span>
<span class="sd">    the node:</span>

<span class="sd">    &gt;&gt;&gt; node.prepare_allseries()</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">    ...     node.sequences.sim.series = 1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    ...     node.sequences.obs.series = 4.0, 5.0, nan, nan, nan, 6.0</span>

<span class="sd">    Now we can pass the node object to function |prepare_arrays| and get the</span>
<span class="sd">    (unmodified) time series data:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import prepare_arrays</span>
<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, 5.0, nan, nan, nan, 6.0</span>

<span class="sd">    Alternatively, we can pass directly any iterable (e.g. |list| and |tuple| objects)</span>
<span class="sd">    containing the `simulated` and `observed` data:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(sim=list(node.sequences.sim.series),</span>
<span class="sd">    ...                         obs=tuple(node.sequences.obs.series))</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, nan, nan, nan, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, 5.0, nan, nan, nan, 6.0</span>

<span class="sd">    The optional `skip_nan` flag allows skipping all values, which are not numbers.</span>
<span class="sd">    Note that |prepare_arrays| returns only those pairs of `simulated` and `observed`</span>
<span class="sd">    values that do not contain any `nan` value:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node, skip_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, 6.0</span>

<span class="sd">    Additionally, you can use the `skip_notpositive` option to filter out zero and</span>
<span class="sd">    negative values:</span>

<span class="sd">    &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">    ...     node.sequences.sim.series = 1.0, 0.0, nan, -1.0, 2.0, 3.0</span>
<span class="sd">    ...     node.sequences.obs.series = 4.0, 5.0, nan, -2.0, 0.0, 6.0</span>
<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node, skip_notpositive=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, nan, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, nan, 6.0</span>

<span class="sd">    You can even combine `skip_nan` and `skip_notpositive`:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node, skip_notpositive=True, skip_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, 6.0</span>

<span class="sd">    If you are interested in analysing a sub-period, adapt the global |Timegrids.eval_|</span>
<span class="sd">    |Timegrid| beforehand.  When passing a |Node| object, function |prepare_arrays|</span>
<span class="sd">    then returns the data of the current evaluation sub-period only:</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.dates = &quot;02.01.2000&quot;, &quot;06.01.2000&quot;</span>
<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    0.0, nan, -1.0, 2.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    5.0, nan, -2.0, 0.0</span>

<span class="sd">    Suppose one instead passes the simulation and observation time series directly</span>
<span class="sd">    (which possibly fit the evaluation period already).  In that case, function</span>
<span class="sd">    |prepare_arrays| ignores the current |Timegrids.eval_| |Timegrid| by default:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(sim=arrays.sim, obs=arrays.obs)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    0.0, nan, -1.0, 2.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    5.0, nan, -2.0, 0.0</span>

<span class="sd">    Use the `subperiod` argument to deviate from the default behaviour:</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(node=node, subperiod=False)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    1.0, 0.0, nan, -1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    4.0, 5.0, nan, -2.0, 0.0, 6.0</span>

<span class="sd">    &gt;&gt;&gt; arrays = prepare_arrays(sim=arrays.sim, obs=arrays.obs, subperiod=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.sim)</span>
<span class="sd">    0.0, nan, -1.0, 2.0</span>
<span class="sd">    &gt;&gt;&gt; round_(arrays.obs)</span>
<span class="sd">    5.0, nan, -2.0, 0.0</span>

<span class="sd">    The final examples show the error messages returned in case of invalid combinations</span>
<span class="sd">    of input arguments:</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Neither a `Node` object is passed to argument `node` nor are arrays \</span>
<span class="sd">passed to arguments `sim` and `obs`.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(sim=node.sequences.sim.series, node=node)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Values are passed to both arguments `sim` and `node`, which is not \</span>
<span class="sd">allowed.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(obs=node.sequences.obs.series, node=node)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Values are passed to both arguments `obs` and `node`, which is not \</span>
<span class="sd">allowed.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(sim=node.sequences.sim.series)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: A value is passed to argument `sim` but no value is passed to argument \</span>
<span class="sd">`obs`.</span>

<span class="sd">    &gt;&gt;&gt; prepare_arrays(obs=node.sequences.obs.series)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: A value is passed to argument `obs` but no value is passed to argument \</span>
<span class="sd">`sim`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Values are passed to both arguments `sim` and `node`, which is not &quot;</span>
                <span class="s2">&quot;allowed.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Values are passed to both arguments `obs` and `node`, which is not &quot;</span>
                <span class="s2">&quot;allowed.&quot;</span>
            <span class="p">)</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">series</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">series</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;A value is passed to argument `sim` but no value is passed to argument &quot;</span>
            <span class="s2">&quot;`obs`.&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;A value is passed to argument `obs` but no value is passed to argument &quot;</span>
            <span class="s2">&quot;`sim`.&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Neither a `Node` object is passed to argument `node` nor are arrays &quot;</span>
            <span class="s2">&quot;passed to arguments `sim` and `obs`.&quot;</span>
        <span class="p">)</span>
    <span class="n">sim_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
    <span class="n">obs_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subperiod</span> <span class="ow">or</span> <span class="p">((</span><span class="n">subperiod</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">evalindices</span>
        <span class="n">sim_</span> <span class="o">=</span> <span class="n">sim_</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>
        <span class="n">obs_</span> <span class="o">=</span> <span class="n">obs_</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">skip_nan</span><span class="p">:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs_</span><span class="p">)))</span>
        <span class="n">sim_</span> <span class="o">=</span> <span class="n">sim_</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="n">obs_</span> <span class="o">=</span> <span class="n">obs_</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">skip_notpositive</span><span class="p">:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">sim_</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">sim_</span> <span class="o">=</span> <span class="n">sim_</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="n">obs_</span> <span class="o">=</span> <span class="n">obs_</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">SimObs</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">)</span></div>



<div class="viewcode-block" id="Criterion">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.Criterion">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Criterion</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Callback protocol for efficiency criteria like |nse|.&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
        <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rmse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rmse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="rmse">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.rmse">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the root-mean-square error&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rmse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the root-mean-square error.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import rmse, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(rmse(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(rmse(sim=[1.0, 2.0, 3.0], obs=[0.5, 2.0, 4.5]))</span>
<span class="sd">    0.912871</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |rmse|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">sim_</span> <span class="o">-</span> <span class="n">obs_</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="nse">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.nse">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the Nash-Sutcliffe efficiency&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the efficiency criteria after Nash &amp; Sutcliffe.</span>

<span class="sd">    If the simulated values predict the observed values and the average observed value</span>
<span class="sd">    (regarding the mean square error), the NSE value is zero:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import nse, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(nse(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(nse(sim=[0.0, 2.0, 4.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>

<span class="sd">    For worse and better agreement, the NSE is negative or positive, respectively:</span>

<span class="sd">    &gt;&gt;&gt; round_(nse(sim=[3.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(nse(sim=[1.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.5</span>

<span class="sd">    The highest possible value is one:</span>

<span class="sd">    &gt;&gt;&gt; round_(nse(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |nse|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
        <span class="nb">float</span><span class="p">,</span>
        <span class="mf">1.0</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sim_</span> <span class="o">-</span> <span class="n">obs_</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs_</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs_</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
    <span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="nse_log">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.nse_log">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the log-Nash-Sutcliffe efficiency&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the efficiency criteria after Nash &amp; Sutcliffe for logarithmic values.</span>

<span class="sd">    The following calculations replicate those in the documentation for the |nse|</span>
<span class="sd">    function, but with exponentiated values.  Hence, the results are identical:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import nse_log, round_</span>
<span class="sd">    &gt;&gt;&gt; from numpy import exp</span>
<span class="sd">    &gt;&gt;&gt; round_(nse_log(sim=exp([2.0, 2.0, 2.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(nse_log(sim=exp([0.0, 2.0, 4.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.0</span>

<span class="sd">    &gt;&gt;&gt; round_(nse_log(sim=exp([3.0, 2.0, 1.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    -3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(nse_log(sim=exp([1.0, 2.0, 2.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.5</span>

<span class="sd">    &gt;&gt;&gt; round_(nse_log(sim=exp([1.0, 2.0, 3.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    1.0</span>

<span class="sd">    Zero and negative values can prevent the successful application of |nse_log|:</span>

<span class="sd">    &gt;&gt;&gt; import warnings</span>
<span class="sd">    &gt;&gt;&gt; with warnings.catch_warnings():</span>
<span class="sd">    ...     warnings.filterwarnings(&quot;ignore&quot;)</span>
<span class="sd">    ...     round_(nse_log(sim=[-1.0, 1.0, 2.0, 3.0], obs=[1.0, 0.0, 1.0, 2.0]))</span>
<span class="sd">    nan</span>

<span class="sd">    You may want to activate the `skip_notpositive` option in such cases:</span>

<span class="sd">    &gt;&gt;&gt; round_(</span>
<span class="sd">    ...     nse_log(</span>
<span class="sd">    ...         sim=[-1.0, 1.0, 2.0, 3.0],</span>
<span class="sd">    ...         obs=[1.0, 0.0, 2.0, 3.0],</span>
<span class="sd">    ...         skip_notpositive=True,</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |nse_log|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span>
        <span class="n">skip_notpositive</span><span class="o">=</span><span class="n">skip_notpositive</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nse</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="fdc_nse">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.fdc_nse">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate the flow duration curve Nash-Sutcliffe efficiency&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the efficiency criteria after Nash &amp; Sutcliffe based on sorted</span>
<span class="sd">    simulation and observation data (such as when comparing flow duration curves).</span>

<span class="sd">    |fdc_nse| sorts the simulation and the observation data independently.  Hence, it</span>
<span class="sd">    compares their statistical distributions only and ignores any differences in the</span>
<span class="sd">    temporal occurrence of individual values:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import fdc_nse, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse(sim=[3.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>

<span class="sd">    Except for its blindness regarding temporal patterns, |fdc_nse| works like |nse|:</span>

<span class="sd">    &gt;&gt;&gt; round_(fdc_nse(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse(sim=[0.0, 2.0, 4.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse(sim=[1.0, 4.0, 5.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse(sim=[1.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.5</span>

<span class="sd">    See the documentation on function |prepare_arrays| for additional instructions on</span>
<span class="sd">    using |fdc_nse|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nse</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="fdc_nse_log">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.fdc_nse_log">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate the logarithmic flow duration curve Nash-Sutcliffe efficiency&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fdc_nse_log</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_notpositive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the efficiency criteria after Nash &amp; Sutcliffe based on sorted</span>
<span class="sd">    logarithmic simulation and observation data (such as when comparing logarithmic</span>
<span class="sd">    flow duration curves).</span>

<span class="sd">    The following calculations replicate those in the documentation for the |fdc_nse|</span>
<span class="sd">    function, but with exponentiated values.  Hence, the results are identical:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import fdc_nse_log, round_</span>
<span class="sd">    &gt;&gt;&gt; from numpy import exp</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse_log(sim=exp([3.0, 2.0, 1.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    1.0</span>

<span class="sd">    &gt;&gt;&gt; round_(fdc_nse_log(sim=exp([2.0, 2.0, 2.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse_log(sim=exp([0.0, 2.0, 4.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse_log(sim=exp([1.0, 4.0, 5.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    -3.0</span>
<span class="sd">    &gt;&gt;&gt; round_(fdc_nse_log(sim=exp([1.0, 2.0, 2.0]), obs=exp([1.0, 2.0, 3.0])))</span>
<span class="sd">    0.5</span>

<span class="sd">    Zero and negative values can prevent the successful application of |fdc_nse_log|:</span>

<span class="sd">    &gt;&gt;&gt; import warnings</span>
<span class="sd">    &gt;&gt;&gt; with warnings.catch_warnings():</span>
<span class="sd">    ...     warnings.filterwarnings(&quot;ignore&quot;)</span>
<span class="sd">    ...     round_(fdc_nse_log(sim=[-1.0, 1.0, 2.0, 3.0], obs=[1.0, 0.0, 1.0, 2.0]))</span>
<span class="sd">    nan</span>

<span class="sd">    You may want to activate the `skip_notpositive` option in such cases:</span>

<span class="sd">    &gt;&gt;&gt; round_(</span>
<span class="sd">    ...     fdc_nse_log(</span>
<span class="sd">    ...         sim=[-1.0, 1.0, 2.0, 3.0],</span>
<span class="sd">    ...         obs=[1.0, 0.0, 2.0, 3.0],</span>
<span class="sd">    ...         skip_notpositive=True,</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for additional instructions on</span>
<span class="sd">    using |fdc_nse_log|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span>
        <span class="n">skip_notpositive</span><span class="o">=</span><span class="n">skip_notpositive</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nse_log</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr2</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr2</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="corr2">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.corr2">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the R-Error&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr2</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the coefficient of determination via the square of the coefficient of</span>
<span class="sd">    correlation according to Bravais-Pearson.</span>

<span class="sd">    For perfect positive or negative correlation, |corr2| returns 1:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import corr2, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(corr2(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(corr2(sim=[3.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>

<span class="sd">    If there is no correlation at all, |corr2| returns 0:</span>

<span class="sd">    &gt;&gt;&gt; round_(corr2(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 1.0]))</span>
<span class="sd">    0.0</span>

<span class="sd">    An intermediate example:</span>

<span class="sd">    &gt;&gt;&gt; round_(corr2(sim=[2.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.75</span>

<span class="sd">    Take care if there is no variation in one of the data series.  Then the correlation</span>
<span class="sd">    coefficient is not defined, and |corr2| returns |numpy.nan|:</span>

<span class="sd">    &gt;&gt;&gt; round_(corr2(sim=[2.0, 2.0, 2.0], obs=[2.0, 2.0, 3.0]))</span>
<span class="sd">    nan</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |corr2|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kge</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kge</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="kge">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.kge">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the Kling-Gupta-Efficiency&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kge</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the Kling-Gupta efficiency according to :cite:t:`ref-Kling2012`.</span>

<span class="sd">    For a perfect fit, |kge| returns one:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import  kge, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(kge(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>

<span class="sd">    In each of the following three examples, only one of the KGE components deviates</span>
<span class="sd">    from one:</span>

<span class="sd">    &gt;&gt;&gt; round_(kge(sim=[3.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))  # imperfect correlation</span>
<span class="sd">    -1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(kge(sim=[3.0, 2.0, 1.0], obs=[6.0, 4.0, 2.0]))  # imperfect average</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; round_(kge(sim=[3.0, 2.0, 1.0], obs=[4.0, 2.0, 0.0]))  # imperfect variation</span>
<span class="sd">    0.5</span>

<span class="sd">    Finally, a mixed example, where all components deviate from one:</span>

<span class="sd">    &gt;&gt;&gt; round_(kge(sim=[3.0, 2.0, 1.0], obs=[2.0, 2.0, 1.0]))</span>
<span class="sd">    0.495489</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |kge|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m_sim</span><span class="p">,</span> <span class="n">m_obs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="n">s_sim</span><span class="p">,</span> <span class="n">s_obs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">m_sim</span> <span class="o">/</span> <span class="n">m_obs</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_sim</span> <span class="o">/</span> <span class="n">m_sim</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">s_obs</span> <span class="o">/</span> <span class="n">m_obs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_abs</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_abs</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="bias_abs">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.bias_abs">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the absolute bias&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_abs</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the absolute difference between the means of the simulated and the</span>
<span class="sd">    observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import bias_abs, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[5.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_abs(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |bias_abs|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim_</span> <span class="o">-</span> <span class="n">obs_</span><span class="p">))</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_rel</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_rel</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="bias_rel">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.bias_rel">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the relative bias&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_rel</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the relative difference between the means of the simulated and the</span>
<span class="sd">    observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import bias_rel, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[5.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; round_(bias_rel(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -0.5</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |bias_rel|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">std_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">std_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="std_ratio">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.std_ratio">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the standard deviation ratio&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">std_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the ratio between the standard deviation of the simulated and the</span>
<span class="sd">    observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_, std_ratio</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[1.0, 1.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(std_ratio(sim=[0.0, 3.0, 6.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    2.0</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |std_ratio|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">var_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">var_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="var_ratio">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.var_ratio">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the variation coefficient ratio&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">var_ratio</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the ratio between the variation coefficients of the simulated and the</span>
<span class="sd">    observed values.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_, var_ratio</span>
<span class="sd">    &gt;&gt;&gt; round_(var_ratio(sim=[1.0, 2.0, 3.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(var_ratio(sim=[1.0, 2.0, 3.0], obs=[0.0, 1.0, 2.0]))</span>
<span class="sd">    -0.5</span>
<span class="sd">    &gt;&gt;&gt; round_(var_ratio(sim=[1.0, 2.0, 3.0], obs=[0.0, 2.0, 4.0]))</span>
<span class="sd">    -0.5</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |var_ratio|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">var_sim</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span>
    <span class="n">var_obs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">var_sim</span> <span class="o">/</span> <span class="n">var_obs</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="corr">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.corr">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the Pearson correlation coefficient&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">corr</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the product-moment correlation coefficient after Pearson.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import corr, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[0.5, 1.0, 1.5], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[4.0, 2.0, 0.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    -1.0</span>
<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[1.0, 2.0, 1.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    0.0</span>

<span class="sd">    Take care if there is no variation in one of the data series.  Then the correlation</span>
<span class="sd">    coefficient is not defined, and |corr| returns |numpy.nan|:</span>

<span class="sd">    &gt;&gt;&gt; round_(corr(sim=[2.0, 2.0, 2.0], obs=[1.0, 2.0, 3.0]))</span>
<span class="sd">    nan</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for use of function |corr|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sim_</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">obs_</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_pars_sepd</span><span class="p">(</span><span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">w_beta</span> <span class="o">=</span> <span class="n">gamma1</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma2</span><span class="o">**</span><span class="mf">1.5</span>
    <span class="n">c_beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma1</span> <span class="o">/</span> <span class="n">gamma2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))</span>
    <span class="n">m_1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma1</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">gamma2</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">m_2</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">mu_xi</span> <span class="o">=</span> <span class="n">m_1</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">xi</span><span class="p">)</span>
    <span class="n">sigma_xi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">m_2</span> <span class="o">-</span> <span class="n">m_1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m_2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu_xi</span><span class="p">,</span> <span class="n">sigma_xi</span><span class="p">,</span> <span class="n">w_beta</span><span class="p">,</span> <span class="n">c_beta</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pars_h</span><span class="p">(</span><span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sim</span><span class="p">:</span> <span class="n">VectorFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">sigma1</span> <span class="o">*</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sim</span><span class="p">))</span> <span class="o">+</span> <span class="n">sigma2</span> <span class="o">*</span> <span class="n">sim</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_pdf</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_pdf</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="hsepd_pdf">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd_pdf">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate the probability densities with the heteroskedastic skewed exponential &quot;</span>
    <span class="s2">&quot;power distribution&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_pdf</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the probability densities based on the heteroskedastic skewed</span>
<span class="sd">    exponential power distribution.</span>

<span class="sd">    For convenience, we store the required parameters of the probability density</span>
<span class="sd">    function as well as the simulated and observed values in a dictionary:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd_pdf, round_</span>
<span class="sd">    &gt;&gt;&gt; general = {&quot;sigma1&quot;: 0.2,</span>
<span class="sd">    ...            &quot;sigma2&quot;: 0.0,</span>
<span class="sd">    ...            &quot;xi&quot;: 1.0,</span>
<span class="sd">    ...            &quot;beta&quot;: 0.0,</span>
<span class="sd">    ...            &quot;sim&quot;: numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...            &quot;obs&quot;: numpy.full(31, 25.0)}</span>

<span class="sd">    The following test function allows for varying one parameter and prints some and</span>
<span class="sd">    plots all the probability density values corresponding to different simulated</span>
<span class="sd">    values:</span>

<span class="sd">    &gt;&gt;&gt; def test(**kwargs):</span>
<span class="sd">    ...     from matplotlib import pyplot</span>
<span class="sd">    ...     special = general.copy()</span>
<span class="sd">    ...     name, values = list(kwargs.items())[0]</span>
<span class="sd">    ...     results = numpy.zeros((len(general[&quot;sim&quot;]), len(values)+1))</span>
<span class="sd">    ...     results[:, 0] = general[&quot;sim&quot;]</span>
<span class="sd">    ...     for jdx, value in enumerate(values):</span>
<span class="sd">    ...         special[name] = value</span>
<span class="sd">    ...         results[:, jdx+1] = hsepd_pdf(**special)</span>
<span class="sd">    ...         pyplot.plot(results[:, 0], results[:, jdx+1],</span>
<span class="sd">    ...                     label=&quot;%s=%.1f&quot; % (name, value))</span>
<span class="sd">    ...     pyplot.legend()</span>
<span class="sd">    ...     for idx, result in enumerate(results):</span>
<span class="sd">    ...         if not (idx % 5):</span>
<span class="sd">    ...             round_(result)</span>

<span class="sd">    When varying `beta`, the resulting probabilities correspond to the Laplace</span>
<span class="sd">    distribution (1.0), normal distribution (0.0), and the uniform distribution (-1.0),</span>
<span class="sd">    respectively.  Note that we use -0.99 instead of -1.0 for approximating the uniform</span>
<span class="sd">    distribution to prevent from running into numerical problems, which are not solved</span>
<span class="sd">    yet:</span>

<span class="sd">    &gt;&gt;&gt; test(beta=[1.0, 0.0, -0.99])</span>
<span class="sd">    10.0, 0.002032, 0.000886, 0.0</span>
<span class="sd">    15.0, 0.008359, 0.010798, 0.0</span>
<span class="sd">    20.0, 0.034382, 0.048394, 0.057739</span>
<span class="sd">    25.0, 0.141421, 0.079788, 0.057739</span>
<span class="sd">    30.0, 0.034382, 0.048394, 0.057739</span>
<span class="sd">    35.0, 0.008359, 0.010798, 0.0</span>
<span class="sd">    40.0, 0.002032, 0.000886, 0.0</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>

<span class="sd">    When varying `xi`, the resulting density is negatively skewed (0.2), symmetric</span>
<span class="sd">    (1.0), and positively skewed (5.0), respectively:</span>

<span class="sd">    &gt;&gt;&gt; test(xi=[0.2, 1.0, 5.0])</span>
<span class="sd">    10.0, 0.0, 0.000886, 0.003175</span>
<span class="sd">    15.0, 0.0, 0.010798, 0.012957</span>
<span class="sd">    20.0, 0.092845, 0.048394, 0.036341</span>
<span class="sd">    25.0, 0.070063, 0.079788, 0.070063</span>
<span class="sd">    30.0, 0.036341, 0.048394, 0.092845</span>
<span class="sd">    35.0, 0.012957, 0.010798, 0.0</span>
<span class="sd">    40.0, 0.003175, 0.000886, 0.0</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>

<span class="sd">    In the above examples, the actual `sigma` (5.0) is calculated by multiplying</span>
<span class="sd">    `sigma1` (0.2) with the mean simulated value (25.0) internally.  This can be done</span>
<span class="sd">    for modelling homoscedastic errors.  Instead, `sigma2` is multiplied with the</span>
<span class="sd">    individual simulated values to account for heteroscedastic errors.  With increasing</span>
<span class="sd">    values of `sigma2`, the resulting densities are modified as follows:</span>

<span class="sd">    &gt;&gt;&gt; test(sigma2=[0.0, 0.1, 0.2])</span>
<span class="sd">    10.0, 0.000886, 0.002921, 0.005737</span>
<span class="sd">    15.0, 0.010798, 0.018795, 0.022831</span>
<span class="sd">    20.0, 0.048394, 0.044159, 0.037988</span>
<span class="sd">    25.0, 0.079788, 0.053192, 0.039894</span>
<span class="sd">    30.0, 0.048394, 0.04102, 0.032708</span>
<span class="sd">    35.0, 0.010798, 0.023493, 0.023493</span>
<span class="sd">    40.0, 0.000886, 0.011053, 0.015771</span>

<span class="sd">    .. testsetup::</span>

<span class="sd">        &gt;&gt;&gt; from matplotlib import pyplot</span>
<span class="sd">        &gt;&gt;&gt; pyplot.close()</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |hsepd_pdf|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">_pars_h</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">sim_</span><span class="p">)</span>
    <span class="n">mu_xi</span><span class="p">,</span> <span class="n">sigma_xi</span><span class="p">,</span> <span class="n">w_beta</span><span class="p">,</span> <span class="n">c_beta</span> <span class="o">=</span> <span class="n">_pars_sepd</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">obs_</span><span class="p">,</span> <span class="n">sim_</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigmas</span>
    <span class="n">a_xi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">mu_xi</span> <span class="o">+</span> <span class="n">sigma_xi</span> <span class="o">*</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.0</span>
    <span class="n">a_xi</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xi</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_xi</span> <span class="o">+</span> <span class="n">sigma_xi</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">idxs</span><span class="p">]))</span>
    <span class="n">a_xi</span><span class="p">[</span><span class="o">~</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">xi</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_xi</span> <span class="o">+</span> <span class="n">sigma_xi</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="o">~</span><span class="n">idxs</span><span class="p">]))</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigma_xi</span> <span class="o">/</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_beta</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">cast</span><span class="p">(</span><span class="n">VectorFloat</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c_beta</span> <span class="o">*</span> <span class="n">a_xi</span> <span class="o">**</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))))</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">sigmas</span>
    <span class="k">return</span> <span class="n">ps</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_hsepd_manual</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">hsepd_pdf</span><span class="p">(</span>
        <span class="n">sigma1</span><span class="o">=</span><span class="n">sigma1</span><span class="p">,</span>
        <span class="n">sigma2</span><span class="o">=</span><span class="n">sigma2</span><span class="p">,</span>
        <span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ps</span><span class="p">[</span><span class="n">ps</span> <span class="o">&lt;</span> <span class="mf">1e-200</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-200</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">)))</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_manual</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as argument&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_manual</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments&quot;&quot;&quot;</span>


<div class="viewcode-block" id="hsepd_manual">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd_manual">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate an objective value based on method `hsepd_manual`&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd_manual</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the mean of the logarithmic probability densities of the</span>
<span class="sd">    heteroskedastic skewed exponential power distribution.</span>

<span class="sd">    The following examples stem from the documentation of function |hsepd_pdf|, which</span>
<span class="sd">    is used by function |hsepd_manual|.  The first one deals with a heteroscedastic</span>
<span class="sd">    normal distribution:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd_manual, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.2,</span>
<span class="sd">    ...                     xi=1.0, beta=0.0,</span>
<span class="sd">    ...                     sim=numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...                     obs=numpy.full(31, 25.0)))</span>
<span class="sd">    -3.682842</span>

<span class="sd">    Too small probability density values are set to 1e-200 before calculating their</span>
<span class="sd">    logarithm (which means that the lowest possible value returned by function</span>
<span class="sd">    |hsepd_manual| is approximately -460):</span>

<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.0,</span>
<span class="sd">    ...                     xi=1.0, beta=-0.99,</span>
<span class="sd">    ...                     sim=numpy.arange(10.0, 41.0),</span>
<span class="sd">    ...                     obs=numpy.full(31, 25.0)))</span>
<span class="sd">    -209.539335</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |hsepd_manual|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span>
    <span class="k">return</span> <span class="n">_hsepd_manual</span><span class="p">(</span>
        <span class="n">sigma1</span><span class="o">=</span><span class="n">sigma1</span><span class="p">,</span>
        <span class="n">sigma2</span><span class="o">=</span><span class="n">sigma2</span><span class="p">,</span>
        <span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inits</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_pars</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as argument, do not return parameters&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inits</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_pars</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sim and obs as arguments, do return parameters&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">inits</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_pars</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as an arguments, do not return parameters&quot;&quot;&quot;</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">inits</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_pars</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;node as an argument, do return parameters&quot;&quot;&quot;</span>


<div class="viewcode-block" id="hsepd">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.hsepd">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate an objective value based on method `hsepd`&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hsepd</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sim</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">VectorInputFloat</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inits</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_pars</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the mean of the logarithmic probability densities of the</span>
<span class="sd">    heteroskedastic skewed exponential power distribution.</span>

<span class="sd">    Function |hsepd| serves the same purpose as function |hsepd_manual| but tries to</span>
<span class="sd">    estimate the parameters of the heteroscedastic skewed exponential distribution via</span>
<span class="sd">    an optimisation algorithm.  This is shown by generating a random sample.  One</span>
<span class="sd">    thousand simulated values are scattered around the observed (true) value of 10.0</span>
<span class="sd">    with a standard deviation of 2.0:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.seed(0)</span>
<span class="sd">    &gt;&gt;&gt; sim = numpy.random.normal(10.0, 2.0, 1000)</span>
<span class="sd">    &gt;&gt;&gt; obs = numpy.full(1000, 10.0)</span>

<span class="sd">    First, as a reference, we calculate the &quot;true&quot; value based on function</span>
<span class="sd">    |hsepd_manual| and the correct distribution parameters:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import hsepd, hsepd_manual, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(hsepd_manual(sigma1=0.2, sigma2=0.0, xi=1.0, beta=0.0, sim=sim, obs=obs))</span>
<span class="sd">    -2.100093</span>

<span class="sd">    When using function |hsepd|, the returned value is even a little &quot;better&quot;:</span>

<span class="sd">    &gt;&gt;&gt; round_(hsepd(sim=sim, obs=obs))</span>
<span class="sd">    -2.09983</span>

<span class="sd">    This is due to the deviation from the random sample to its theoretical distribution.</span>
<span class="sd">    This is reflected by small differences between the estimated values and the</span>
<span class="sd">    theoretical values of `sigma1` (0.2), `sigma2` (0.0), `xi` (1.0), and `beta` (0.0).</span>
<span class="sd">    The estimated values are returned in the mentioned order by enabling the</span>
<span class="sd">    `return_pars` option:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True)</span>
<span class="sd">    &gt;&gt;&gt; round_(pars, decimals=5)</span>
<span class="sd">    0.19966, 0.0, 0.96836, 0.0188</span>

<span class="sd">    There is no guarantee that the optimisation numerical optimisation algorithm</span>
<span class="sd">    underlying function |hsepd| will always find the parameters resulting in the</span>
<span class="sd">    largest value returned by function |hsepd_manual|.  You can increase its robustness</span>
<span class="sd">    (and decrease computation time) by supplying close initial parameter values:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True,</span>
<span class="sd">    ...                     inits=(0.2, 0.0, 1.0, 0.0))</span>
<span class="sd">    &gt;&gt;&gt; round_(pars, decimals=5)</span>
<span class="sd">    0.19966, 0.0, 0.96836, 0.0188</span>

<span class="sd">    However, the following example shows a case when this strategy results in worse</span>
<span class="sd">    results:</span>

<span class="sd">    &gt;&gt;&gt; value, pars = hsepd(sim=sim, obs=obs, return_pars=True,</span>
<span class="sd">    ...                     inits=(0.0, 0.2, 1.0, 0.0))</span>
<span class="sd">    &gt;&gt;&gt; round_(value)</span>
<span class="sd">    -2.174492</span>
<span class="sd">    &gt;&gt;&gt; round_(pars)</span>
<span class="sd">    0.0, 0.213179, 1.705485, 0.505112</span>

<span class="sd">    See the documentation on function |prepare_arrays| for some additional instructions</span>
<span class="sd">    for using |hsepd|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">pars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform the actual optimisation problem into a function to be minimised</span>
<span class="sd">        and apply parameter constraints.&quot;&quot;&quot;</span>
        <span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="o">*</span><span class="n">pars</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">_hsepd_manual</span><span class="p">(</span>
            <span class="n">sigma1</span><span class="o">=</span><span class="n">sigma1</span><span class="p">,</span>
            <span class="n">sigma2</span><span class="o">=</span><span class="n">sigma2</span><span class="p">,</span>
            <span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
            <span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span>
            <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span>
            <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">constrain</span><span class="p">(</span>
        <span class="n">sigma1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">xi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply constraints on the given parameter values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">sigma2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="mf">10.0</span><span class="p">),</span>
            <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">),</span> <span class="mf">5.0</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">sim_</span><span class="p">,</span> <span class="n">obs_</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="n">skip_nan</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">inits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">original_values</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span>
        <span class="n">transform</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="ow">not</span> <span class="n">silent</span>
    <span class="p">)</span>
    <span class="n">constrained_values</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="o">*</span><span class="n">original_values</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_hsepd_manual</span><span class="p">(</span>
        <span class="n">sigma1</span><span class="o">=</span><span class="n">constrained_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">sigma2</span><span class="o">=</span><span class="n">constrained_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">xi</span><span class="o">=</span><span class="n">constrained_values</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">constrained_values</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim_</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs_</span><span class="p">,</span>
        <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">subperiod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_pars</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">constrained_values</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="calc_mean_time">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.calc_mean_time">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span><span class="s2">&quot;calculate the weighted mean time&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_mean_time</span><span class="p">(</span><span class="n">timepoints</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the weighted mean of the given time points.</span>

<span class="sd">    With equal given weights, the result is simply the mean of the given time points:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import calc_mean_time, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time(timepoints=[3.0, 7.0], weights=[2.0, 2.0]))</span>
<span class="sd">    5.0</span>

<span class="sd">    With different weights, the resulting time is shifted to the larger ones:</span>

<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time(timepoints=[3.0, 7.0], weights=[1.0, 3.0]))</span>
<span class="sd">    6.0</span>

<span class="sd">    Or, in the most extreme case:</span>

<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time(timepoints=[3.0, 7.0], weights=[0.0, 4.0]))</span>
<span class="sd">    7.0</span>

<span class="sd">    There are some checks for input plausibility, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time(timepoints=[3.0, 7.0], weights=[-2.0, 2.0])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to calculate the weighted mean time, the following error \</span>
<span class="sd">occurred: For the following objects, at least one value is negative: weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timepoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">timepoints</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_equal_shape</span><span class="p">(</span><span class="n">timepoints</span><span class="o">=</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_non_negative</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span></div>



<div class="viewcode-block" id="calc_mean_time_deviation">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.calc_mean_time_deviation">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;calculate the weighted time deviation from mean time&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_mean_time_deviation</span><span class="p">(</span>
    <span class="n">timepoints</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
    <span class="n">mean_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the weighted deviation of the given timepoints from their mean time.</span>

<span class="sd">    With equal given weights, the is simply the standard deviation of the given time</span>
<span class="sd">    points:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import calc_mean_time_deviation, round_</span>
<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3.0, 7.0], weights=[2.0, 2.0]))</span>
<span class="sd">    2.0</span>

<span class="sd">    One can pass a precalculated mean time:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(</span>
<span class="sd">    ...     timepoints=[3.0, 7.0], weights=[2.0, 2.0], mean_time=4.0))</span>
<span class="sd">    2.236068</span>

<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3.0, 7.0], weights=[1.0, 3.0]))</span>
<span class="sd">    1.732051</span>

<span class="sd">    Or, in the most extreme case:</span>

<span class="sd">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3.0, 7.0], weights=[0.0, 4.0]))</span>
<span class="sd">    0.0</span>

<span class="sd">    There are some checks for input plausibility, e.g.:</span>

<span class="sd">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3.0, 7.0], weights=[-2.0, 2.0])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to calculate the weighted time deviation from mean time, \</span>
<span class="sd">the following error occurred: For the following objects, at least one value is \</span>
<span class="sd">negative: weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timepoints_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">timepoints</span><span class="p">)</span>
    <span class="n">weights_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">timepoints</span><span class="p">,</span> <span class="n">weights</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_equal_shape</span><span class="p">(</span><span class="n">timepoints</span><span class="o">=</span><span class="n">timepoints_</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights_</span><span class="p">)</span>
    <span class="n">validtools</span><span class="o">.</span><span class="n">test_non_negative</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mean_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean_time</span> <span class="o">=</span> <span class="n">calc_mean_time</span><span class="p">(</span><span class="n">timepoints_</span><span class="p">,</span> <span class="n">weights_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
        <span class="nb">float</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights_</span><span class="p">,</span> <span class="p">(</span><span class="n">timepoints_</span> <span class="o">-</span> <span class="n">mean_time</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_</span><span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="calc_weights">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.calc_weights">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_weights</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate &quot;statistical&quot; weights for all given nodes based on the number of</span>
<span class="sd">    observations within the evaluation period.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import calc_weights, nan, Node, print_vector, pub</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;01.01.2000&quot;, &quot;04.01.2000&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; test1, test2 = Node(&quot;test1&quot;), Node(&quot;test2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; test1.prepare_obsseries()</span>
<span class="sd">    &gt;&gt;&gt; test1.sequences.obs.series = 4.0, 5.0, 6.0</span>
<span class="sd">    &gt;&gt;&gt; test2.prepare_obsseries()</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">    ...     test2.sequences.obs.series = 3.0, nan, 1.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(calc_weights((test1, test2)).values())</span>
<span class="sd">    0.6, 0.4</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.lastdate = &quot;03.01.2000&quot;</span>
<span class="sd">    &gt;&gt;&gt; print_vector(calc_weights((test1, test2)).values())</span>
<span class="sd">    0.666667, 0.333333</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.firstdate = &quot;02.01.2000&quot;</span>
<span class="sd">    &gt;&gt;&gt; print_vector(calc_weights((test1, test2)).values())</span>
<span class="sd">    1.0, 0.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(calc_weights((test1,)).values())</span>
<span class="sd">    1.0</span>

<span class="sd">    &gt;&gt;&gt; print_vector(calc_weights((test2,)).values())</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: None of the given nodes (test2) provides any observation values for \</span>
<span class="sd">the current evaluation period (Timegrid(&quot;02.01.2000 00:00:00&quot;, &quot;03.01.2000 00:00:00&quot;, \</span>
<span class="sd">&quot;1d&quot;)).</span>

<span class="sd">    &gt;&gt;&gt; calc_weights(())</span>
<span class="sd">    {}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nonnans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">nonnans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">evalseries</span><span class="p">)))</span>
    <span class="n">sum_nonnan</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nonnans</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sum_nonnan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;None of the given nodes (</span><span class="si">{</span><span class="n">names</span><span class="si">}</span><span class="s2">) provides any observation values for &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;the current evaluation period (</span><span class="si">{</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">eval_</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">g</span><span class="p">:</span> <span class="n">w</span> <span class="o">/</span> <span class="n">sum_nonnan</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nonnans</span><span class="p">)}</span></div>



<div class="viewcode-block" id="SummaryRow">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRow">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SummaryRow</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for |SummaryRowSimple| and |SummaryRowWeighted|.</span>

<span class="sd">    The documentation on function |print_evaluationtable| explains the intended use of</span>
<span class="sd">    the available |SummaryRow| subclasses.  Here, we demonstrate their configuration in</span>
<span class="sd">    more detail based on the subclass |SummaryRowSimple|, which calculates simple</span>
<span class="sd">    (non-weighted) averages.  You only need to pass the name and the node objects</span>
<span class="sd">    relevant for the corresponding row for initialising:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Nodes, print_vector, SummaryRowSimple</span>
<span class="sd">    &gt;&gt;&gt; n1, n2, n3 = Nodes(&quot;n1&quot;, &quot;n2&quot;, &quot;n3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; s = SummaryRowSimple(&quot;s&quot;, (n1, n2))</span>

<span class="sd">    |print_evaluationtable| calculates values for all node-criterion combinations and</span>
<span class="sd">    passes them to |SummaryRow.summarise_criteria|.  If the nodes passed to</span>
<span class="sd">    |print_evaluationtable| and the |SummaryRow| instance are identical,</span>
<span class="sd">    |SummaryRowSimple| just calculates the average for each criterion:</span>

<span class="sd">    &gt;&gt;&gt; print_vector(s.summarise_criteria(2, {n1: [1.0, 2.0], n2: [3.0, 6.0]}))</span>
<span class="sd">    2.0, 4.0</span>

<span class="sd">    Nodes passed to |print_evaluationtable| but not to |SummaryRow| are considered</span>
<span class="sd">    irrelevant for the corresponding row and thus not taken into account for averaging:</span>

<span class="sd">    &gt;&gt;&gt; print_vector(s.summarise_criteria(1, {n1: [1.0], n2: [3.0], n3: [5.0]}))</span>
<span class="sd">    2.0</span>

<span class="sd">    If the |SummaryRow| instance expects a node not passed to |print_evaluationtable|,</span>
<span class="sd">    it raises the following error:</span>

<span class="sd">    &gt;&gt;&gt; print_vector(s.summarise_criteria(1, {n1: [1.0]}))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to calculate the values of row `s` based on class \</span>
<span class="sd">`SummaryRowSimple`, the following error occurred: Missing information for node `n2`.</span>

<span class="sd">    |SummaryRow.summarise_criteria| generally returns |numpy.nan| values for all</span>
<span class="sd">    |SummaryRow| instances that select no nodes:</span>

<span class="sd">    &gt;&gt;&gt; SummaryRowSimple(&quot;s&quot;, ()).summarise_criteria(2, {n1: [1.0, 2.0]})</span>
<span class="sd">    (nan, nan)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">_nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

<div class="viewcode-block" id="SummaryRow.summarise_criteria">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRow.summarise_criteria">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarise_criteria</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nmb_criteria</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node2values</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summarise the results of all criteria.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nmb_criteria</span> <span class="o">*</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">summaries</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmb_criteria</span><span class="p">):</span>
                <span class="n">node2value</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node2value</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2values</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Missing information for node `</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
                <span class="n">summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summarise_criterion</span><span class="p">(</span><span class="n">node2value</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">summaries</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to calculate the values of row `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` based on &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;class `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="SummaryRow.summarise_criterion">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRow.summarise_criterion">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarise_criterion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node2value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summarise the values of a specific criterion.&quot;&quot;&quot;</span></div>
</div>



<div class="viewcode-block" id="SummaryRowSimple">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRowSimple">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SummaryRowSimple</span><span class="p">(</span><span class="n">SummaryRow</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to define additional &quot;summary rows&quot; in evaluation tables based on simple</span>
<span class="sd">    (non-weighted) averages.</span>

<span class="sd">    See the documentation on class |SummaryRow| for further information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SummaryRowSimple.summarise_criterion">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRowSimple.summarise_criterion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarise_criterion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node2value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the simple (non-weighted) average of all selected nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node2value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SummaryRowWeighted">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRowWeighted">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SummaryRowWeighted</span><span class="p">(</span><span class="n">SummaryRow</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to define additional &quot;summary rows&quot; in evaluation tables based on</span>
<span class="sd">    weighted averages.</span>

<span class="sd">    The documentation on class |SummaryRow| provides general information on using</span>
<span class="sd">    |SummaryRow| subclasses, while the following examples focus on the unique features</span>
<span class="sd">    of class |SummaryRowWeighted|.</span>

<span class="sd">    First, we prepare two nodes.  `n1` provides a complete and `n2` provides an</span>
<span class="sd">    incomplete observation time series:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import print_vector, pub, Node, nan</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;2000-01-01&quot;, &quot;2000-01-04&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; n1, n2 = Node(&quot;n1&quot;), Node(&quot;n2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; n1.prepare_obsseries()</span>
<span class="sd">    &gt;&gt;&gt; n1.sequences.obs.series = 4.0, 5.0, 6.0</span>
<span class="sd">    &gt;&gt;&gt; n2.prepare_obsseries()</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">    ...     n2.sequences.obs.series = 3.0, nan, 1.0</span>

<span class="sd">    We can pass predefined weighting coefficients to |SummaryRowWeighted|.  Then, the</span>
<span class="sd">    completeness of the observation series is irrelevant:</span>

<span class="sd">    &gt;&gt;&gt; sumrow = SummaryRowWeighted(&quot;sumrow&quot;, (n1, n2), (0.1, 0.9))</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sumrow.summarise_criteria(2, {n1: [-1.0, 2.0], n2: [1.0, 6.0]}))</span>
<span class="sd">    0.8, 5.6</span>

<span class="sd">    If we do not pass any weights, |SummaryRowWeighted| determines them automatically</span>
<span class="sd">    based on the number of available observations per node by invoking function</span>
<span class="sd">    |calc_weights|:</span>

<span class="sd">    &gt;&gt;&gt; sumrow = SummaryRowWeighted(&quot;sumrow&quot;, (n1, n2))</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sumrow.summarise_criteria(2, {n1: [-1.0, 2.0], n2: [1.0, 6.0]}))</span>
<span class="sd">    -0.2, 3.6</span>

<span class="sd">    |SummaryRowWeighted| reuses the internally calculated weights but updates them when</span>
<span class="sd">    the evaluation time grid changes in the meantime:</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.firstdate = &quot;2000-01-02&quot;</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sumrow.summarise_criteria(2, {n1: [-1.0, 2.0], n2: [1.0, 6.0]}))</span>
<span class="sd">    -0.333333, 3.333333</span>

<span class="sd">    |nan| values calculated for individual nodes due to completely missing observations</span>
<span class="sd">    within the evaluation period do not leak into the results of</span>
<span class="sd">    |SummaryRow.summarise_criteria| (if the corresponding weights are zero, as they</span>
<span class="sd">    should):</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.lastdate = &quot;2000-01-03&quot;</span>
<span class="sd">    &gt;&gt;&gt; print_vector(sumrow.summarise_criteria(2, {n1: [-1.0, 2.0], n2: [nan, nan]}))</span>
<span class="sd">    -1.0, 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_node2weight</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="n">_predefined</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_evaltimegrid</span><span class="p">:</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Timegrid</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evaltimegrid</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">eval_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predefined</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node2weight</span> <span class="o">=</span> <span class="n">calc_weights</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predefined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node2weight</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

<div class="viewcode-block" id="SummaryRowWeighted.summarise_criterion">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.SummaryRowWeighted.summarise_criterion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarise_criterion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node2value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the weighted average of all selected nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predefined</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaltimegrid</span> <span class="o">!=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">eval_</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node2weight</span> <span class="o">=</span> <span class="n">calc_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_evaltimegrid</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">timegrids</span><span class="o">.</span><span class="n">eval_</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">w</span> <span class="o">*</span> <span class="n">node2value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2weight</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span></div>
</div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">print_evaluationtable</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
    <span class="n">criteria</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">Criterion</span><span class="p">],</span>
    <span class="n">firstcellname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">nodenames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critnames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critfactors</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">critdigits</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">averagename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">summaryrows</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">SummaryRow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">filter_</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">missingvalue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">decimalseperator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">columnseparator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">file_</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">TextIO</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">print_evaluationtable</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
    <span class="n">criteria</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">Criterion</span><span class="p">],</span>
    <span class="n">firstcellname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">nodenames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critnames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critfactors</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">critdigits</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">averagename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">summaryrows</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">SummaryRow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">filter_</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">stepsize</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;daily&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;monthly&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;daily&quot;</span><span class="p">,</span>
    <span class="n">aggregator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">VectorInputFloat</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">missingvalue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">decimalseperator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">columnseparator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">file_</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">TextIO</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>


<div class="viewcode-block" id="print_evaluationtable">
<a class="viewcode-back" href="../../../statstools.html#hydpy.auxs.statstools.print_evaluationtable">[docs]</a>
<span class="nd">@objecttools</span><span class="o">.</span><span class="n">excmessage_decorator</span><span class="p">(</span>
    <span class="s2">&quot;evaluate the simulation results of some node objects&quot;</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">print_evaluationtable</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span>
    <span class="n">criteria</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">Criterion</span><span class="p">],</span>
    <span class="n">firstcellname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">nodenames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critnames</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">critfactors</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">critdigits</span><span class="p">:</span> <span class="n">Collection1</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">subperiod</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">averagename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">summaryrows</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="n">SummaryRow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">filter_</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">stepsize</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;daily&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;monthly&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">aggregator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">VectorInputFloat</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">missingvalue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">decimalseperator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">columnseparator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">file_</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">TextIO</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print a table containing the results of the given evaluation criteria for the</span>
<span class="sd">    given |Node| objects.</span>

<span class="sd">    First, we define two nodes with different simulation and observation data (see</span>
<span class="sd">    function |prepare_arrays| for some explanations):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub, Node, nan</span>
<span class="sd">    &gt;&gt;&gt; pub.timegrids = &quot;01.01.2000&quot;, &quot;04.01.2000&quot;, &quot;1d&quot;</span>
<span class="sd">    &gt;&gt;&gt; nodes = Node(&quot;test1&quot;), Node(&quot;test2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for node in nodes:</span>
<span class="sd">    ...     node.prepare_allseries()</span>
<span class="sd">    &gt;&gt;&gt; nodes[0].sequences.sim.series = 1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; nodes[0].sequences.obs.series = 4.0, 5.0, 6.0</span>
<span class="sd">    &gt;&gt;&gt; nodes[1].sequences.sim.series = 1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.checkseries(False):</span>
<span class="sd">    ...     nodes[1].sequences.obs.series = 3.0, nan, 1.0</span>

<span class="sd">    Selecting functions |corr| and |bias_abs| as evaluation criteria, function</span>
<span class="sd">    |print_evaluationtable| prints the following table:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import bias_abs, corr, print_evaluationtable</span>
<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs))</span>
<span class="sd">            corr   bias_abs</span>
<span class="sd">    test1   1.00      -3.00</span>
<span class="sd">    test2  -1.00       0.00</span>
<span class="sd">    mean    0.00      -1.50</span>

<span class="sd">    One can pass alternative names for the first cell, the node objects, the criteria</span>
<span class="sd">    functions, and the row containing the average values, as well as alternative column</span>
<span class="sd">    and decimal separators..  Also, one can use the `filter_` argument to suppress</span>
<span class="sd">    printing statistics in case of incomplete observation data.  In the following</span>
<span class="sd">    example, we set the minimum fraction of required data to 80 %:</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       firstcellname=&quot;nodes&quot;,</span>
<span class="sd">    ...                       nodenames=(&quot;first node&quot;, &quot;second node&quot;),</span>
<span class="sd">    ...                       critnames=(&quot;corrcoef&quot;, &quot;bias&quot;),</span>
<span class="sd">    ...                       critdigits=1,</span>
<span class="sd">    ...                       averagename=&quot;average&quot;,</span>
<span class="sd">    ...                       decimalseperator=&quot;,&quot;,</span>
<span class="sd">    ...                       columnseparator=&quot;;&quot;,</span>
<span class="sd">    ...                       filter_=0.8)</span>
<span class="sd">    nodes;corrcoef;bias</span>
<span class="sd">    first node;1,0;-3,0</span>
<span class="sd">    second node;-;-</span>
<span class="sd">    average;1,0;-3,0</span>

<span class="sd">    The number of assigned node objects and criteria functions must match the number of</span>
<span class="sd">    given alternative names:</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       nodenames=(&quot;first node&quot;,))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to evaluate the simulation results of some node objects, \</span>
<span class="sd">the following error occurred: 2 node objects are given which does not match with \</span>
<span class="sd">number of given alternative names being 1.</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       critnames=(&quot;corrcoef&quot;,))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to evaluate the simulation results of some node objects, \</span>
<span class="sd">the following error occurred: 2 criteria functions are given which does not match with \</span>
<span class="sd">number of given alternative names being 1.</span>

<span class="sd">    Set the `average` argument to |False| to omit the row containing the average values:</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       average=False)</span>
<span class="sd">            corr  bias_abs</span>
<span class="sd">    test1   1.00     -3.00</span>
<span class="sd">    test2  -1.00      0.00</span>

<span class="sd">    The `summaryrows` argument is a more flexible alternative to the standard averaging</span>
<span class="sd">    across nodes.  You can pass an arbitrary number of |SummaryRow| instances.  Their</span>
<span class="sd">    names define the descriptions in the first column.  Here, we include additional</span>
<span class="sd">    lines giving the complete averages for all nodes, averages for a subset of nodes</span>
<span class="sd">    (in fact, the &quot;average&quot; for the single node `test2`), automatically weighted</span>
<span class="sd">    averages (based on the number of available observations), and manually weighted</span>
<span class="sd">    averages (based on predefined weights):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import SummaryRowSimple, SummaryRowWeighted</span>
<span class="sd">    &gt;&gt;&gt; summaryrows = (SummaryRowSimple(&quot;complete&quot;, nodes),</span>
<span class="sd">    ...                SummaryRowSimple(&quot;selective&quot;, (nodes[1],)),</span>
<span class="sd">    ...                SummaryRowWeighted(&quot;automatically weighted&quot;, nodes),</span>
<span class="sd">    ...                SummaryRowWeighted(&quot;manually weighted&quot;, nodes, (0.1, 0.9)))</span>
<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       average=False,</span>
<span class="sd">    ...                       summaryrows=summaryrows)</span>
<span class="sd">                             corr  bias_abs</span>
<span class="sd">    test1                    1.00     -3.00</span>
<span class="sd">    test2                   -1.00      0.00</span>
<span class="sd">    complete                 0.00     -1.50</span>
<span class="sd">    selective               -1.00      0.00</span>
<span class="sd">    automatically weighted   0.20     -1.80</span>
<span class="sd">    manually weighted       -0.80     -0.30</span>

<span class="sd">    You can use the arguments `critfactors` and `critdigits` by passing either a single</span>
<span class="sd">    number or a sequence of criteria-specific numbers to modify the printed values:</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       critfactors=(10.0, 0.1),</span>
<span class="sd">    ...                       critdigits=1)</span>
<span class="sd">            corr  bias_abs</span>
<span class="sd">    test1   10.0      -0.3</span>
<span class="sd">    test2  -10.0       0.0</span>
<span class="sd">    mean     0.0      -0.2</span>

<span class="sd">    By default, function |print_evaluationtable| prints the statistics relevant for the</span>
<span class="sd">    actual evaluation period only:</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.dates = &quot;01.01.2000&quot;, &quot;02.01.2000&quot;</span>
<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs))</span>
<span class="sd">           corr  bias_abs</span>
<span class="sd">    test1     -     -3.00</span>
<span class="sd">    test2     -     -2.00</span>
<span class="sd">    mean      -     -2.50</span>

<span class="sd">    You can deviate from this default behaviour by setting the `subperiod` argument to</span>
<span class="sd">    |False|:</span>

<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       subperiod=False)</span>
<span class="sd">            corr  bias_abs</span>
<span class="sd">    test1   1.00     -3.00</span>
<span class="sd">    test2  -1.00      0.00</span>
<span class="sd">    mean    0.00     -1.50</span>

<span class="sd">    Use the `stepsize` argument (eventually in combination with argument `aggregator`)</span>
<span class="sd">    to print the statistics of previously aggregated time series.  See</span>
<span class="sd">    |aggregate_series| for further information.</span>

<span class="sd">    Here, the daily aggregation step size results in identical results as the original</span>
<span class="sd">    step size is also one day:</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_ = pub.timegrids.init</span>
<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       stepsize=&quot;daily&quot;,</span>
<span class="sd">    ...                       aggregator=&quot;mean&quot;)</span>
<span class="sd">            corr  bias_abs</span>
<span class="sd">    test1   1.00     -3.00</span>
<span class="sd">    test2  -1.00      0.00</span>
<span class="sd">    mean    0.00     -1.50</span>

<span class="sd">    For the monthly step size, the result table is empty due to the too-short</span>
<span class="sd">    initialisation period covering less than a month:</span>

<span class="sd">    &gt;&gt;&gt; pub.timegrids.eval_.dates = pub.timegrids.init.dates</span>
<span class="sd">    &gt;&gt;&gt; print_evaluationtable(nodes=nodes,  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...                       criteria=(corr, bias_abs),</span>
<span class="sd">    ...                       stepsize=&quot;monthly&quot;,</span>
<span class="sd">    ...                       aggregator=&quot;mean&quot;)</span>
<span class="sd">           corr  bias_abs</span>
<span class="sd">    test1     -         -</span>
<span class="sd">    test2     -         -</span>
<span class="sd">    mean      -         -</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodenames</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> node objects are given which does not match with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;number of given alternative names being </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">critnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">critnames</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span><span class="si">}</span><span class="s2"> criteria functions are given which does not match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with number of given alternative names being </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">critnames</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">critnames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">crit</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">crit</span><span class="p">))</span> <span class="k">for</span> <span class="n">crit</span> <span class="ow">in</span> <span class="n">criteria</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">critfactors</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">critfactors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">critfactors</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">critdigits</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">critdigits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">critdigits</span><span class="p">,)</span>
    <span class="n">formats</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;%.</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">f&quot;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">critdigits</span><span class="p">)</span>
    <span class="n">node2values</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">[</span><span class="n">devicetools</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="n">node2values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stepsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">seriestools</span><span class="o">.</span><span class="n">aggregate_series</span><span class="p">(</span>
                <span class="n">series</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">series</span><span class="p">,</span>
                <span class="n">stepsize</span><span class="o">=</span><span class="n">stepsize</span><span class="p">,</span>
                <span class="n">aggregator</span><span class="o">=</span><span class="n">aggregator</span><span class="p">,</span>
                <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">seriestools</span><span class="o">.</span><span class="n">aggregate_series</span><span class="p">(</span>
                <span class="n">series</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">sequences</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">series</span><span class="p">,</span>
                <span class="n">stepsize</span><span class="o">=</span><span class="n">stepsize</span><span class="p">,</span>
                <span class="n">aggregator</span><span class="o">=</span><span class="n">aggregator</span><span class="p">,</span>
                <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sim</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">prepare_arrays</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subperiod</span><span class="o">=</span><span class="n">subperiod</span><span class="p">)</span>
        <span class="n">availability</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">critfactor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">criteria</span><span class="p">,</span> <span class="n">critfactors</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">critfactor</span> <span class="o">*</span> <span class="n">criterion</span><span class="p">(</span><span class="n">sim</span><span class="o">=</span><span class="n">sim</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">skip_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">node2values</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node2values</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">availability</span> <span class="o">&lt;</span> <span class="n">filter_</span> <span class="k">else</span> <span class="n">node2values</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_write</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">printtarget_</span><span class="p">:</span> <span class="n">TextIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">printtarget_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">columnseparator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">printtarget_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">columnseparator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">decimalseperator</span><span class="p">))</span>
        <span class="n">printtarget_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_nmbs2strs</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">f</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">decimalseperator</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">,</span> <span class="n">missingvalue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">formats</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">get_printtarget</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span> <span class="k">as</span> <span class="n">printtarget</span><span class="p">:</span>
        <span class="n">_write</span><span class="p">(</span><span class="n">firstcellname</span><span class="p">,</span> <span class="n">critnames</span><span class="p">,</span> <span class="n">printtarget</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nodename</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodenames</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="n">_write</span><span class="p">(</span><span class="n">nodename</span><span class="p">,</span> <span class="n">_nmbs2strs</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">printtarget</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;Mean of empty slice&quot;</span><span class="p">)</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">_nmbs2strs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">_write</span><span class="p">(</span><span class="n">averagename</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">printtarget</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">summaryrow</span> <span class="ow">in</span> <span class="n">summaryrows</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">summaryrow</span><span class="o">.</span><span class="n">summarise_criteria</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">),</span> <span class="n">node2values</span><span class="p">)</span>
            <span class="n">_write</span><span class="p">(</span><span class="n">summaryrow</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_nmbs2strs</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">printtarget</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.statstools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2026, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>