
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.auxs.calibtools &#8212; HydPy 4.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.calibtools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.calibtools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module implements features for calibrating model parameters.</span>

<span class="sd">.. _`NLopt`: https://nlopt.readthedocs.io/en/latest/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TextIO</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>  <span class="c1"># type: ignore[misc]</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Protocol</span>  <span class="c1"># type: ignore[misc]</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span> <span class="nn">black</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># ...from hydpy</span>
<span class="kn">import</span> <span class="nn">hydpy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">devicetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">hydpytools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">masktools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">parametertools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">selectiontools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">timetools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">typingtools</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">variabletools</span>
<span class="kn">from</span> <span class="nn">hydpy.auxs</span> <span class="kn">import</span> <span class="n">iuhtools</span>

<span class="n">RuleType1</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;RuleType1&quot;</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Rule&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">RuleType2</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;RuleType2&quot;</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Rule&quot;</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="TargetFunction"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.TargetFunction">[docs]</a><span class="k">class</span> <span class="nc">TargetFunction</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Protocol class for the target function required by class</span>
<span class="sd">    |CalibrationInterface|.</span>

<span class="sd">    The target functions must calculate and return a floating-point number</span>
<span class="sd">    reflecting the quality of the current parameterisation of the models of</span>
<span class="sd">    the current project.  Often, as in the following example, the target</span>
<span class="sd">    function relies on objective functions as |nse|, applied on the time</span>
<span class="sd">    series of the |Sim| and |Obs| sequences handled by the |HydPy| object:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import HydPy, nse, TargetFunction</span>
<span class="sd">    &gt;&gt;&gt; class Target(TargetFunction):</span>
<span class="sd">    ...     def __init__(self, hp):</span>
<span class="sd">    ...         self.hp = hp</span>
<span class="sd">    ...     def __call__(self):</span>
<span class="sd">    ...         return sum(nse(node=node) for node in self.hp.nodes)</span>
<span class="sd">    &gt;&gt;&gt; target = Target(HydPy())</span>

<span class="sd">    See the documentation on class |CalibrationInterface| for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return some kind of efficience criterion.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Adaptor"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Adaptor">[docs]</a><span class="k">class</span> <span class="nc">Adaptor</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Protocol class for defining adoptors required by |Replace| objects.</span>

<span class="sd">    Often, one calibration parameter (represented by one |Replace| object)</span>
<span class="sd">    depends on other calibration parameters (represented by other |Replace|</span>
<span class="sd">    objects) or other &quot;real&quot; parameter values.  Please select an existing</span>
<span class="sd">    or define an individual adaptor and assign it to a |Replace| object to</span>
<span class="sd">    introduce such dependencies.</span>

<span class="sd">    See class |SumAdaptor| or class |FactorAdaptor| for concrete examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Modify the value(s) of the given target |Parameter| object.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="SumAdaptor"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.SumAdaptor">[docs]</a><span class="k">class</span> <span class="nc">SumAdaptor</span><span class="p">(</span><span class="n">Adaptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adaptor which calculates the sum of the values of multiple |Rule|</span>
<span class="sd">    objects and assigns it to the value(s) of the target |Parameter| object.</span>

<span class="sd">    Class |SumAdaptor| helps to introduce &quot;larger than&quot; relationships between</span>
<span class="sd">    calibration parameters.  A common use-case is the time of concentration</span>
<span class="sd">    of different runoff components.  The time of concentration of base flow</span>
<span class="sd">    should be larger than the one of direct runoff.  Accordingly, when</span>
<span class="sd">    modelling runoff concentration with linear storages, the recession</span>
<span class="sd">    coefficient of direct runoff should be larger. Principally, we could</span>
<span class="sd">    ensure this during a calibration process by defining two |Rule| objects</span>
<span class="sd">    with fixed non-overlapping parameter ranges.  For example, we could</span>
<span class="sd">    search for the best direct runoff delay between 1 and 5 days and the</span>
<span class="sd">    base flow delay between 5 and 100 days.  We demonstrate this for the</span>
<span class="sd">    recession coefficient parameters |hland_control.K| and |hland_control.K4|</span>
<span class="sd">    of application model |hland_v1| (assuming the nonlinearity parameter</span>
<span class="sd">    |hland_control.Alpha| to be zero):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import Replace, SumAdaptor</span>
<span class="sd">    &gt;&gt;&gt; k = Replace(</span>
<span class="sd">    ...     name=&quot;k&quot;,</span>
<span class="sd">    ...     parameter=&quot;k&quot;,</span>
<span class="sd">    ...     value=2.0**-1,</span>
<span class="sd">    ...     lower=5.0**-1,</span>
<span class="sd">    ...     upper=1.0**-1,</span>
<span class="sd">    ...     parameterstep=&quot;1d&quot;,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; k4 = Replace(</span>
<span class="sd">    ...     name=&quot;k4&quot;,</span>
<span class="sd">    ...     parameter=&quot;k4&quot;,</span>
<span class="sd">    ...     value=10.0**-1,</span>
<span class="sd">    ...     lower=100.0**-1,</span>
<span class="sd">    ...     upper=5.0**-1,</span>
<span class="sd">    ...     parameterstep=&quot;1d&quot;,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    To allow for non-fixed non-overlapping ranges, we can prepare a</span>
<span class="sd">    |SumAdaptor| object, knowing both our |Rule| objects, assign it</span>
<span class="sd">    the direct runoff-related |Rule| object, and, for example, set its</span>
<span class="sd">    lower boundary to zero:</span>

<span class="sd">    &gt;&gt;&gt; k.adaptor = SumAdaptor(k, k4)</span>
<span class="sd">    &gt;&gt;&gt; k.lower = 0.0</span>

<span class="sd">    Calling method |Replace.apply_value| of the |Replace| objects makes</span>
<span class="sd">    our |SumAdaptor| object apply the sum of the values of all of its</span>
<span class="sd">    |Rule| objects:</span>

<span class="sd">    &gt;&gt;&gt; control = hp.elements.land_dill.model.parameters.control</span>
<span class="sd">    &gt;&gt;&gt; k.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.parameterstep(&quot;1d&quot;):</span>
<span class="sd">    ...     control.k</span>
<span class="sd">    k(0.6)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rules</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;Rule&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">rules</span><span class="p">:</span> <span class="s2">&quot;Rule&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rules</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">))</span></div>


<div class="viewcode-block" id="FactorAdaptor"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.FactorAdaptor">[docs]</a><span class="k">class</span> <span class="nc">FactorAdaptor</span><span class="p">(</span><span class="n">Adaptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adaptor which calculates the product of the value of the parent</span>
<span class="sd">    |Replace| object and the value(s) of a given reference |Parameter| object</span>
<span class="sd">    and assigns it to the value(s) of the target |Parameter| object.</span>

<span class="sd">    Class |FactorAdaptor| helps to respect dependencies between model</span>
<span class="sd">    parameters.  If you, for example, aim at calibrating the permanent</span>
<span class="sd">    wilting point (|lland_control.PWP|) of model |lland_v1|, you need to</span>
<span class="sd">    make sure it always agrees with the maximum soil water storage</span>
<span class="sd">    (|lland_control.WMax|).  Especially, one should avoid permanent wilting</span>
<span class="sd">    points larger than total porosity.  Due to the high variability</span>
<span class="sd">    of soil properties within most catchments, it is no real option to</span>
<span class="sd">    define a fixed upper threshold for |lland_control.PWP|.  By using</span>
<span class="sd">    class |FactorAdaptor| you can instead calibrate a multiplication</span>
<span class="sd">    factor.  Setting the bounds of such a factor to 0.0 and 0.5, for example,</span>
<span class="sd">    would result in |lland_control.PWP| values ranging from zero up to half</span>
<span class="sd">    of |lland_control.WMax| for each respective response unit.</span>

<span class="sd">    To show how class |FactorAdaptor| works, we select another use-case</span>
<span class="sd">    based on the `Lahn` example project prepared by function</span>
<span class="sd">    |prepare_full_example_2|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">    |hland_v1| calculates the &quot;normal&quot; potential snow-melt with the</span>
<span class="sd">    degree-day factor |hland_control.CFMax|.  For glacial zones, it</span>
<span class="sd">    also calculates a separate potential glacier-melt with the additional</span>
<span class="sd">    degree-day factor |hland_control.GMelt|.  Suppose, we have</span>
<span class="sd">    |hland_control.CFMax| readily available for the different hydrological</span>
<span class="sd">    response units of the Lahn catchment.  We might find it useful to</span>
<span class="sd">    calibrate |hland_control.GMelt| based on the spatial pattern of</span>
<span class="sd">    |hland_control.CFMax|.  Therefore, we first define a |Replace| rule</span>
<span class="sd">    for parameter |hland_control.GMelt|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Replace, FactorAdaptor</span>
<span class="sd">    &gt;&gt;&gt; gmelt = Replace(</span>
<span class="sd">    ...     name=&quot;gmelt&quot;,</span>
<span class="sd">    ...     parameter=&quot;gmelt&quot;,</span>
<span class="sd">    ...     value=2.0,</span>
<span class="sd">    ...     lower=0.5,</span>
<span class="sd">    ...     upper=2.0,</span>
<span class="sd">    ...     parameterstep=&quot;1d&quot;,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    Second, we initialise a |FactorAdaptor| object based on target</span>
<span class="sd">    rule `gmelt` and our reference parameter |hland_control.CFMax| and</span>
<span class="sd">    assign it our rule object:</span>

<span class="sd">    &gt;&gt;&gt; gmelt.adaptor = FactorAdaptor(gmelt, &quot;cfmax&quot;)</span>

<span class="sd">    The `Dill` subcatchment, as the whole `Lahn` basin, does not contain</span>
<span class="sd">    any glaciers.  Hence it defines (identical) |hland_control.CFMax|</span>
<span class="sd">    values for the zones of type |hland_constants.FIELD| and</span>
<span class="sd">    |hland_constants.FOREST|, but must not specify any value for</span>
<span class="sd">    |hland_control.GMelt|:</span>

<span class="sd">    &gt;&gt;&gt; control = hp.elements.land_dill.model.parameters.control</span>
<span class="sd">    &gt;&gt;&gt; control.cfmax</span>
<span class="sd">    cfmax(field=4.55853, forest=2.735118)</span>
<span class="sd">    &gt;&gt;&gt; control.gmelt</span>
<span class="sd">    gmelt(nan)</span>

<span class="sd">    Next, we call method |Replace.apply_value| of the |Replace| object to</span>
<span class="sd">    apply the |FactorAdaptor| object on all relevant |hland_control.GMelt|</span>
<span class="sd">    instances of the `Lahn` catchment:</span>

<span class="sd">    &gt;&gt;&gt; gmelt.adaptor(control.gmelt)</span>

<span class="sd">    The string representation of the |hland_control.GMelt| instance of `Dill`</span>
<span class="sd">    catchment seems to indicate nothing happened:</span>

<span class="sd">    &gt;&gt;&gt; control.gmelt</span>
<span class="sd">    gmelt(nan)</span>

<span class="sd">    However, inspecting the individual values of the respective response</span>
<span class="sd">    units reveals the multiplication was successful:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import print_values</span>
<span class="sd">    &gt;&gt;&gt; print_values(control.gmelt.values)</span>
<span class="sd">    9.11706, 5.470236, 9.11706, 5.470236, 9.11706, 5.470236, 9.11706,</span>
<span class="sd">    5.470236, 9.11706, 5.470236, 9.11706, 5.470236</span>

<span class="sd">    Calculating values for response units that do not require these</span>
<span class="sd">    values can be misleading.  We can improve the situation by using</span>
<span class="sd">    the masks provided by the respective model, in our example mask</span>
<span class="sd">    |hland_masks.Glacier|.  To make this clearer, we set the  first six</span>
<span class="sd">    response units to |hland_control.ZoneType| |hland_constants.GLACIER|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.models.hland_v1 import *</span>
<span class="sd">    &gt;&gt;&gt; control.zonetype(GLACIER, GLACIER, GLACIER, GLACIER, GLACIER, GLACIER,</span>
<span class="sd">    ...                  FIELD, FOREST, ILAKE, FIELD, FOREST, ILAKE)</span>

<span class="sd">    We now can assign the |SumAdaptor| object to the direct runoff-related</span>
<span class="sd">    |Replace| object and, for example, set its lower boundary to zero:</span>

<span class="sd">    Now we create a new |FactorAdaptor| object, handling the same parameters</span>
<span class="sd">    but also the |hland_masks.Glacier| mask:</span>

<span class="sd">    &gt;&gt;&gt; gmelt.adaptor = FactorAdaptor(gmelt, &quot;cfmax&quot;, &quot;glacier&quot;)</span>

<span class="sd">    To be able to see the results of our new adaptor object, we change the</span>
<span class="sd">    values both of our reference parameter and our rule object:</span>

<span class="sd">    &gt;&gt;&gt; control.cfmax(field=5.0, forest=3.0, glacier=6.0)</span>
<span class="sd">    &gt;&gt;&gt; gmelt.value = 0.5</span>

<span class="sd">    The string representation of our target parameter shows that the</span>
<span class="sd">    glacier-related day degree factor of all glacier zones is now half as</span>
<span class="sd">    large as the snow-related one:</span>

<span class="sd">    &gt;&gt;&gt; gmelt.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; control.gmelt</span>
<span class="sd">    gmelt(3.0)</span>

<span class="sd">    Note that all remaining values (for zone types |hland_constants.FIELD|,</span>
<span class="sd">    |hland_constants.FOREST|, and |hland_constants.ILAKE| are still the same.</span>
<span class="sd">    This intended behaviour allows calibrating, for example, hydrological</span>
<span class="sd">    response units of different types with different rule objects:</span>

<span class="sd">    &gt;&gt;&gt; print_values(control.gmelt.values)</span>
<span class="sd">    3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 9.11706, 5.470236, 9.11706, 5.470236,</span>
<span class="sd">    9.11706, 5.470236</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rule</span><span class="p">:</span> <span class="s2">&quot;Rule&quot;</span>
    <span class="n">_reference</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="s2">&quot;Rule&quot;</span><span class="p">,</span>
        <span class="n">reference</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">masktools</span><span class="o">.</span><span class="n">BaseMask</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="o">=</span> <span class="n">rule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">reference</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">subpars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">get_submask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">NDIM</span> <span class="k">else</span> <span class="n">ref</span><span class="o">.</span><span class="n">value</span>
            <span class="n">target</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="Rule"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Rule">[docs]</a><span class="k">class</span> <span class="nc">Rule</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for defining calibration rules.</span>

<span class="sd">    Each |Rule| object relates one calibration parameter with some</span>
<span class="sd">    model parameters.  We select the class |Replace| as a concrete example</span>
<span class="sd">    for the following explanations and use the `Lahn` example project,</span>
<span class="sd">    which we prepare by calling function |prepare_full_example_2|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">    We define a |Rule| object supposed to replace the values of parameter</span>
<span class="sd">    |hland_control.FC| of application model |lland_v1|.  Note that argument</span>
<span class="sd">    `name` is the name of the rule itself, whereas the argument `parameter`</span>
<span class="sd">    is the name of the parameter:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">    &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    The following string representation shows us the full list of available</span>
<span class="sd">    arguments:</span>

<span class="sd">    &gt;&gt;&gt; rule</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;fc&quot;,</span>
<span class="sd">        parameter=&quot;fc&quot;,</span>
<span class="sd">        lower=-inf,</span>
<span class="sd">        upper=inf,</span>
<span class="sd">        parameterstep=None,</span>
<span class="sd">        value=100.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>

<span class="sd">    The initial value of parameter |hland_control.FC| is 206 mm:</span>

<span class="sd">    &gt;&gt;&gt; fc = hp.elements.land_lahn_1.model.parameters.control.fc</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(206.0)</span>

<span class="sd">    We can modify it by calling method |Rule.apply_value|:</span>

<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(100.0)</span>

<span class="sd">    You can change and apply the value at any time:</span>

<span class="sd">    &gt;&gt;&gt; rule.value = 200.0</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(200.0)</span>

<span class="sd">    Sometimes, one needs to make a difference between the original value</span>
<span class="sd">    to be calibrated and the actually applied value.  Therefore, (only)</span>
<span class="sd">    the |Replace| class allows defining custom &quot;adaptors&quot;. Prepare an</span>
<span class="sd">    |Adaptor| function and assign it to the relevant |Replace| object (see</span>
<span class="sd">    the documentation on class |SumAdaptor| or |FactorAdaptor| for more</span>
<span class="sd">    realistic examples):</span>

<span class="sd">    &gt;&gt;&gt; rule.adaptor = lambda target: target(2.0*rule.value)</span>

<span class="sd">    Now, our rule does not apply the original but the adapted calibration</span>
<span class="sd">    parameter value:</span>

<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(400.0)</span>

<span class="sd">    Use method |Rule.reset_parameters| to restore the original states of the</span>
<span class="sd">    affected parameters (&quot;original&quot; here means at the time of initialisation</span>
<span class="sd">    of the |Rule| object):</span>

<span class="sd">    &gt;&gt;&gt; rule.reset_parameters()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(206.0)</span>

<span class="sd">    The value of parameter |hland_control.FC| is not time-dependent.</span>
<span class="sd">    Any |Options.parameterstep| information given to its |Rule| object</span>
<span class="sd">    is ignored (note that we pass an example parameter object of</span>
<span class="sd">    type |hland_control.FC| instead of the string `fc` this time):</span>

<span class="sd">    &gt;&gt;&gt; Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=fc,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ...     parameterstep=&quot;1d&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;fc&quot;,</span>
<span class="sd">        parameter=&quot;fc&quot;,</span>
<span class="sd">        lower=-inf,</span>
<span class="sd">        upper=inf,</span>
<span class="sd">        parameterstep=None,</span>
<span class="sd">        value=100.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>

<span class="sd">    For time-dependent parameters, the rule queries the current global</span>
<span class="sd">    |Options.parameterstep| value, if you do not specify one explicitly</span>
<span class="sd">    (note that we pass the parameter type |hland_control.PercMax| this</span>
<span class="sd">    time):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.models.hland.hland_control import PercMax</span>
<span class="sd">    &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">    ...     name=&quot;percmax&quot;,</span>
<span class="sd">    ...     parameter=PercMax,</span>
<span class="sd">    ...     value=5.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    The |Rule| object internally handles, to avoid confusion, a copy of</span>
<span class="sd">    |Options.parameterstep|.</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">    &gt;&gt;&gt; pub.options.parameterstep = None</span>
<span class="sd">    &gt;&gt;&gt; rule</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;percmax&quot;,</span>
<span class="sd">        parameter=&quot;percmax&quot;,</span>
<span class="sd">        lower=-inf,</span>
<span class="sd">        upper=inf,</span>
<span class="sd">        parameterstep=&quot;1d&quot;,</span>
<span class="sd">        value=5.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; percmax = hp.elements.land_lahn_1.model.parameters.control.percmax</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.parameterstep(&quot;1d&quot;):</span>
<span class="sd">    ...     percmax</span>
<span class="sd">    percmax(5.0)</span>

<span class="sd">    Alternatively, you can pass a parameter step size yourself:</span>

<span class="sd">    &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">    ...     name=&quot;percmax&quot;,</span>
<span class="sd">    ...     parameter=&quot;percmax&quot;,</span>
<span class="sd">    ...     value=5.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ...     parameterstep=&quot;2d&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; with pub.options.parameterstep(&quot;1d&quot;):</span>
<span class="sd">    ...     percmax</span>
<span class="sd">    percmax(2.5)</span>

<span class="sd">    Missing parameter step-size information results in the following error:</span>

<span class="sd">    &gt;&gt;&gt; Replace(</span>
<span class="sd">    ...     name=&quot;percmax&quot;,</span>
<span class="sd">    ...     parameter=&quot;percmax&quot;,</span>
<span class="sd">    ...     value=5.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to initialise the `Replace` rule object \</span>
<span class="sd">`percmax`, the following error occurred: Rules which handle time-dependent \</span>
<span class="sd">parameters require information on the parameter timestep size.  Either \</span>
<span class="sd">assign it directly or define it via option `parameterstep`.</span>

<span class="sd">    With the following definition, the |Rule| object queries all |Element|</span>
<span class="sd">    objects handling |hland_v1| instances from the global |Selections|</span>
<span class="sd">    object `pub.selections`:</span>

<span class="sd">    &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; rule.elements</span>
<span class="sd">    Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;)</span>

<span class="sd">    Alternatively, you can specify selections by passing themselves or their</span>
<span class="sd">    names (the latter requires them to be a member of `pub.selections`):</span>

<span class="sd">    &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     selections=[pub.selections.headwaters, &quot;nonheadwaters&quot;],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; rule.elements</span>
<span class="sd">    Elements(&quot;land_dill&quot;, &quot;land_lahn_1&quot;, &quot;land_lahn_2&quot;, &quot;land_lahn_3&quot;)</span>

<span class="sd">    Without using the `model` argument, you must make sure the selected</span>
<span class="sd">    elements handle the correct model instance yourself:</span>

<span class="sd">    &gt;&gt;&gt; Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to initialise the `Replace` rule object \</span>
<span class="sd">`fc`, the following error occurred: Model `hstream_v1` of element \</span>
<span class="sd">`stream_dill_lahn_2` does not define a control parameter named `fc`.</span>

<span class="sd">    &gt;&gt;&gt; Replace(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     model=&quot;hstream_v1&quot;,</span>
<span class="sd">    ...     selections=[pub.selections.headwaters, &quot;nonheadwaters&quot;],</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: While trying to initialise the `Replace` rule object `fc`, \</span>
<span class="sd">the following error occurred: Object `Selections(&quot;headwaters&quot;, \</span>
<span class="sd">&quot;nonheadwaters&quot;)` does not handle any `hstream_v1` model instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="sd">&quot;&quot;&quot;The name of the |Rule| object.</span>

<span class="sd">    Often, the name of the target parameter, but this is arbitrary.&quot;&quot;&quot;</span>

    <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;Lower boundary value.</span>

<span class="sd">    No lower boundary corresponds to minus |numpy.inf|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;Upper boundary value.</span>

<span class="sd">    No upper boundary corresponds to plus |numpy.inf|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parametername</span><span class="p">:</span> <span class="nb">str</span>
    <span class="sd">&quot;&quot;&quot;The name of the addressed |Parameter| objects.&quot;&quot;&quot;</span>

    <span class="n">parametertype</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The type of the addressed |Parameter| objects.&quot;&quot;&quot;</span>

    <span class="n">elements</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span>
    <span class="sd">&quot;&quot;&quot;The |Element| objects which handle the relevant target |Parameter|</span>
<span class="sd">    instances.&quot;&quot;&quot;</span>

    <span class="n">selections</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The names of all relevant |Selection| objects.&quot;&quot;&quot;</span>

    <span class="n">_value</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">_parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">]</span>
    <span class="n">_original_parameter_values</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">parameter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parametername</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">parameter</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">selections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">selections</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span>
                <span class="k">if</span> <span class="s2">&quot;complete&quot;</span> <span class="ow">in</span> <span class="n">selections</span><span class="p">:</span>
                    <span class="n">selections</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">(</span><span class="n">selections</span><span class="o">.</span><span class="n">complete</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selections</span> <span class="o">=</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selections</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">(</span>
                        <span class="n">sel</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">selections</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="n">selections</span><span class="o">.</span><span class="n">names</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">selections</span><span class="o">.</span><span class="n">elements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">(</span>
                    <span class="n">element</span>
                    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">selections</span><span class="o">.</span><span class="n">elements</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Object `</span><span class="si">{</span><span class="n">selections</span><span class="si">}</span><span class="s2">` does not handle &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;any `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="si">}</span><span class="s2">` model instances.&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="n">control</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">control</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametername</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;does not define a control parameter named &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parametername</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parametertype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">control</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parametername</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span> <span class="o">=</span> <span class="n">parameterstep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original_parameter_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_original_parameter_values</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to initialise the `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;rule object `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_original_parameter_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="c1"># pylint: disable=not-callable</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">revert_timefactor</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The calibration parameter value.</span>

<span class="sd">        Property |Rule.value| ensures that the given value adheres to the</span>
<span class="sd">        defined lower and upper boundaries:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">        ...     name=&quot;fc&quot;,</span>
<span class="sd">        ...     parameter=&quot;fc&quot;,</span>
<span class="sd">        ...     value=100.0,</span>
<span class="sd">        ...     lower=50.0,</span>
<span class="sd">        ...     upper=200.0,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; rule.value = 0.0</span>
<span class="sd">        &gt;&gt;&gt; rule.value</span>
<span class="sd">        50.0</span>

<span class="sd">        With option |Options.warntrim| enabled (the default), property</span>
<span class="sd">        |Rule.value| also emits a warning like the following:</span>

<span class="sd">        &gt;&gt;&gt; with pub.options.warntrim(True):</span>
<span class="sd">        ...     rule.value = 300.0</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        UserWarning: The value of the `Replace` object `fc` must not be \</span>
<span class="sd">smaller than `50.0` or larger than `200.0`, but the given value is `300.0`.  \</span>
<span class="sd">Applying the trimmed value `200.0` instead.</span>
<span class="sd">        &gt;&gt;&gt; rule.value</span>
<span class="sd">        200.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">warntrim</span><span class="p">:</span>
                <span class="n">repr_</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The value of the `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` object &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">` must not be smaller than `</span><span class="si">{</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;or larger than `</span><span class="si">{</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">`, but the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;given value is `</span><span class="si">{</span><span class="n">repr_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">`.  Applying the trimmed &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;value `</span><span class="si">{</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span><span class="si">}</span><span class="s2">` instead.&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="Rule.apply_value"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Rule.apply_value">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">apply_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the current value on the relevant |Parameter| objects.</span>

<span class="sd">        To be overridden by the concrete subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="Rule.reset_parameters"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Rule.reset_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset all relevant parameter objects to their original states.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">        &gt;&gt;&gt; rule = Replace(</span>
<span class="sd">        ...     name=&quot;fc&quot;,</span>
<span class="sd">        ...     parameter=&quot;fc&quot;,</span>
<span class="sd">        ...     value=100.0,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; fc = hp.elements.land_lahn_1.model.parameters.control.fc</span>
<span class="sd">        &gt;&gt;&gt; fc</span>
<span class="sd">        fc(206.0)</span>
<span class="sd">        &gt;&gt;&gt; fc(100.0)</span>
<span class="sd">        &gt;&gt;&gt; fc</span>
<span class="sd">        fc(100.0)</span>
<span class="sd">        &gt;&gt;&gt; rule.reset_parameters()</span>
<span class="sd">        &gt;&gt;&gt; fc</span>
<span class="sd">        fc(206.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=not-callable</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">orig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_parameter_values</span><span class="p">):</span>
                <span class="n">parameter</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The parameter step size relevant to the related model parameter.</span>

<span class="sd">        For non-time-dependent parameters, property |Rule.parameterstep|</span>
<span class="sd">        is (usually) |None|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameterstep</span>

    <span class="k">def</span> <span class="nf">_set_parameterstep</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametertype</span><span class="o">.</span><span class="n">TIME</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameterstep</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Rules which handle time-dependent parameters &quot;</span>
                        <span class="s2">&quot;require information on the parameter timestep &quot;</span>
                        <span class="s2">&quot;size.  Either assign it directly or define &quot;</span>
                        <span class="s2">&quot;it via option `parameterstep`.&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameterstep</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">parameterstep</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_parameterstep</span><span class="p">,</span> <span class="n">_set_parameterstep</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.assignrepr"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Rule.assignrepr">[docs]</a>    <span class="k">def</span> <span class="nf">assignrepr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the actual |Rule| object</span>
<span class="sd">        prefixed with the given string.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_none_or_string</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">if</span> <span class="n">obj</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">blanks</span> <span class="o">=</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="n">selprefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">selections=&quot;</span>
        <span class="n">selline</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">assignrepr_tuple</span><span class="p">(</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">sel</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">),</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">selprefix</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s1">name=&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&quot;,</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s1">parameter=&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parametername</span><span class="si">}</span><span class="s1">&quot;,</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">lower=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">upper=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">parameterstep=</span><span class="si">{</span><span class="n">_none_or_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">value=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}</span><span class="s2">model=</span><span class="si">{</span><span class="n">_none_or_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">selline</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indent</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">getattr</span><span class="p">(</span>
                <span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">control</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parametername</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Replace"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Replace">[docs]</a><span class="k">class</span> <span class="nc">Replace</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;|Rule| class which simply replaces the current model parameter</span>
<span class="sd">    value(s) with the current calibration parameter value.</span>

<span class="sd">    See the documentation on class |Rule| for further information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adaptor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Adaptor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;An optional function object for customising individual calibration</span>
<span class="sd">    strategies.</span>

<span class="sd">    See the documentation on the classes |Rule|, |SumAdaptor|, and </span>
<span class="sd">    |FactorAdaptor| for further information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Replace.apply_value"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Replace.apply_value">[docs]</a>    <span class="k">def</span> <span class="nf">apply_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the current value on the relevant |Parameter| objects.</span>

<span class="sd">        See the documentation on class |Rule| for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=not-callable</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaptor</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">adaptor</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Add"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Add">[docs]</a><span class="k">class</span> <span class="nc">Add</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;|Rule| class which adds its calibration delta to the original model</span>
<span class="sd">    parameter value(s).</span>

<span class="sd">    Please read the examples of the documentation on class |Rule| first.</span>
<span class="sd">    Here, we modify some of these examples to show the unique features</span>
<span class="sd">    of class |Add|.</span>

<span class="sd">    The first example deals with the non-time-dependent parameter</span>
<span class="sd">    |hland_control.FC|.  The following |Add| object adds its current</span>
<span class="sd">    value to the original value of the parameter:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import Add</span>
<span class="sd">    &gt;&gt;&gt; rule = Add(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=100.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; rule.adaptor = lambda parameter: 2.0*rule.value</span>
<span class="sd">    &gt;&gt;&gt; fc = hp.elements.land_lahn_1.model.parameters.control.fc</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(206.0)</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(306.0)</span>

<span class="sd">    The second example deals with the time-dependent parameter</span>
<span class="sd">    |hland_control.PercMax| and shows that everything works even for</span>
<span class="sd">    situations where the actual |Options.parameterstep| (2 days) differs</span>
<span class="sd">    from the current |Options.simulationstep| (1 day):</span>

<span class="sd">    &gt;&gt;&gt; rule = Add(</span>
<span class="sd">    ...     name=&quot;percmax&quot;,</span>
<span class="sd">    ...     parameter=&quot;percmax&quot;,</span>
<span class="sd">    ...     value=5.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ...     parameterstep=&quot;2d&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; percmax = hp.elements.land_lahn_1.model.parameters.control.percmax</span>
<span class="sd">    &gt;&gt;&gt; percmax</span>
<span class="sd">    percmax(1.02978)</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; percmax</span>
<span class="sd">    percmax(3.52978)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Add.apply_value"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Add.apply_value">[docs]</a>    <span class="k">def</span> <span class="nf">apply_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the current (adapted) value on the relevant |Parameter|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=not-callable</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">orig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_parameter_values</span><span class="p">):</span>
                <span class="n">parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">orig</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Multiply"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Multiply">[docs]</a><span class="k">class</span> <span class="nc">Multiply</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;|Rule| class which multiplies the original model parameter value(s)</span>
<span class="sd">    by its calibration factor.</span>

<span class="sd">    Please read the examples of the documentation on class |Rule| first.</span>
<span class="sd">    Here, we modify some of these examples to show the unique features</span>
<span class="sd">    of class |Multiply|.</span>

<span class="sd">    The first example deals with the non-time-dependent parameter</span>
<span class="sd">    |hland_control.FC|.  The following |Multiply| object multiplies the</span>
<span class="sd">    original value of the parameter by its current calibration factor:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import Add</span>
<span class="sd">    &gt;&gt;&gt; rule = Multiply(</span>
<span class="sd">    ...     name=&quot;fc&quot;,</span>
<span class="sd">    ...     parameter=&quot;fc&quot;,</span>
<span class="sd">    ...     value=2.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; fc = hp.elements.land_lahn_1.model.parameters.control.fc</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(206.0)</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; fc</span>
<span class="sd">    fc(412.0)</span>

<span class="sd">    The second example deals with the time-dependent parameter</span>
<span class="sd">    |hland_control.PercMax| and shows that everything works even for</span>
<span class="sd">    situations where the actual |Options.parameterstep| (2 days) differs</span>
<span class="sd">    from the current |Options.simulationstep| (1 day):</span>

<span class="sd">    &gt;&gt;&gt; rule = Multiply(</span>
<span class="sd">    ...     name=&quot;percmax&quot;,</span>
<span class="sd">    ...     parameter=&quot;percmax&quot;,</span>
<span class="sd">    ...     value=2.0,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ...     parameterstep=&quot;2d&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; percmax = hp.elements.land_lahn_1.model.parameters.control.percmax</span>
<span class="sd">    &gt;&gt;&gt; percmax</span>
<span class="sd">    percmax(1.02978)</span>
<span class="sd">    &gt;&gt;&gt; rule.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; percmax</span>
<span class="sd">    percmax(2.05956)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Multiply.apply_value"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.Multiply.apply_value">[docs]</a>    <span class="k">def</span> <span class="nf">apply_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the current (adapted) value on the relevant |Parameter|</span>
<span class="sd">        objects.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=not-callable</span>
        <span class="k">with</span> <span class="n">hydpy</span><span class="o">.</span><span class="n">pub</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">orig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_parameter_values</span><span class="p">):</span>
                <span class="n">parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">orig</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CalibrationInterface"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface">[docs]</a><span class="k">class</span> <span class="nc">CalibrationInterface</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Interface for the coupling of *HydPy* to optimisation libraries like</span>
<span class="sd">    `NLopt`_.</span>

<span class="sd">    Essentially, class |CalibrationInterface| is supposed for the structured</span>
<span class="sd">    handling of multiple objects of the different |Rule| subclasses.  Hence,</span>
<span class="sd">    please read the documentation on class |Rule| before continuing, on</span>
<span class="sd">    which we base the following explanations.</span>

<span class="sd">    We work with the `Lahn` example project again:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">    &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">    First, we create a |CalibrationInterface| object.  Initially, it needs</span>
<span class="sd">    to know the relevant |HydPy| object and the target or objective function</span>
<span class="sd">    (here, we define the target function sloppily via the `lambda` statement;</span>
<span class="sd">    see the documentation on the protocol class |TargetFunction| for a more</span>
<span class="sd">    formal definition and further explanations):</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import CalibrationInterface, nse</span>
<span class="sd">    &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">    ...     hp=hp,</span>
<span class="sd">    ...     targetfunction=lambda: sum(nse(node=node) for node in hp.nodes)</span>
<span class="sd">    ... )</span>

<span class="sd">    Next, we use method |CalibrationInterface.make_rules|, which generates</span>
<span class="sd">    one |Replace| rule related to parameter |hland_control.FC| and another</span>
<span class="sd">    one related to parameter |hland_control.PercMax| in one step:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">    &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">    ...     rule=Replace,</span>
<span class="sd">    ...     names=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">    ...     parameters=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">    ...     values=[100.0, 5.0],</span>
<span class="sd">    ...     lowers=[50.0, 1.0],</span>
<span class="sd">    ...     uppers=[200.0, 10.0],</span>
<span class="sd">    ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">    ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    &gt;&gt;&gt; print(ci)</span>
<span class="sd">    CalibrationInterface</span>
<span class="sd">    &gt;&gt;&gt; ci</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;fc&quot;,</span>
<span class="sd">        parameter=&quot;fc&quot;,</span>
<span class="sd">        lower=50.0,</span>
<span class="sd">        upper=200.0,</span>
<span class="sd">        parameterstep=None,</span>
<span class="sd">        value=100.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;percmax&quot;,</span>
<span class="sd">        parameter=&quot;percmax&quot;,</span>
<span class="sd">        lower=1.0,</span>
<span class="sd">        upper=10.0,</span>
<span class="sd">        parameterstep=&quot;1d&quot;,</span>
<span class="sd">        value=5.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>

<span class="sd">    You can also add existing rules via method |CalibrationInterface.add_rules|.</span>
<span class="sd">    We add one for calibrating parameter |hstream_control.Damp| of application</span>
<span class="sd">    model |hstream_v1|:</span>

<span class="sd">    &gt;&gt;&gt; len(ci)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; ci.add_rules(</span>
<span class="sd">    ...     Replace(</span>
<span class="sd">    ...         name=&quot;damp&quot;,</span>
<span class="sd">    ...         parameter=&quot;damp&quot;,</span>
<span class="sd">    ...         value=0.2,</span>
<span class="sd">    ...         lower=0.0,</span>
<span class="sd">    ...         upper=0.5,</span>
<span class="sd">    ...         selections=[&quot;complete&quot;],</span>
<span class="sd">    ...         model=&quot;hstream_v1&quot;,</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; len(ci)</span>
<span class="sd">    3</span>

<span class="sd">    All rules are available via attribute and keyword access:</span>

<span class="sd">    &gt;&gt;&gt; ci.fc</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;fc&quot;,</span>
<span class="sd">        parameter=&quot;fc&quot;,</span>
<span class="sd">        lower=50.0,</span>
<span class="sd">        upper=200.0,</span>
<span class="sd">        parameterstep=None,</span>
<span class="sd">        value=100.0,</span>
<span class="sd">        model=&quot;hland_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; ci.FC</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The actual calibration interface does neither \</span>
<span class="sd">handle a normal attribute nor a rule object named `FC`.</span>

<span class="sd">    &gt;&gt;&gt; ci[&quot;damp&quot;]</span>
<span class="sd">    Replace(</span>
<span class="sd">        name=&quot;damp&quot;,</span>
<span class="sd">        parameter=&quot;damp&quot;,</span>
<span class="sd">        lower=0.0,</span>
<span class="sd">        upper=0.5,</span>
<span class="sd">        parameterstep=None,</span>
<span class="sd">        value=0.2,</span>
<span class="sd">        model=&quot;hstream_v1&quot;,</span>
<span class="sd">        selections=(&quot;complete&quot;,),</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; ci[&quot;Damp&quot;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    KeyError: &#39;The actual calibration interface does not handle a \</span>
<span class="sd">rule object named `Damp`.&#39;</span>

<span class="sd">    The following properties return consistently sorted information on</span>
<span class="sd">    the handles |Rule| objects:</span>

<span class="sd">    &gt;&gt;&gt; ci.names</span>
<span class="sd">    (&#39;fc&#39;, &#39;percmax&#39;, &#39;damp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ci.values</span>
<span class="sd">    (100.0, 5.0, 0.2)</span>
<span class="sd">    &gt;&gt;&gt; ci.lowers</span>
<span class="sd">    (50.0, 1.0, 0.0)</span>
<span class="sd">    &gt;&gt;&gt; ci.uppers</span>
<span class="sd">    (200.0, 10.0, 0.5)</span>

<span class="sd">    All tuples reflect the current state of all rules:</span>

<span class="sd">    &gt;&gt;&gt; ci.damp.value = 0.3</span>
<span class="sd">    &gt;&gt;&gt; ci.values</span>
<span class="sd">    (100.0, 5.0, 0.3)</span>

<span class="sd">    For the following examples, we perform a simulation run and assign</span>
<span class="sd">    the values of the simulated time-series to the observed series:</span>

<span class="sd">    &gt;&gt;&gt; conditions = hp.conditions</span>
<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">    &gt;&gt;&gt; for node in hp.nodes:</span>
<span class="sd">    ...     node.sequences.obs.series = node.sequences.sim.series</span>
<span class="sd">    &gt;&gt;&gt; hp.conditions = conditions</span>

<span class="sd">    As the agreement between the simulated and the &quot;observed&quot; time-series is</span>
<span class="sd">    perfect all four gauges, method |CalibrationInterface.calculate_likelihood|</span>
<span class="sd">    returns the highest possible sum of four |nse| values and also stores it</span>
<span class="sd">    under the attribute `result`:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.calculate_likelihood())</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.result)</span>
<span class="sd">    4.0</span>

<span class="sd">    When performing a manual calibration, it might be convenient to use</span>
<span class="sd">    method |CalibrationInterface.apply_values|.  To explain how it works,</span>
<span class="sd">    we first show the values of the relevant parameters of some randomly</span>
<span class="sd">    selected model instances:</span>

<span class="sd">    &gt;&gt;&gt; stream = hp.elements.stream_lahn_1_lahn_2.model</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.control</span>
<span class="sd">    lag(0.583)</span>
<span class="sd">    damp(0.0)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.derived</span>
<span class="sd">    nmbsegments(1)</span>
<span class="sd">    c1(0.0)</span>
<span class="sd">    c3(0.0)</span>
<span class="sd">    c2(1.0)</span>
<span class="sd">    &gt;&gt;&gt; land = hp.elements.land_lahn_1.model</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.fc</span>
<span class="sd">    fc(206.0)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.percmax</span>
<span class="sd">    percmax(1.02978)</span>

<span class="sd">    Method |CalibrationInterface.apply_values| of class |CalibrationInterface|</span>
<span class="sd">    calls the method |Rule.apply_value| of all handled |Rule| objects, performs</span>
<span class="sd">    some preparations (for example, it derives the values of the secondary</span>
<span class="sd">    parameters (see parameter |hstream_derived.NmbSegments|), executes a</span>
<span class="sd">    simulation run, calls method |CalibrationInterface.calculate_likelihood|,</span>
<span class="sd">    and returns the result:</span>

<span class="sd">    &gt;&gt;&gt; result = ci.apply_values()</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.control</span>
<span class="sd">    lag(0.583)</span>
<span class="sd">    damp(0.3)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.derived</span>
<span class="sd">    nmbsegments(1)</span>
<span class="sd">    c1(0.230769)</span>
<span class="sd">    c3(0.230769)</span>
<span class="sd">    c2(0.538462)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.fc</span>
<span class="sd">    fc(100.0)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.percmax</span>
<span class="sd">    percmax(5.0)</span>

<span class="sd">    Due to the changes in our parameter values, our simulation is not</span>
<span class="sd">    &quot;perfect&quot; anymore:</span>

<span class="sd">    &gt;&gt;&gt; round_(ci.result)</span>
<span class="sd">    1.605136</span>

<span class="sd">    Use method |CalibrationInterface.reset_parameters| to restore the initial</span>
<span class="sd">    states of all affected parameters:</span>

<span class="sd">    &gt;&gt;&gt; ci.reset_parameters()</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.control</span>
<span class="sd">    lag(0.583)</span>
<span class="sd">    damp(0.0)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.derived</span>
<span class="sd">    nmbsegments(1)</span>
<span class="sd">    c1(0.0)</span>
<span class="sd">    c3(0.0)</span>
<span class="sd">    c2(1.0)</span>
<span class="sd">    &gt;&gt;&gt; land = hp.elements.land_lahn_1.model</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.fc</span>
<span class="sd">    fc(206.0)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.percmax</span>
<span class="sd">    percmax(1.02978)</span>

<span class="sd">    Now we get the same &quot;perfect&quot; efficiency again:</span>

<span class="sd">    &gt;&gt;&gt; hp.simulate()</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.calculate_likelihood())</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; hp.conditions = conditions</span>

<span class="sd">    Note the `perform_simulation` argument of method</span>
<span class="sd">    |CalibrationInterface.apply_values|, which allows changing the model parameter</span>
<span class="sd">    values and updating the |HydPy| object only without to trigger a simulation run</span>
<span class="sd">    (and to calculate and return a new likelihood value):</span>

<span class="sd">    &gt;&gt;&gt; ci.apply_values(perform_simulation=False)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.control</span>
<span class="sd">    lag(0.583)</span>
<span class="sd">    damp(0.3)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.derived</span>
<span class="sd">    nmbsegments(1)</span>
<span class="sd">    c1(0.230769)</span>
<span class="sd">    c3(0.230769)</span>
<span class="sd">    c2(0.538462)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.fc</span>
<span class="sd">    fc(100.0)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.percmax</span>
<span class="sd">    percmax(5.0)</span>

<span class="sd">    Optimisers, like those implemented in `NLopt`_, often provide their new</span>
<span class="sd">    parameter estimates via vectors.  Method</span>
<span class="sd">    |CalibrationInterface.perform_calibrationstep| accepts such vectors and</span>
<span class="sd">    updates the handled |Rule| objects accordingly.  After that, it performs</span>
<span class="sd">    the same steps as described for method |CalibrationInterface.apply_values|:</span>

<span class="sd">    &gt;&gt;&gt; round_(ci.perform_calibrationstep([100.0, 5.0, 0.3]))</span>
<span class="sd">    1.605136</span>

<span class="sd">    &gt;&gt;&gt; stream.parameters.control</span>
<span class="sd">    lag(0.583)</span>
<span class="sd">    damp(0.3)</span>
<span class="sd">    &gt;&gt;&gt; stream.parameters.derived</span>
<span class="sd">    nmbsegments(1)</span>
<span class="sd">    c1(0.230769)</span>
<span class="sd">    c3(0.230769)</span>
<span class="sd">    c2(0.538462)</span>

<span class="sd">    &gt;&gt;&gt; land.parameters.control.fc</span>
<span class="sd">    fc(100.0)</span>
<span class="sd">    &gt;&gt;&gt; land.parameters.control.percmax</span>
<span class="sd">    percmax(5.0)</span>

<span class="sd">    Method |CalibrationInterface.perform_calibrationstep| writes intermediate</span>
<span class="sd">    results into a log file, if available.  Prepares it beforehand via method</span>
<span class="sd">    |CalibrationInterface.prepare_logfile|:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.prepare_logfile(logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...                        objectivefunction=&quot;NSE&quot;,</span>
<span class="sd">    ...                        documentation=&quot;Just a doctest example.&quot;)</span>

<span class="sd">    To continue &quot;manually&quot;, we now can call method</span>
<span class="sd">    |CalibrationInterface.update_logfile| to write the lastly calculated</span>
<span class="sd">    efficiency and the corresponding calibration parameter values to the</span>
<span class="sd">    log file:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():   # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...     ci.update_logfile()</span>
<span class="sd">    ...     print(open(&quot;example_calibration.log&quot;).read())</span>
<span class="sd">    # Just a doctest example.</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    NSE           fc    percmax damp</span>
<span class="sd">    parameterstep None	1d      None</span>
<span class="sd">    1.605136      100.0 5.0     0.3</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    For automatic calibration, one needs a calibration algorithm like the</span>
<span class="sd">    following, which simply checks the lower and upper boundaries as well</span>
<span class="sd">    as the initial values of all |Rule| objects:</span>

<span class="sd">    &gt;&gt;&gt; def find_max(function, lowers, uppers, inits):</span>
<span class="sd">    ...     best_result = -999.0</span>
<span class="sd">    ...     best_parameters = None</span>
<span class="sd">    ...     for values in (lowers, uppers, inits):</span>
<span class="sd">    ...         result = function(values)</span>
<span class="sd">    ...         if result &gt; best_result:</span>
<span class="sd">    ...             best_result = result</span>
<span class="sd">    ...             best_parameters = values</span>
<span class="sd">    ...     return best_parameters</span>

<span class="sd">    Now we can assign method |CalibrationInterface.perform_calibrationstep|</span>
<span class="sd">    to this oversimplified optimiser, which then returns the best examined</span>
<span class="sd">    calibration parameter values:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     find_max(function=ci.perform_calibrationstep,</span>
<span class="sd">    ...              lowers=ci.lowers,</span>
<span class="sd">    ...              uppers=ci.uppers,</span>
<span class="sd">    ...              inits=ci.values)</span>
<span class="sd">    (200.0, 10.0, 0.5)</span>

<span class="sd">    The log file now contains one line for our old result and three lines</span>
<span class="sd">    for the results of our optimiser:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():   # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    ...     print(open(&quot;example_calibration.log&quot;).read())</span>
<span class="sd">    # Just a doctest example.</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    NSE           fc    percmax damp</span>
<span class="sd">    parameterstep None  1d      None</span>
<span class="sd">    1.605136      100.0 5.0     0.3</span>
<span class="sd">    -0.710211     50.0  1.0     0.0</span>
<span class="sd">    2.313934      200.0 10.0    0.5</span>
<span class="sd">    1.605136      100.0 5.0     0.3</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    Class |CalibrationInterface| also provides method</span>
<span class="sd">    |CalibrationInterface.read_logfile|, which automatically selects the</span>
<span class="sd">    best calibration result.  Therefore, it needs to know that the highest</span>
<span class="sd">    result is the best, which we indicate by setting argument `maximisation`</span>
<span class="sd">    to |True|:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.read_logfile(</span>
<span class="sd">    ...         logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...         maximisation=True,</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; ci.fc.value</span>
<span class="sd">    200.0</span>
<span class="sd">    &gt;&gt;&gt; ci.percmax.value</span>
<span class="sd">    10.0</span>
<span class="sd">    &gt;&gt;&gt; ci.damp.value</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.result)</span>
<span class="sd">    2.313934</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.apply_values())</span>
<span class="sd">    2.313934</span>

<span class="sd">    On the contrary, if we set argument `maximisation` to |False|, method</span>
<span class="sd">    |CalibrationInterface.read_logfile| returns the worst result in our</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.read_logfile(</span>
<span class="sd">    ...         logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...         maximisation=False,</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; ci.fc.value</span>
<span class="sd">    50.0</span>
<span class="sd">    &gt;&gt;&gt; ci.percmax.value</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; ci.damp.value</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.result)</span>
<span class="sd">    -0.710211</span>
<span class="sd">    &gt;&gt;&gt; round_(ci.apply_values())</span>
<span class="sd">    -0.710211</span>

<span class="sd">    To prevent errors due to different parameter step-sizes, method</span>
<span class="sd">    |CalibrationInterface.read_logfile| raises the following error whenever</span>
<span class="sd">    it detects inconsistencies:</span>

<span class="sd">    &gt;&gt;&gt; ci.percmax.parameterstep = &quot;2d&quot;</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.read_logfile(</span>
<span class="sd">    ...         logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...         maximisation=True,</span>
<span class="sd">    ...     )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: The current parameterstep of the `Replace` rule \</span>
<span class="sd">`percmax` (`2d`) does not agree with the one documentated in log file \</span>
<span class="sd">`example_calibration.log` (`1d`).</span>

<span class="sd">    Method |CalibrationInterface.read_logfile| reports inconsistent rule</span>
<span class="sd">    names as follows:</span>

<span class="sd">    &gt;&gt;&gt; ci.remove_rules(ci.percmax)</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.read_logfile(</span>
<span class="sd">    ...         logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...         maximisation=True,</span>
<span class="sd">    ...     )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: The names of the rules handled by the actual calibration \</span>
<span class="sd">interface (damp and fc) do not agree with the names in the header of logfile \</span>
<span class="sd">`example_calibration.log` (damp, fc, and percmax).</span>

<span class="sd">    The last consistency check is optional.  Set argument `check` to |False|</span>
<span class="sd">    to force method |CalibrationInterface.read_logfile| to query all available</span>
<span class="sd">    data instead of raising an error:</span>

<span class="sd">    &gt;&gt;&gt; ci.add_rules(</span>
<span class="sd">    ...     Replace(</span>
<span class="sd">    ...         name=&quot;beta&quot;,</span>
<span class="sd">    ...         parameter=&quot;beta&quot;,</span>
<span class="sd">    ...         value=2.0,</span>
<span class="sd">    ...         lower=1.0,</span>
<span class="sd">    ...         upper=4.0,</span>
<span class="sd">    ...         selections=[&quot;complete&quot;],</span>
<span class="sd">    ...         model=&quot;hland_v1&quot;,</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; ci.fc.value = 0.0</span>
<span class="sd">    &gt;&gt;&gt; ci.damp.value = 0.0</span>
<span class="sd">    &gt;&gt;&gt; with TestIO():</span>
<span class="sd">    ...     ci.read_logfile(</span>
<span class="sd">    ...         logfilepath=&quot;example_calibration.log&quot;,</span>
<span class="sd">    ...         maximisation=True,</span>
<span class="sd">    ...         check=False,</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; ci.beta.value</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; ci.fc.value</span>
<span class="sd">    200.0</span>
<span class="sd">    &gt;&gt;&gt; ci.damp.value</span>
<span class="sd">    0.5</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The last result calculated by the target function.&quot;&quot;&quot;</span>
    <span class="n">conditions</span><span class="p">:</span> <span class="n">hydpytools</span><span class="o">.</span><span class="n">ConditionsType</span>
    <span class="sd">&quot;&quot;&quot;The |HydPy.conditions| of the given |HydPy| object.</span>

<span class="sd">    |CalibrationInterface| queries the conditions during its initialisation </span>
<span class="sd">    and uses them later to reset all relevant conditions before each new </span>
<span class="sd">    simulation run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logfilepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">_hp</span><span class="p">:</span> <span class="n">hydpytools</span><span class="o">.</span><span class="n">HydPy</span>
    <span class="n">_targetfunction</span><span class="p">:</span> <span class="n">TargetFunction</span>
    <span class="n">_rules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RuleType1</span><span class="p">]</span>
    <span class="n">_elements</span><span class="p">:</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hp</span><span class="p">:</span> <span class="n">hydpytools</span><span class="o">.</span><span class="n">HydPy</span><span class="p">,</span>
        <span class="n">targetfunction</span><span class="p">:</span> <span class="n">TargetFunction</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hp</span> <span class="o">=</span> <span class="n">hp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_targetfunction</span> <span class="o">=</span> <span class="n">targetfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="CalibrationInterface.add_rules"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.add_rules">[docs]</a>    <span class="k">def</span> <span class="nf">add_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">rules</span><span class="p">:</span> <span class="n">RuleType1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add some |Rule| objects to the actual |CalibrationInterface| object.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import CalibrationInterface</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: None,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">        &gt;&gt;&gt; ci.add_rules(</span>
<span class="sd">        ...     Replace(</span>
<span class="sd">        ...         name=&quot;fc&quot;,</span>
<span class="sd">        ...         parameter=&quot;fc&quot;,</span>
<span class="sd">        ...         value=100.0,</span>
<span class="sd">        ...         model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ...     Replace(</span>
<span class="sd">        ...         name=&quot;percmax&quot;,</span>
<span class="sd">        ...         parameter=&quot;percmax&quot;,</span>
<span class="sd">        ...         value=5.0,</span>
<span class="sd">        ...         model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>

<span class="sd">        Note that method |CalibrationInterface.add_rules| might change the</span>
<span class="sd">        number of |Element| objects relevant for the |CalibrationInterface|</span>
<span class="sd">        object:</span>

<span class="sd">        &gt;&gt;&gt; damp = Replace(</span>
<span class="sd">        ...     name=&quot;damp&quot;,</span>
<span class="sd">        ...     parameter=&quot;damp&quot;,</span>
<span class="sd">        ...     value=0.2,</span>
<span class="sd">        ...     model=&quot;hstream_v1&quot;,</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; len(ci._elements)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; ci.add_rules(damp)</span>
<span class="sd">        &gt;&gt;&gt; len(ci._elements)</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_elements_when_adding_a_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">get_rule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleType1</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">get_rule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">type_</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType2</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleType2</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="CalibrationInterface.get_rule"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.get_rule">[docs]</a>    <span class="k">def</span> <span class="nf">get_rule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">type_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">RuleType2</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rule</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a |Rule| object (of a specific type).</span>

<span class="sd">        Method |CalibrationInterface.get_rule| is a more typesafe alternative to</span>
<span class="sd">        simple keyword access. Besides the name of the required |Rule| object, pass</span>
<span class="sd">        its subclass, to convince your IDE (and yourself) that the returned rule</span>
<span class="sd">        follows this more specific type:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Add, CalibrationInterface, nse, Replace</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: sum(nse(node=node) for node in hp.nodes)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     names=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     parameters=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     values=[100.0, 5.0],</span>
<span class="sd">        ...     lowers=[50.0, 1.0],</span>
<span class="sd">        ...     uppers=[200.0, 10.0],</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; ci.get_rule(&quot;fc&quot;, Replace).name</span>
<span class="sd">        &#39;fc&#39;</span>

<span class="sd">        &gt;&gt;&gt; ci.get_rule(&quot;Fc&quot;, Replace).name</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The actual calibration interface does not handle a rule \</span>
<span class="sd">object named `Fc`.</span>

<span class="sd">        &gt;&gt;&gt; ci.get_rule(&quot;fc&quot;, Replace).name</span>
<span class="sd">        &#39;fc&#39;</span>

<span class="sd">        &gt;&gt;&gt; ci.get_rule(&quot;fc&quot;, Add).name</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The actual calibration interface does not handle a rule \</span>
<span class="sd">object named `fc` of type `Add`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The actual calibration interface does not handle &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;a rule object named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rule</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The actual calibration interface does not handle a &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;rule object named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">` of type `</span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CalibrationInterface.remove_rules"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.remove_rules">[docs]</a>    <span class="k">def</span> <span class="nf">remove_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">rules</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RuleType1</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove some |Rule| objects from the actual |CalibrationInterface|</span>
<span class="sd">        object.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import CalibrationInterface</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: None,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">        &gt;&gt;&gt; ci.add_rules(</span>
<span class="sd">        ...     Replace(</span>
<span class="sd">        ...         name=&quot;fc&quot;,</span>
<span class="sd">        ...         parameter=&quot;fc&quot;,</span>
<span class="sd">        ...         value=100.0,</span>
<span class="sd">        ...         model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ...     Replace(</span>
<span class="sd">        ...         name=&quot;percmax&quot;,</span>
<span class="sd">        ...         parameter=&quot;percmax&quot;,</span>
<span class="sd">        ...         value=5.0,</span>
<span class="sd">        ...         model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ...     Replace(</span>
<span class="sd">        ...         name=&quot;damp&quot;,</span>
<span class="sd">        ...         parameter=&quot;damp&quot;,</span>
<span class="sd">        ...         value=0.2,</span>
<span class="sd">        ...         model=&quot;hstream_v1&quot;,</span>
<span class="sd">        ...     )</span>
<span class="sd">        ... )</span>

<span class="sd">        You can remove each rule either by passing itself or its name (note</span>
<span class="sd">        that method |CalibrationInterface.remove_rules| might change the</span>
<span class="sd">        number of |Element| objects relevant for the |CalibrationInterface|</span>
<span class="sd">        object):</span>

<span class="sd">        &gt;&gt;&gt; len(ci._elements)</span>
<span class="sd">        7</span>
<span class="sd">        &gt;&gt;&gt; fc = ci.fc</span>
<span class="sd">        &gt;&gt;&gt; fc in ci</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; &quot;damp&quot; in ci</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ci.remove_rules(fc, &quot;damp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; fc in ci</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; &quot;damp&quot; in ci</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; len(ci._elements)</span>
<span class="sd">        4</span>

<span class="sd">        Trying to remove a non-existing rule results in the following error:</span>

<span class="sd">        &gt;&gt;&gt; ci.remove_rules(&quot;fc&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: The actual calibration interface object does not handle \</span>
<span class="sd">a rule object named `fc`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="n">rulename</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The actual calibration interface object does &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;not handle a rule object named `</span><span class="si">{</span><span class="n">rulename</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_elements_when_deleting_a_rule</span><span class="p">()</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">make_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">],</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">lowers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">uppers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">parametersteps</span><span class="p">:</span> <span class="n">typingtools</span><span class="o">.</span><span class="n">Sequence1</span><span class="p">[</span>
            <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">make_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">],</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">lowers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">uppers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">parametersteps</span><span class="p">:</span> <span class="n">typingtools</span><span class="o">.</span><span class="n">Sequence1</span><span class="p">[</span>
            <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">product</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">make_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">],</span>
        <span class="n">calibspecs</span><span class="p">:</span> <span class="s2">&quot;CalibSpecs&quot;</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lowers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">uppers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">make_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">],</span>
        <span class="n">calibspecs</span><span class="p">:</span> <span class="s2">&quot;CalibSpecs&quot;</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lowers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">uppers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">product</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="CalibrationInterface.make_rules"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.make_rules">[docs]</a>    <span class="k">def</span> <span class="nf">make_rules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">],</span>
        <span class="n">calibspecs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;CalibSpecs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lowers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">uppers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parametersteps</span><span class="p">:</span> <span class="n">typingtools</span><span class="o">.</span><span class="n">Sequence1</span><span class="p">[</span>
            <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">product</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create and store new |Rule| objects.</span>

<span class="sd">        Please see the main documentation on class |CalibrationInterface| first,</span>
<span class="sd">        from which we borrow the general setup:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibrationInterface, nse</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: sum(nse(node=node) for node in hp.nodes)</span>
<span class="sd">        ... )</span>

<span class="sd">        Here, we show only the supplemental features of method</span>
<span class="sd">        |CalibrationInterface.make_rules| in some brevity.</span>

<span class="sd">        Method |CalibrationInterface.make_rules| checks that all given</span>
<span class="sd">        sequences have the same length:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Replace</span>
<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     names=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     parameters=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     values=[100.0, 5.0],</span>
<span class="sd">        ...     lowers=[50.0, 1.0],</span>
<span class="sd">        ...     uppers=[200.0],</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: When creating rules via method `make_rules`, all given \</span>
<span class="sd">sequences must be of equal length.</span>

<span class="sd">        The separate handling of the specifications of all calibration parameters</span>
<span class="sd">        is error-prone.  For more safety and convenience, you can bundle all</span>
<span class="sd">        specifications within a |CalibSpecs| object instead and pass them at once:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(</span>
<span class="sd">        ...     CalibSpec(name=&quot;fc&quot;, default=100.0, lower=50.0, upper=200.0),</span>
<span class="sd">        ...     CalibSpec(</span>
<span class="sd">        ...         name=&quot;percmax&quot;, default=5.0, lower=1.0, upper=10.0, \</span>
<span class="sd">parameterstep=&quot;1d&quot;</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     calibspecs=calibspecs,</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;percmax&quot;]</span>
<span class="sd">        Replace(</span>
<span class="sd">            name=&quot;percmax&quot;,</span>
<span class="sd">            parameter=&quot;percmax&quot;,</span>
<span class="sd">            lower=1.0,</span>
<span class="sd">            upper=10.0,</span>
<span class="sd">            parameterstep=&quot;1d&quot;,</span>
<span class="sd">            value=5.0,</span>
<span class="sd">            model=&quot;hland_v1&quot;,</span>
<span class="sd">            selections=(&quot;complete&quot;,),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ci.remove_rules(&quot;fc&quot;, &quot;percmax&quot;)</span>

<span class="sd">        You are free also to use the individual arguments (e.g. `names`) to</span>
<span class="sd">        override the related specifications defined by the |CalibSpecs| object:</span>

<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     calibspecs=calibspecs,</span>
<span class="sd">        ...     names=[name.upper() for name in calibspecs.names],</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;PERCMAX&quot;]</span>
<span class="sd">        Replace(</span>
<span class="sd">            name=&quot;PERCMAX&quot;,</span>
<span class="sd">            parameter=&quot;percmax&quot;,</span>
<span class="sd">            lower=1.0,</span>
<span class="sd">            upper=10.0,</span>
<span class="sd">            parameterstep=&quot;1d&quot;,</span>
<span class="sd">            value=5.0,</span>
<span class="sd">            model=&quot;hland_v1&quot;,</span>
<span class="sd">            selections=(&quot;complete&quot;,),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ci.remove_rules(&quot;FC&quot;, &quot;PERCMAX&quot;)</span>

<span class="sd">        Method |CalibrationInterface.make_rules| raises the following error if</span>
<span class="sd">        you neither pass a |CalibSpecs| object nor the complete list of individual</span>
<span class="sd">        calibration parameter specifications:</span>

<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     names=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     parameters=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     values=[100.0, 5.0],</span>
<span class="sd">        ...     lowers=[50.0, 1.0],</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: When creating rules via method `make_rules`, you must pass a \</span>
<span class="sd">`CalibSpecs` object or provide complete information for the following arguments: \</span>
<span class="sd">names, parameters, values, lowers, and uppers.</span>

<span class="sd">        You can run method |CalibrationInterface.make_rules| in &quot;product mode&quot;,</span>
<span class="sd">        meaning that its execution results in distinct |Rule| objects for all</span>
<span class="sd">        combinations of the given calibration parameters and selections:</span>

<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     calibspecs=calibspecs,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     selections=(&quot;headwaters&quot;, &quot;nonheadwaters&quot;),</span>
<span class="sd">        ...     product=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; tuple(par.__name__ for par in ci.parametertypes)</span>
<span class="sd">        (&#39;FC&#39;, &#39;PercMax&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ci.selections</span>
<span class="sd">        (&#39;headwaters&#39;, &#39;nonheadwaters&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;percmax_headwaters&quot;]</span>
<span class="sd">        Replace(</span>
<span class="sd">            name=&quot;percmax_headwaters&quot;,</span>
<span class="sd">            parameter=&quot;percmax&quot;,</span>
<span class="sd">            lower=1.0,</span>
<span class="sd">            upper=10.0,</span>
<span class="sd">            parameterstep=&quot;1d&quot;,</span>
<span class="sd">            value=5.0,</span>
<span class="sd">            model=&quot;hland_v1&quot;,</span>
<span class="sd">            selections=(&quot;headwaters&quot;,),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;percmax_nonheadwaters&quot;].selections</span>
<span class="sd">        (&#39;nonheadwaters&#39;,)</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;fc_headwaters&quot;].selections</span>
<span class="sd">        (&#39;headwaters&#39;,)</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;fc_nonheadwaters&quot;].selections</span>
<span class="sd">        (&#39;nonheadwaters&#39;,)</span>

<span class="sd">        Trying to run in &quot;product mode&quot; without defining the target selections</span>
<span class="sd">        results in the following error message:</span>

<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     calibspecs=calibspecs,</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     product=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: When creating rules via method `make_rules` in &quot;product mode&quot; \</span>
<span class="sd">(with the argument `product` being `True`), you must supply all target selection \</span>
<span class="sd">objects via argument `selections`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">calibspecs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">lowers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">uppers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;When creating rules via method `make_rules`, you must pass &quot;</span>
                    <span class="s2">&quot;a `CalibSpecs` object or provide complete information for &quot;</span>
                    <span class="s2">&quot;the following arguments: names, parameters, values, lowers, &quot;</span>
                    <span class="s2">&quot;and uppers.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">calibspecs</span><span class="o">.</span><span class="n">names</span>
            <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parameters</span> <span class="o">=</span> <span class="n">calibspecs</span><span class="o">.</span><span class="n">names</span>
            <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">calibspecs</span><span class="o">.</span><span class="n">defaults</span>
            <span class="k">if</span> <span class="n">lowers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lowers</span> <span class="o">=</span> <span class="n">calibspecs</span><span class="o">.</span><span class="n">lowers</span>
            <span class="k">if</span> <span class="n">uppers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">uppers</span> <span class="o">=</span> <span class="n">calibspecs</span><span class="o">.</span><span class="n">uppers</span>
        <span class="n">parameters_</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                <span class="n">types_</span><span class="o">=</span><span class="p">(</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># pylint: disable=isinstance-second-argument-not-valid-type</span>
        <span class="c1"># see https://github.com/PyCQA/pylint/issues/3507</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parametersteps</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parametersteps</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">parametersteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">parametersteps</span><span class="p">,)</span>
        <span class="c1"># pylint: enable=isinstance-second-argument-not-valid-type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters_</span><span class="p">)</span>
            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span>
            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">uppers</span><span class="p">)</span>
            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parametersteps</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When creating rules via method `make_rules`, all &quot;</span>
                <span class="s2">&quot;given sequences must be of equal length.&quot;</span>
            <span class="p">)</span>
        <span class="n">nmb_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters_</span><span class="p">)</span>
        <span class="n">selections2</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">selectiontools</span><span class="o">.</span><span class="n">Selection</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]]</span>
        <span class="k">if</span> <span class="n">product</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">selections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;When creating rules via method `make_rules` in &quot;product mode&quot; &#39;</span>
                    <span class="s2">&quot;(with the argument `product` being `True`), you must supply &quot;</span>
                    <span class="s2">&quot;all target selection objects via argument `selections`.&quot;</span>
                <span class="p">)</span>
            <span class="n">selections</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">selections</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">par</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sel</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">sel</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">selections</span><span class="p">,</span> <span class="n">parameters_</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">nmb_selections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selections</span><span class="p">)</span>
            <span class="n">parameters_</span> <span class="o">=</span> <span class="n">nmb_selections</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters_</span><span class="p">)</span>
            <span class="n">lowers</span> <span class="o">=</span> <span class="n">nmb_selections</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span>
            <span class="n">uppers</span> <span class="o">=</span> <span class="n">nmb_selections</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">uppers</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">nmb_selections</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">parametersteps</span> <span class="o">=</span> <span class="n">nmb_selections</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parametersteps</span><span class="p">)</span>
            <span class="n">selections2</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">sel</span><span class="p">,),</span> <span class="n">nmb_parameters</span><span class="p">)</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">selections</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selections2</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">selections</span><span class="p">,</span> <span class="n">nmb_parameters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">parameterstep</span><span class="p">,</span> <span class="n">selections_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">names</span><span class="p">,</span> <span class="n">parameters_</span><span class="p">,</span> <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">parametersteps</span><span class="p">,</span> <span class="n">selections2</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_rules</span><span class="p">(</span>
                <span class="n">rule</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span>
                    <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">,</span>
                    <span class="n">parameterstep</span><span class="o">=</span><span class="n">parameterstep</span><span class="p">,</span>
                    <span class="n">selections</span><span class="o">=</span><span class="n">selections_</span><span class="p">,</span>
                    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="CalibrationInterface.prepare_logfile"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.prepare_logfile">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_logfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logfilepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">objectivefunction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;result&quot;</span><span class="p">,</span>
        <span class="n">documentation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare a log file.</span>

<span class="sd">        Use argument `objectivefunction` to describe the |TargetFunction| used</span>
<span class="sd">        for calculating the efficiency and argument `documentation` to add</span>
<span class="sd">        some information to the header of the logfile.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span> <span class="o">=</span> <span class="n">logfilepath</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfilepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logfile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">documentation</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">documentation</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
                <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objectivefunction</span><span class="si">}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">)</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;parameterstep&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">steps</span><span class="p">))</span>
            <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CalibrationInterface.update_logfile"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.update_logfile">[docs]</a>    <span class="k">def</span> <span class="nf">update_logfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the current log file, if available.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">logfile</span><span class="p">:</span>
                <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">logfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CalibrationInterface.read_logfile"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.read_logfile">[docs]</a>    <span class="k">def</span> <span class="nf">read_logfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">logfilepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">maximisation</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Read the log file with the given file path.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfilepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">logfile</span><span class="p">:</span>
            <span class="c1"># pylint: disable=not-an-iterable</span>
            <span class="c1"># because pylint is wrong!?</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">logfile</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="c1"># pylint: disable=not-an-iterable</span>
        <span class="n">idx2name</span><span class="p">,</span> <span class="n">idx2rule</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parameterstep</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]),</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">:</span>
                <span class="n">rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">parameterstep</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
                    <span class="n">parameterstep</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parameterstep</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">parameterstep</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parameterstep</span> <span class="o">!=</span> <span class="n">rule</span><span class="o">.</span><span class="n">parameterstep</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The current parameterstep of the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` rule `</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(`</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">parameterstep</span><span class="si">}</span><span class="s2">`) does not agree with the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;one documentated in log file `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span><span class="si">}</span><span class="s2">` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(`</span><span class="si">{</span><span class="n">parameterstep</span><span class="si">}</span><span class="s2">`).&quot;</span>
                    <span class="p">)</span>
                <span class="n">idx2rule</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span>
            <span class="n">idx2name</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">names_int</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">names_ext</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">idx2name</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">names_int</span> <span class="o">!=</span> <span class="n">names_ext</span><span class="p">:</span>
                <span class="n">enumeration</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The names of the rules handled by the actual calibration &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;interface (</span><span class="si">{</span><span class="n">enumeration</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names_int</span><span class="p">))</span><span class="si">}</span><span class="s2">) do not agree &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;with the names in the header of logfile &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_logfilepath</span><span class="si">}</span><span class="s2">` (</span><span class="si">{</span><span class="n">enumeration</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names_ext</span><span class="p">))</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
        <span class="n">jdx_best</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">result_best</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">maximisation</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">maximisation</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">result_best</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">maximisation</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">result_best</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">jdx_best</span> <span class="o">=</span> <span class="n">jdx</span>
                <span class="n">result_best</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">jdx_best</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx2rule</span><span class="p">:</span>
                <span class="n">idx2rule</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result_best</span></div>

    <span class="k">def</span> <span class="nf">_update_elements_when_adding_a_rule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">Rule</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">+=</span> <span class="n">rule</span><span class="o">.</span><span class="n">elements</span>

    <span class="k">def</span> <span class="nf">_update_elements_when_deleting_a_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="n">devicetools</span><span class="o">.</span><span class="n">Elements</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">+=</span> <span class="n">rule</span><span class="o">.</span><span class="n">elements</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The names of all handled |Rule| objects.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The values of all handled |Rule| objects.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lowers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The lower boundaries of all handled |Rule| objects.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">lower</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uppers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The upper boundaries of all handled |Rule| objects.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">upper</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The names of all |Selection| objects addressed at least one of the</span>
<span class="sd">        handled |Rule| objects.</span>

<span class="sd">        See the documentation on method |CalibrationInterface.make_rules| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">selections</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parametertypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The types of all |Parameter| objects addressed by at least one of the</span>
<span class="sd">        handled |Rule| objects.</span>

<span class="sd">        See the documentation on method |CalibrationInterface.make_rules| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">variabletools</span><span class="o">.</span><span class="n">sort_variables</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">parametertype</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_update_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_refresh_hp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">:</span>
            <span class="n">element</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hp</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">apply_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perform_simulation</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">apply_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perform_simulation</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="CalibrationInterface.apply_values"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.apply_values">[docs]</a>    <span class="k">def</span> <span class="nf">apply_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perform_simulation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Apply all current calibration parameter values on all relevant</span>
<span class="sd">        parameters.</span>

<span class="sd">        Set argument `perform_simulation` to |False| to only change the</span>
<span class="sd">        actual parameter values and update the |HydPy| object without</span>
<span class="sd">        performing a simulation run.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">apply_value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_hp</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">perform_simulation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hp</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_likelihood</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CalibrationInterface.reset_parameters"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.reset_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset all relevant parameters to their original states.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_hp</span><span class="p">()</span></div>

<div class="viewcode-block" id="CalibrationInterface.calculate_likelihood"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.calculate_likelihood">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the defined |TargetFunction| and return the result.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_targetfunction</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span></div>

<div class="viewcode-block" id="CalibrationInterface.perform_calibrationstep"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.perform_calibrationstep">[docs]</a>    <span class="k">def</span> <span class="nf">perform_calibrationstep</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="c1"># for optimisers that pass additional informative data</span>
        <span class="sd">&quot;&quot;&quot;Update all calibration parameters with the given values, update</span>
<span class="sd">        the |HydPy| object, perform a simulation run, and calculate and</span>
<span class="sd">        return the achieved efficiency.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_values</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_logfile</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">likelihood</span></div>

<div class="viewcode-block" id="CalibrationInterface.print_table"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibrationInterface.print_table">[docs]</a>    <span class="k">def</span> <span class="nf">print_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parametertypes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">parametertools</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">selections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">),</span>
        <span class="n">fillvalue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">file_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TextIO</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Print the current calibration parameter values in a table format.</span>

<span class="sd">        Please see the documentation on method |CalibrationInterface.make_rules|</span>
<span class="sd">        first, from which we borrow the general setup:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs, CalibrationInterface, nse</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface(</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: sum(nse(node=node) for node in hp.nodes)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(</span>
<span class="sd">        ...     CalibSpec(name=&quot;fc&quot;, default=100.0, lower=50.0, upper=200.0),</span>
<span class="sd">        ...     CalibSpec(</span>
<span class="sd">        ...         name=&quot;percmax&quot;, default=5.0, lower=1.0, upper=10.0, \</span>
<span class="sd">parameterstep=&quot;1d&quot;</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     calibspecs=calibspecs,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ...     selections=(&quot;headwaters&quot;, &quot;nonheadwaters&quot;),</span>
<span class="sd">        ...     product=True,</span>
<span class="sd">        ... )</span>

<span class="sd">        First, we change the values of two |Rule| objects to clarify that all</span>
<span class="sd">        values appear in the correct table cells:</span>

<span class="sd">        &gt;&gt;&gt; ci[&quot;fc_headwaters&quot;].value = 200.0</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;percmax_nonheadwaters&quot;].value = 10.0</span>

<span class="sd">        By default, method |CalibrationInterface.print_table| prints the values</span>
<span class="sd">        of all handled |Rule| objects.  We varies the target control parameters on</span>
<span class="sd">        the first axis and the target selections on the second axis.  Row two and</span>
<span class="sd">        three contain the (identical) lower and upper boundary values corresponding</span>
<span class="sd">        to the respective control parameters:</span>

<span class="sd">        &gt;&gt;&gt; ci.print_table()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 lower  upper  headwaters  nonheadwaters</span>
<span class="sd">        FC       50.0   200.0  200.0       100.0</span>
<span class="sd">        PercMax  1.0    10.0   5.0         10.0</span>

<span class="sd">        For non-identical boundary values, method |CalibrationInterface.print_table|</span>
<span class="sd">        prints fill values in the relevant cells.  Besides this, the following</span>
<span class="sd">        example shows how to define alternative titles for the boundary value columns:</span>

<span class="sd">        &gt;&gt;&gt; ci[&quot;fc_headwaters&quot;].lower = 60.0</span>
<span class="sd">        &gt;&gt;&gt; ci[&quot;percmax_nonheadwaters&quot;].upper = 20.0</span>
<span class="sd">        &gt;&gt;&gt; ci.print_table(bounds=(&quot;min&quot;, &quot;max&quot;))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 min  max    headwaters  nonheadwaters</span>
<span class="sd">        FC       /    200.0  200.0       100.0</span>
<span class="sd">        PercMax  1.0  /      5.0         10.0</span>

<span class="sd">        Pass |None| to argument `bounds` to omit writing any boundary value column:</span>

<span class="sd">        &gt;&gt;&gt; ci.print_table(bounds=None)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 headwaters  nonheadwaters</span>
<span class="sd">        FC       200.0       100.0</span>
<span class="sd">        PercMax  5.0         10.0</span>

<span class="sd">        The next example shows how to change the tabulated target parameters</span>
<span class="sd">        and selections.  Method |CalibrationInterface.print_table| uses the</span>
<span class="sd">        (given alternative) fill value for each parameter-selection-combination</span>
<span class="sd">        not met by any of the available |Rule| objects:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.models.hland.hland_control import CFlux, PercMax</span>
<span class="sd">        &gt;&gt;&gt; ci.print_table(  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ...     parametertypes=(PercMax, CFlux),</span>
<span class="sd">        ...     selections=(&quot;streams&quot;, &quot;headwaters&quot;),</span>
<span class="sd">        ...     bounds=None,</span>
<span class="sd">        ...     fillvalue=&quot;-&quot;)</span>
<span class="sd">    	         streams  headwaters</span>
<span class="sd">        PercMax  -        5.0</span>
<span class="sd">        CFlux    -        -</span>

<span class="sd">        Note that the value of the same calibration parameter might appear</span>
<span class="sd">        multiple times when targeting multiple |Selection| objects:</span>

<span class="sd">        &gt;&gt;&gt; ci[&quot;fc_headwaters&quot;].selections = (&quot;headwaters&quot;, &quot;streams&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ci.print_table(bounds=None)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    	         headwaters  nonheadwaters  streams</span>
<span class="sd">        FC       200.0       100.0	        200.0</span>
<span class="sd">        PercMax  5.0	     10.0	        /</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">none</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;_None&quot;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})()</span>
        <span class="k">if</span> <span class="n">parametertypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parametertypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametertypes</span>
        <span class="k">if</span> <span class="n">selections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">bounds</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parametertypes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selections</span><span class="p">))</span> <span class="o">+</span> <span class="n">delta</span><span class="p">),</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fillvalue</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">parametertypes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="p">:]</span> <span class="o">=</span> <span class="n">selections</span>
        <span class="n">par2idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">par</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parametertypes</span><span class="p">)}</span>
        <span class="n">sel2jdx</span> <span class="o">=</span> <span class="p">{</span><span class="n">sel</span><span class="p">:</span> <span class="n">jdx</span> <span class="o">+</span> <span class="n">delta</span> <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">sel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selections</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">par2idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">parametertype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">rule</span><span class="o">.</span><span class="n">lower</span><span class="p">):</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">lower</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">none</span>
                    <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">rule</span><span class="o">.</span><span class="n">upper</span><span class="p">):</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">upper</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">none</span>
                <span class="k">for</span> <span class="n">selection</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">selections</span><span class="p">:</span>
                    <span class="n">jdx</span> <span class="o">=</span> <span class="n">sel2jdx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">jdx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">value</span>
        <span class="n">table</span><span class="p">[</span><span class="n">table</span> <span class="o">==</span> <span class="n">none</span><span class="p">]</span> <span class="o">=</span> <span class="n">fillvalue</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">file_</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">RuleType1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">rule</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleType1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The actual calibration interface does neither handle a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;normal attribute nor a rule object named `</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleType1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The actual calibration interface does not handle &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;a rule object named `</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Rule</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">classname</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        &gt;&gt;&gt; from hydpy.examples import prepare_full_example_2</span>
<span class="sd">        &gt;&gt;&gt; hp, pub, TestIO = prepare_full_example_2()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import CalibrationInterface, Replace</span>
<span class="sd">        &gt;&gt;&gt; ci = CalibrationInterface[Replace](</span>
<span class="sd">        ...     hp=hp,</span>
<span class="sd">        ...     targetfunction=lambda: None,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ci.make_rules(</span>
<span class="sd">        ...     rule=Replace,</span>
<span class="sd">        ...     names=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     parameters=[&quot;fc&quot;, &quot;percmax&quot;],</span>
<span class="sd">        ...     values=[100.0, 5.0],</span>
<span class="sd">        ...     lowers=[50.0, 1.0],</span>
<span class="sd">        ...     uppers=[200.0, 10.0],</span>
<span class="sd">        ...     parametersteps=&quot;1d&quot;,</span>
<span class="sd">        ...     model=&quot;hland_v1&quot;,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dir(ci)   # doctest: +ELLIPSIS</span>
<span class="sd">        [&#39;add_rules&#39;, &#39;apply_values&#39;, &#39;calculate_likelihood&#39;, &#39;conditions&#39;, \</span>
<span class="sd">&#39;fc&#39;, &#39;get_rule&#39;, &#39;lowers&#39;, &#39;make_rules&#39;, &#39;names&#39;, &#39;parametertypes&#39;, &#39;percmax&#39;, \</span>
<span class="sd">&#39;perform_calibrationstep&#39;, &#39;prepare_logfile&#39;, &#39;print_table&#39;, &#39;read_logfile&#39;, \</span>
<span class="sd">&#39;remove_rules&#39;, &#39;reset_parameters&#39;, &#39;result&#39;, &#39;selections&#39;, &#39;update_logfile&#39;, \</span>
<span class="sd">&#39;uppers&#39;, &#39;values&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">dir_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="ReplaceIUH"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.ReplaceIUH">[docs]</a><span class="k">class</span> <span class="nc">ReplaceIUH</span><span class="p">(</span><span class="n">Rule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A |Rule| class specialised for |IUH| parameters.</span>

<span class="sd">    Usually, it is not a good idea to calibrate the AR and MA coefficients</span>
<span class="sd">    of parameters like |arma_control.Responses| of model |arma_v1| individually.</span>
<span class="sd">    Instead, we need to calibrate the few coefficients of the underlying |IUH|</span>
<span class="sd">    objects, which calculate the ARMA coefficients.  Class |ReplaceIUH| helps</span>
<span class="sd">    to accomplish this task.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Class |ReplaceIUH| is still under development.  For example, it</span>
<span class="sd">        does not address the possibility of different ARMA coefficients</span>
<span class="sd">        related to different discharge thresholds.  Hence, the usage</span>
<span class="sd">        of class |ReplaceIUH| might change in the future.</span>

<span class="sd">    So far, there is no example project containing |arma_v1| models</span>
<span class="sd">    instances.  Therefore, we generate a simple one consisting of two</span>
<span class="sd">    |Element| objects only:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Element, prepare_model, Selection</span>
<span class="sd">    &gt;&gt;&gt; element1 = Element(&quot;element1&quot;, inlets=&quot;in1&quot;, outlets=&quot;out1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; element2 = Element(&quot;element2&quot;, inlets=&quot;in2&quot;, outlets=&quot;out2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; complete = Selection(&quot;complete&quot;, elements=[element1, element2])</span>
<span class="sd">    &gt;&gt;&gt; element1.model = prepare_model(&quot;arma_v1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; element2.model = prepare_model(&quot;arma_v1&quot;)</span>

<span class="sd">    We focus on class |TranslationDiffusionEquation| in the following.</span>
<span class="sd">    We create two separate instances and use to calculate the response</span>
<span class="sd">    coefficients of both |arma_v1| instances:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import TranslationDiffusionEquation</span>
<span class="sd">    &gt;&gt;&gt; tde1 = TranslationDiffusionEquation(u=5.0, d=15.0, x=1.0)</span>
<span class="sd">    &gt;&gt;&gt; tde2 = TranslationDiffusionEquation(u=5.0, d=15.0, x=2.0)</span>
<span class="sd">    &gt;&gt;&gt; element1.model.parameters.control.responses(tde1.arma.coefs)</span>
<span class="sd">    &gt;&gt;&gt; element1.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((0.906536, -0.197555, 0.002128, 0.000276),</span>
<span class="sd">                      (0.842788, -0.631499, 0.061685, 0.015639, 0.0, 0.0, 0.0,</span>
<span class="sd">                       -0.000001, 0.0, 0.0, 0.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; element2.model.parameters.control.responses(tde2.arma.coefs)</span>
<span class="sd">    &gt;&gt;&gt; element2.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((1.298097, -0.536702, 0.072903, -0.001207, -0.00004),</span>
<span class="sd">                      (0.699212, -0.663835, 0.093935, 0.046177, -0.00854)))</span>

<span class="sd">    Next, we define one |ReplaceIUH| for modifying parameter</span>
<span class="sd">    |TranslationDiffusionEquation.u| and another one for changing</span>
<span class="sd">    |TranslationDiffusionEquation.d|:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import ReplaceIUH</span>
<span class="sd">    &gt;&gt;&gt; u = ReplaceIUH(</span>
<span class="sd">    ...     name=&quot;u&quot;,</span>
<span class="sd">    ...     parameter=&quot;responses&quot;,</span>
<span class="sd">    ...     value=5.0,</span>
<span class="sd">    ...     lower=1.0,</span>
<span class="sd">    ...     upper=10.0,</span>
<span class="sd">    ...     selections=[complete],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; d = ReplaceIUH(</span>
<span class="sd">    ...     name=&quot;d&quot;,</span>
<span class="sd">    ...     parameter=&quot;responses&quot;,</span>
<span class="sd">    ...     value=15.0,</span>
<span class="sd">    ...     lower=5.0,</span>
<span class="sd">    ...     upper=50.0,</span>
<span class="sd">    ...     selections=[complete],</span>
<span class="sd">    ... )</span>

<span class="sd">    We add and thereby connect the |Element| and |TranslationDiffusionEquation|</span>
<span class="sd">    objects to both |ReplaceIUH| objects via method |ReplaceIUH.add_iuhs|:</span>

<span class="sd">    &gt;&gt;&gt; u.add_iuhs(element1=tde1, element2=tde2)</span>
<span class="sd">    &gt;&gt;&gt; d.add_iuhs(element1=tde1, element2=tde2)</span>

<span class="sd">    Note that method |ReplaceIUH.add_iuhs| enforces to add all |IUH| objects</span>
<span class="sd">    at ones to avoid inconsistencies that might be hard to track later:</span>

<span class="sd">    &gt;&gt;&gt; d.add_iuhs(element1=tde1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to add `IUH` objects to the `ReplaceIUH` rule \</span>
<span class="sd">`d`, the following error occurred: The given elements (element1) do not \</span>
<span class="sd">agree with the complete set of relevant elements (element1 and element2).</span>

<span class="sd">    By default, each |ReplaceIUH| objects triggers the calculation of the ARMA</span>
<span class="sd">    coefficients during the execution of its method |ReplaceIUH.apply_value|,</span>
<span class="sd">    which can be a waste of computation time if we want to calibrate multiple</span>
<span class="sd">    |IUH| coefficients.  To save computation time in such cases, set option</span>
<span class="sd">    |ReplaceIUH.update_parameters| to |False| for all except the lastly</span>
<span class="sd">    executed |ReplaceIUH| objects:</span>

<span class="sd">    &gt;&gt;&gt; u.update_parameters = False</span>

<span class="sd">    Now, changing the value of rule `u` and calling method</span>
<span class="sd">    |ReplaceIUH.apply_value| does not affect the coefficients of both</span>
<span class="sd">    |arma_control.Responses| parameters:</span>

<span class="sd">    &gt;&gt;&gt; u.value = 10.0</span>
<span class="sd">    &gt;&gt;&gt; u.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; tde1</span>
<span class="sd">    TranslationDiffusionEquation(d=15.0, u=10.0, x=1.0)</span>
<span class="sd">    &gt;&gt;&gt; element1.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((0.906536, -0.197555, 0.002128, 0.000276),</span>
<span class="sd">                      (0.842788, -0.631499, 0.061685, 0.015639, 0.0, 0.0, 0.0,</span>
<span class="sd">                       -0.000001, 0.0, 0.0, 0.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; tde2</span>
<span class="sd">    TranslationDiffusionEquation(d=15.0, u=10.0, x=2.0)</span>
<span class="sd">    &gt;&gt;&gt; element2.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((1.298097, -0.536702, 0.072903, -0.001207, -0.00004),</span>
<span class="sd">                      (0.699212, -0.663835, 0.093935, 0.046177, -0.00854)))</span>

<span class="sd">    On the other side, calling method |ReplaceIUH.apply_value| of rule `d`</span>
<span class="sd">    does activate the freshly set value of rule `d` and the previously set</span>
<span class="sd">    value of rule `u`, as well:</span>

<span class="sd">    &gt;&gt;&gt; d.value = 50.0</span>
<span class="sd">    &gt;&gt;&gt; d.apply_value()</span>
<span class="sd">    &gt;&gt;&gt; tde1</span>
<span class="sd">    TranslationDiffusionEquation(d=50.0, u=10.0, x=1.0)</span>
<span class="sd">    &gt;&gt;&gt; element1.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((0.811473, -0.15234, -0.000256, 0.000177),</span>
<span class="sd">                      (0.916619, -0.670781, 0.087185, 0.007923)))</span>
<span class="sd">    &gt;&gt;&gt; tde2</span>
<span class="sd">    TranslationDiffusionEquation(d=50.0, u=10.0, x=2.0)</span>
<span class="sd">    &gt;&gt;&gt; element2.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((0.832237, -0.167205, 0.002007, 0.000184),</span>
<span class="sd">                      (0.836513, -0.555399, 0.037628, 0.014035)))</span>

<span class="sd">    Use method |ReplaceIUH.reset_parameters| to restore the original</span>
<span class="sd">    ARMA coefficients:</span>

<span class="sd">    &gt;&gt;&gt; d.reset_parameters()</span>
<span class="sd">    &gt;&gt;&gt; element1.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((0.906536, -0.197555, 0.002128, 0.000276),</span>
<span class="sd">                      (0.842788, -0.631499, 0.061685, 0.015639, 0.0, 0.0, 0.0,</span>
<span class="sd">                       -0.000001, 0.0, 0.0, 0.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; element2.model.parameters.control.responses</span>
<span class="sd">    responses(th_0_0=((1.298097, -0.536702, 0.072903, -0.001207, -0.00004),</span>
<span class="sd">                      (0.699212, -0.663835, 0.093935, 0.046177, -0.00854)))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">update_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;Flag indicating whether method |ReplaceIUH.apply_value| should </span>
<span class="sd">    calculate the |ARMA.coefs| and pass them to the relevant model parameter</span>
<span class="sd">    or not.</span>

<span class="sd">    Set this flag to |False| for the first |ReplaceIUH| object when another</span>
<span class="sd">    one handles the same elements and is applied afterwards.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_element2iuh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">iuhtools</span><span class="o">.</span><span class="n">IUH</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_original_parameter_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">ar_coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">par</span><span class="o">.</span><span class="n">ma_coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ReplaceIUH.add_iuhs"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.ReplaceIUH.add_iuhs">[docs]</a>    <span class="k">def</span> <span class="nf">add_iuhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">**</span><span class="n">iuhs</span><span class="p">:</span> <span class="n">iuhtools</span><span class="o">.</span><span class="n">IUH</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add one |IUH| object for each relevant |Element| objects.</span>

<span class="sd">        See the main documentation on class |ReplaceIUH| for further</span>
<span class="sd">        information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">names_int</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">names_ext</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">iuhs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">names_int</span> <span class="o">!=</span> <span class="n">names_ext</span><span class="p">:</span>
                <span class="n">enumeration</span> <span class="o">=</span> <span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given elements (</span><span class="si">{</span><span class="n">enumeration</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names_ext</span><span class="p">))</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;do not agree with the complete set of relevant &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;elements (</span><span class="si">{</span><span class="n">enumeration</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names_int</span><span class="p">))</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="n">element2iuh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element2iuh</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="n">element2iuh</span><span class="p">[</span><span class="n">element</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">iuhs</span><span class="p">[</span><span class="n">element</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to add `IUH` objects to the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` rule `</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">`&quot;</span>
            <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_iuhs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">iuhtools</span><span class="o">.</span><span class="n">IUH</span><span class="p">]:</span>
        <span class="n">element2iuh</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element2iuh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element2iuh</span>
        <span class="k">for</span> <span class="n">iuh</span> <span class="ow">in</span> <span class="n">element2iuh</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">iuh</span>

<div class="viewcode-block" id="ReplaceIUH.apply_value"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.ReplaceIUH.apply_value">[docs]</a>    <span class="k">def</span> <span class="nf">apply_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply all current calibration parameter values on all relevant</span>
<span class="sd">        |IUH| objects and eventually update the ARMA coefficients of the</span>
<span class="sd">        related parameter.</span>

<span class="sd">        See the main documentation on class |CalibrationInterface| for</span>
<span class="sd">        further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">iuh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iuhs</span><span class="p">):</span>
            <span class="c1"># entries = self.name.split(&quot;_&quot;)</span>
            <span class="c1"># name = entries[0]</span>
            <span class="c1"># threshold = &quot;_&quot;.join(entries[1:])</span>
            <span class="c1"># setattr(iuh, self.name, self.value)</span>
            <span class="c1"># if self.update_parameters:</span>
            <span class="c1">#     try:</span>
            <span class="c1">#         parameter(iuh.arma.coefs)</span>
            <span class="c1">#     except RuntimeError:</span>
            <span class="c1">#         parameter(((), iuh.ma.coefs))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">iuh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_parameters</span><span class="p">:</span>
                <span class="n">parameter</span><span class="p">(</span><span class="n">iuh</span><span class="o">.</span><span class="n">arma</span><span class="o">.</span><span class="n">coefs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReplaceIUH.reset_parameters"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.ReplaceIUH.reset_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset all relevant parameter objects to their original states.</span>

<span class="sd">        See the main documentation on class |ReplaceIUH| for further</span>
<span class="sd">        information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">orig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_parameter_values</span><span class="p">):</span>
            <span class="n">parameter</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CalibSpec"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibSpec">[docs]</a><span class="k">class</span> <span class="nc">CalibSpec</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper class for specifying the properties of a single calibration parameter.</span>

<span class="sd">    So far, class |CalibSpec| does not provide much functionality, besides checking</span>
<span class="sd">    upon initialisation that the given default and boundary values are consistent:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import CalibSpec</span>
<span class="sd">    &gt;&gt;&gt; CalibSpec(</span>
<span class="sd">    ...     name=&quot;par1&quot;,</span>
<span class="sd">    ...     default=1.0,</span>
<span class="sd">    ... )</span>
<span class="sd">    CalibSpec(name=&quot;par1&quot;, default=1.0)</span>

<span class="sd">    &gt;&gt;&gt; CalibSpec(</span>
<span class="sd">    ...     name=&quot;par1&quot;,</span>
<span class="sd">    ...     default=1.0,</span>
<span class="sd">    ...     lower=2.0,</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: The following values given for calibration parameter `par1` are not \</span>
<span class="sd">consistent: default=1.0, lower=2.0, upper=inf.</span>

<span class="sd">    &gt;&gt;&gt; CalibSpec(</span>
<span class="sd">    ...     name=&quot;par1&quot;,</span>
<span class="sd">    ...     default=1.0,</span>
<span class="sd">    ...     upper=0.5,</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: The following values given for calibration parameter `par1` are not \</span>
<span class="sd">consistent: default=1.0, lower=-inf, upper=0.5.</span>

<span class="sd">    &gt;&gt;&gt; CalibSpec(</span>
<span class="sd">    ...     name=&quot;par1&quot;,</span>
<span class="sd">    ...     default=1.0,</span>
<span class="sd">    ...     lower=0.0,</span>
<span class="sd">    ...     upper=2.0,</span>
<span class="sd">    ... )</span>
<span class="sd">    CalibSpec(name=&quot;par1&quot;, default=1.0, lower=0.0, upper=2.0)</span>

<span class="sd">    Use the `parameterstep` argument for time-dependent calibration parameters:</span>

<span class="sd">    &gt;&gt;&gt; CalibSpec(</span>
<span class="sd">    ...     name=&quot;par1&quot;,</span>
<span class="sd">    ...     default=1.0/3.0,</span>
<span class="sd">    ...     lower=1.0/3.0,</span>
<span class="sd">    ...     upper=1.0/3.0,</span>
<span class="sd">    ...     parameterstep=&quot;1d&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    CalibSpec(</span>
<span class="sd">        name=&quot;par1&quot;, default=0.333333, lower=0.333333, upper=0.333333, \</span>
<span class="sd">parameterstep=&quot;1d&quot;</span>
<span class="sd">    )</span>

<span class="sd">    See the documentation on class |CalibSpecs| for further information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="sd">&quot;&quot;&quot;Name of the calibration parameter.&quot;&quot;&quot;</span>
    <span class="n">default</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;The default value of the calibration parameter.&quot;&quot;&quot;</span>
    <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;Lower bound of the allowed calibration parameter value.&quot;&quot;&quot;</span>
    <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;Upper bound of the allowed calibration parameter value.&quot;&quot;&quot;</span>
    <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The parameter step size to be set before applying the defined </span>
<span class="sd">    calibration parameter values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">parameterstep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">PeriodConstrArg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">default</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The following values given for calibration parameter `</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">` are &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not consistent: default=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="n">default</span><span class="p">)</span><span class="si">}</span><span class="s2">, lower=&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2">, upper=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="k">if</span> <span class="n">parameterstep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span> <span class="o">=</span> <span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">parameterstep</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;name=&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;default=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">):</span>
            <span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lower=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">):</span>
            <span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upper=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;parameterstep=&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameterstep</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">black</span><span class="o">.</span><span class="n">format_str</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">black</span><span class="o">.</span><span class="n">FileMode</span><span class="p">(),</span>
        <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="CalibSpecs"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibSpecs">[docs]</a><span class="k">class</span> <span class="nc">CalibSpecs</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Collection class for handling |CalibSpec| objects.</span>

<span class="sd">    The primary purpose of class |CalibSpecs| is to handle multiple |CalibSpec|</span>
<span class="sd">    objects and to make all their attributes accessible in the same order. See</span>
<span class="sd">    property |CalibSpecs.names| as one example.  Note that all such properties are</span>
<span class="sd">    sorted in the order or the attachment of the different |CalibSpec| objects:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">    &gt;&gt;&gt; calibspecs = CalibSpecs(</span>
<span class="sd">    ...     CalibSpec(</span>
<span class="sd">    ...         name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ...     CalibSpec(name=&quot;second&quot;, default=1.0, lower=0.0),</span>
<span class="sd">    ...     CalibSpec(name=&quot;first&quot;,default=2.0, upper=2.0),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; calibspecs</span>
<span class="sd">    CalibSpecs(</span>
<span class="sd">        CalibSpec(name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, \</span>
<span class="sd">parameterstep=&quot;1d&quot;),</span>
<span class="sd">        CalibSpec(name=&quot;second&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        CalibSpec(name=&quot;first&quot;, default=2.0, upper=2.0),</span>
<span class="sd">    )</span>

<span class="sd">    You can query and remove |CalibSpec| objects via keyword and attribute access:</span>

<span class="sd">    &gt;&gt;&gt; print(calibspecs)</span>
<span class="sd">    CalibSpecs(&quot;third&quot;, &quot;second&quot;, &quot;first&quot;)</span>

<span class="sd">    &gt;&gt;&gt; third = calibspecs[&quot;third&quot;]</span>
<span class="sd">    &gt;&gt;&gt; third in calibspecs</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; del calibspecs[&quot;third&quot;]</span>
<span class="sd">    &gt;&gt;&gt; third in calibspecs</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; calibspecs[&quot;third&quot;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    KeyError: &#39;The current `CalibSpecs` object does not handle a `CalibSpec` object \</span>
<span class="sd">named `third`.&#39;</span>
<span class="sd">    &gt;&gt;&gt; del calibspecs[&quot;third&quot;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    KeyError: &#39;The current `CalibSpecs` object does not handle a `CalibSpec` object \</span>
<span class="sd">named `third`.&#39;</span>

<span class="sd">    &gt;&gt;&gt; second = calibspecs.second</span>
<span class="sd">    &gt;&gt;&gt; &quot;second&quot; in calibspecs</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; del calibspecs.second</span>
<span class="sd">    &gt;&gt;&gt; &quot;second&quot; in calibspecs</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; calibspecs.second</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The current `CalibSpecs` object does neither handle a `CalibSpec` \</span>
<span class="sd">object nor a normal attribute named `second`.</span>
<span class="sd">    &gt;&gt;&gt; del calibspecs.second</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError: The current `CalibSpecs` object does not handle a `CalibSpec` \</span>
<span class="sd">object named `second`.</span>

<span class="sd">    &gt;&gt;&gt; len(calibspecs)</span>
<span class="sd">    1</span>

<span class="sd">    Now we can re-append the previously removed |CalibSpec| objects (and thereby</span>
<span class="sd">    bring the order of attachment in agreement with the |CalibSpec| names):</span>

<span class="sd">    &gt;&gt;&gt; calibspecs.append(second, third)</span>
<span class="sd">    &gt;&gt;&gt; for calibspec in calibspecs:</span>
<span class="sd">    ...     print(calibspec)</span>
<span class="sd">    first</span>
<span class="sd">    second</span>
<span class="sd">    third</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_name2parspec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CalibSpec</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">parspecs</span><span class="p">:</span> <span class="n">CalibSpec</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span> <span class="o">=</span> <span class="p">{</span><span class="n">parspec</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">parspec</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="n">parspecs</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalibSpec</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The current `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` object does not handle a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`CalibSpec` object named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The current `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` object does not handle a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`CalibSpec` object named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalibSpec</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The current `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` object does neither handle a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`CalibSpec` object nor a normal attribute named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The current `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` object does not handle a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`CalibSpec` object named `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CalibSpec</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">CalibSpec</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">value</span>

<div class="viewcode-block" id="CalibSpecs.append"><a class="viewcode-back" href="../../../calibtools.html#hydpy.auxs.calibtools.CalibSpecs.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">calibspecs</span><span class="p">:</span> <span class="n">CalibSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Append one or more |CalibSpec| objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; first = CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0)</span>
<span class="sd">        &gt;&gt;&gt; second = CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs()</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(first)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(second, third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs</span>
<span class="sd">        CalibSpecs(</span>
<span class="sd">            CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">            CalibSpec(name=&quot;second&quot;, default=2.0, upper=2.0),</span>
<span class="sd">            CalibSpec(name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, \</span>
<span class="sd">parameterstep=&quot;1d&quot;),</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">calibspec</span> <span class="ow">in</span> <span class="n">calibspecs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="p">[</span><span class="n">calibspec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">calibspec</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The names of all |CalibSpec| objects in the order of attachment.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0))</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.names</span>
<span class="sd">        (&#39;first&#39;, &#39;second&#39;, &#39;third&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parspec</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The default values of all |CalibSpec| objects in the order of attachment.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0))</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.defaults</span>
<span class="sd">        (1.0, 2.0, 3.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parspec</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lowers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The lower boundary values of all |CalibSpec| objects in the order of</span>
<span class="sd">        attachment.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0))</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.lowers</span>
<span class="sd">        (0.0, -inf, -10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parspec</span><span class="o">.</span><span class="n">lower</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uppers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The upper boundary values of all |CalibSpec| objects in the order of</span>
<span class="sd">        attachment.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0))</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.uppers</span>
<span class="sd">        (inf, 2.0, 10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parspec</span><span class="o">.</span><span class="n">upper</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parametersteps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">timetools</span><span class="o">.</span><span class="n">Period</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The parameter steps of all |CalibSpec| objects in the order of attachment.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs</span>
<span class="sd">        &gt;&gt;&gt; third = CalibSpec(</span>
<span class="sd">        ...     name=&quot;third&quot;, default=3.0, lower=-10.0, upper=10.0, parameterstep=&quot;1d&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0, lower=0.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0, upper=2.0))</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.append(third)</span>
<span class="sd">        &gt;&gt;&gt; calibspecs.parametersteps</span>
<span class="sd">        (None, None, Period(&quot;1d&quot;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parspec</span><span class="o">.</span><span class="n">parameterstep</span> <span class="k">for</span> <span class="n">parspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">black</span><span class="o">.</span><span class="n">format_str</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">black</span><span class="o">.</span><span class="n">FileMode</span><span class="p">(),</span>
        <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name2parspec</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">black</span><span class="o">.</span><span class="n">format_str</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">black</span><span class="o">.</span><span class="n">FileMode</span><span class="p">(),</span>
        <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import CalibSpec, CalibSpecs, print_values</span>
<span class="sd">        &gt;&gt;&gt; calibspecs = CalibSpecs(CalibSpec(name=&quot;first&quot;, default=1.0),</span>
<span class="sd">        ...                         CalibSpec(name=&quot;second&quot;,default=2.0))</span>
<span class="sd">        &gt;&gt;&gt; print_values(dir(calibspecs))</span>
<span class="sd">        __annotations__, __class__, __contains__, __delattr__, __delitem__,</span>
<span class="sd">        __dict__, __dir__, __doc__, __eq__, __format__, __ge__, __getattr__,</span>
<span class="sd">        __getattribute__, __getitem__, __gt__, __hash__, __init__,</span>
<span class="sd">        __init_subclass__, __iter__, __le__, __len__, __lt__, __module__,</span>
<span class="sd">        __ne__, __new__, __reduce__, __reduce_ex__, __repr__, __setattr__,</span>
<span class="sd">        __sizeof__, __str__, __subclasshook__, __weakref__, _name2parspec,</span>
<span class="sd">        append, defaults, first, lowers, names, parametersteps, second, uppers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 4.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.calibtools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>