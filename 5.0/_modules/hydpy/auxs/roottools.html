<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.auxs.roottools &#8212; HydPy 5.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=127cebf3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=eafc0fe6" />
    
    <script src="../../../_static/documentation_options.js?v=f98c4cc8"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.roottools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to.html">How to…</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework.html">Framework Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modelcollection.html">Model Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.roottools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module specialises class |Submodel| for root-finding problems.</span>

<span class="sd">Module |roottools| provides Python interfaces only.  See the</span>
<span class="sd">Cython extension module `rootutils` for the actual implementations</span>
<span class="sd">of the mathematical algorithms.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">from</span> <span class="nn">hydpy.core</span> <span class="kn">import</span> <span class="n">modeltools</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">hydpy.cythons</span> <span class="kn">import</span> <span class="n">rootutils</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">hydpy.cythons.autogen</span> <span class="kn">import</span> <span class="n">rootutils</span>


<div class="viewcode-block" id="Pegasus">
<a class="viewcode-back" href="../../../roottools.html#hydpy.auxs.roottools.Pegasus">[docs]</a>
<span class="k">class</span> <span class="nc">Pegasus</span><span class="p">(</span><span class="n">modeltools</span><span class="o">.</span><span class="n">Submodel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Root-finder based on the `Pegasus method`_.</span>

<span class="sd">    .. _`Pegasus method`: https://link.springer.com/article/10.1007/BF01932959</span>

<span class="sd">    The Pegasus method is a root-finding algorithm which sequentially</span>
<span class="sd">    decreases its search radius (like the simple bisection algorithm)</span>
<span class="sd">    and shows superlinear convergence properties (like the Newton-Raphson</span>
<span class="sd">    algorithm).  Our implementation adds a simple &quot;interval widening&quot;</span>
<span class="sd">    strategy that comes into play when the given initial interval does not</span>
<span class="sd">    contain the root.  This widening should be left for emergencies as</span>
<span class="sd">    it might be not always efficient.  So please try to provide to</span>
<span class="sd">    initial interval estimates that rather overestimate than underestimate</span>
<span class="sd">    the interval width.  Additionally, make sure you apply |Pegasus| on</span>
<span class="sd">    monotone functions only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CYTHONBASECLASS</span> <span class="o">=</span> <span class="n">rootutils</span><span class="o">.</span><span class="n">PegasusBase</span>  <span class="c1"># pylint: disable=used-before-assignment</span>
    <span class="n">PYTHONCLASS</span> <span class="o">=</span> <span class="n">rootutils</span><span class="o">.</span><span class="n">PegasusPython</span>
    <span class="n">_cysubmodel</span><span class="p">:</span> <span class="n">rootutils</span><span class="o">.</span><span class="n">PegasusBase</span>

<div class="viewcode-block" id="Pegasus.find_x">
<a class="viewcode-back" href="../../../roottools.html#hydpy.auxs.roottools.Pegasus.find_x">[docs]</a>
    <span class="k">def</span> <span class="nf">find_x</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">xmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">xmax</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">xtol</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">ytol</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">itermax</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the relevant root within the interval</span>
<span class="sd">        :math:`x0 \\leq x \\leq x1` with an accuracy meeting at least</span>
<span class="sd">        one of the absolute tolerance values `xtol` and `ytol` (or the</span>
<span class="sd">        accuracy achieved by performing the maximum number of iteration</span>
<span class="sd">        steps, defined by argument `itermax`).</span>

<span class="sd">        The arguments `xmin` and `xmax` define the smallest and largest</span>
<span class="sd">        allowed `x` value, respectively.  Method |Pegasus.find_x| never</span>
<span class="sd">        evaluates the underlying function for any `x` value outside these</span>
<span class="sd">        bounds, even if its &quot;interval widening&quot; strategy suggests so.</span>
<span class="sd">        Instead, it returns the relevant `xmin` or `xmax` value.</span>

<span class="sd">        In the following, we explain the details of our Pegasus implementation</span>
<span class="sd">        by using method |lland_model.Return_TempSSurface_V1|.</span>

<span class="sd">        Method |lland_model.Return_TempSSurface_V1| (used by application model</span>
<span class="sd">        |lland_v3|) implements the Pegasus iteration to determine the surface</span>
<span class="sd">        temperature of the snow layer with the help of the Pegasus subclass</span>
<span class="sd">        |lland_model.PegasusTempSSurface|.  For the correct surface</span>
<span class="sd">        temperature, the net energy gain of the surface (defined by method</span>
<span class="sd">        |lland_model.Return_EnergyGainSnowSurface_V1|) must be zero.</span>
<span class="sd">        Iteration is necessary, as some terms of the net energy gain (for</span>
<span class="sd">        example, the emitted longwave radiation) depend on the surface</span>
<span class="sd">        temperature in a non-linear manner.</span>

<span class="sd">        As a starting point, we use the setting provided by the documentation</span>
<span class="sd">        on method |lland_model.Return_TempSSurface_V1| but work in pure Python</span>
<span class="sd">        mode for flexibility (more specifically, to have direct access to</span>
<span class="sd">        method `find_x`) and focus on a single hydrological response unit</span>
<span class="sd">        for simplicity:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import pub</span>
<span class="sd">        &gt;&gt;&gt; with pub.options.usecython(False):</span>
<span class="sd">        ...     from hydpy.models.lland import *</span>
<span class="sd">        ...     simulationstep(&quot;1d&quot;)</span>
<span class="sd">        ...     parameterstep(&quot;1d&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nhru(1)</span>
<span class="sd">        &gt;&gt;&gt; lnk(ACKER)</span>
<span class="sd">        &gt;&gt;&gt; turb0(2.0)</span>
<span class="sd">        &gt;&gt;&gt; turb1(2.0)</span>
<span class="sd">        &gt;&gt;&gt; ktschnee(5.0)</span>
<span class="sd">        &gt;&gt;&gt; derived.days.update()</span>
<span class="sd">        &gt;&gt;&gt; inputs.relativehumidity = 60.0</span>
<span class="sd">        &gt;&gt;&gt; states.waes.values = 1.0</span>
<span class="sd">        &gt;&gt;&gt; fluxes.tkor = -3.0</span>
<span class="sd">        &gt;&gt;&gt; fluxes.reducedwindspeed2m = 3.0</span>
<span class="sd">        &gt;&gt;&gt; fluxes.actualvapourpressure = 2.9</span>
<span class="sd">        &gt;&gt;&gt; fluxes.netshortwaveradiationsnow = 10.0</span>
<span class="sd">        &gt;&gt;&gt; aides.temps = -2.0</span>
<span class="sd">        &gt;&gt;&gt; aides.rlatm = 200.0</span>

<span class="sd">        Method |lland_model.Return_TempSSurface_V1| finds the following</span>
<span class="sd">        surface temperature value:</span>

<span class="sd">        &gt;&gt;&gt; model.idx_hru = 0</span>
<span class="sd">        &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_tempssurface_v1(0))</span>
<span class="sd">        -8.307868</span>

<span class="sd">        We confirm that the net energy gain corresponding to this surface</span>
<span class="sd">        temperature is approximately zero to validate this result:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(-8.3078682))</span>
<span class="sd">        0.0</span>

<span class="sd">        Method `apply_method0` always calls the appropriate target</span>
<span class="sd">        method, which is, for |lland_model.PegasusTempSSurface|,</span>
<span class="sd">        method |lland_model.Return_EnergyGainSnowSurface_V1|:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.apply_method0(-8.3078682))</span>
<span class="sd">        0.0</span>

<span class="sd">        To check for some exceptional cases, we call the `find_x` method of</span>
<span class="sd">        class |lland_model.PegasusTempSSurface| directly.  First, we pass</span>
<span class="sd">        the same arguments as in method |lland_model.Return_TempSSurface_V1|</span>
<span class="sd">        and thus get the same result:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        -8.307868</span>

<span class="sd">        Through decreasing the maximum number of iterations, the result</span>
<span class="sd">        becomes less accurate:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 3))</span>
<span class="sd">        -8.312628</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(-8.312628))</span>
<span class="sd">        0.09905</span>

<span class="sd">        Use the `ytol` argument to control the achieved accuracy more</span>
<span class="sd">        explicitly:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.0, 0.1, 10))</span>
<span class="sd">        -8.312628</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(-8.312628))</span>
<span class="sd">        0.09905</span>

<span class="sd">        Pass an `xtol` value larger than zero to stop iteration as soon as</span>
<span class="sd">        the search interval is small enough:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.1, 1e-8, 10))</span>
<span class="sd">        -8.30786</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(-8.30786))</span>
<span class="sd">        -0.000171</span>

<span class="sd">        `x0` does not need to be smaller than `x1`, and `xmin` does not need to be</span>
<span class="sd">        smaller than `xmax` by necessity (the algorithm swaps values when necessary):</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     50.0, -50.0, 100.0, -100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        -8.307868</span>

<span class="sd">        An ill-defined initial interval might decrease efficiency but</span>
<span class="sd">        should usually not affect the result:</span>

<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     0.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        -8.307868</span>
<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, -20.0, -100.0, 100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        -8.307868</span>

<span class="sd">        Defining proper values for arguments `xmin` and `xmax` provides a way to</span>
<span class="sd">        prevent possible program crashes.  As an example, we do not care about</span>
<span class="sd">        physics and set the snow layer&#39;s temperature to -300 °C.  Theoretically,</span>
<span class="sd">        the surface temperature must also be (unrealistically) low to prevent a</span>
<span class="sd">        considerable energy gain of the surface due to an extreme temperature</span>
<span class="sd">        gradient within the snow layer. However, -100 °C is the lowest value allowed,</span>
<span class="sd">        so method |lland_model.PegasusTempSSurface| returns this boundary-value.</span>
<span class="sd">        It is up to the model developer to handle such misleading responses</span>
<span class="sd">        (if possible):</span>

<span class="sd">        &gt;&gt;&gt; aides.temps = -400</span>
<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        -100.0</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(-100.0))</span>
<span class="sd">        -524.133374</span>

<span class="sd">        To demonstrate the upper boundary&#39;s functionality, we set the snow layer</span>
<span class="sd">        temperature to 4&#39;000 °C (also not the most plausible value, of course):</span>

<span class="sd">        &gt;&gt;&gt; aides.temps = 4000.0</span>
<span class="sd">        &gt;&gt;&gt; round_(model.pegasustempssurface.find_x(</span>
<span class="sd">        ...     -50.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 10))</span>
<span class="sd">        100.0</span>
<span class="sd">        &gt;&gt;&gt; round_(model.return_energygainsnowsurface_v1(100.0))</span>
<span class="sd">        3561.059134</span>

<span class="sd">        Finally, we evaluate some additional snow layer temperatures</span>
<span class="sd">        to show that everything works consistently:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import print_values</span>
<span class="sd">        &gt;&gt;&gt; for temps in [-500, -400, -300, -4, -2, 2, 2000, 3000, 4000]:</span>
<span class="sd">        ...    aides.temps = temps</span>
<span class="sd">        ...    tempssurface = model.pegasustempssurface.find_x(</span>
<span class="sd">        ...        -50.0, 5.0, -100.0, 100.0, 0.0, 1e-8, 10)</span>
<span class="sd">        ...    energygain = model.return_energygainsnowsurface_v1(tempssurface)</span>
<span class="sd">        ...    print_values([temps, tempssurface, energygain])</span>
<span class="sd">        -500, -100.0, -1024.133374</span>
<span class="sd">        -400, -100.0, -524.133374</span>
<span class="sd">        -300, -100.0, -24.133374</span>
<span class="sd">        -4, -8.790047, 0.0</span>
<span class="sd">        -2, -8.307868, 0.0</span>
<span class="sd">        2, -7.353441, 0.0</span>
<span class="sd">        2000, 85.175508, 0.0</span>
<span class="sd">        3000, 97.204856, 0.0</span>
<span class="sd">        4000, 100.0, 3561.059134</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cysubmodel</span><span class="o">.</span><span class="n">find_x</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">ytol</span><span class="p">,</span> <span class="n">itermax</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pegasus.apply_method0">
<a class="viewcode-back" href="../../../roottools.html#hydpy.auxs.roottools.Pegasus.apply_method0">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_method0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the model method relevant for root-finding.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cysubmodel</span><span class="o">.</span><span class="n">apply_method0</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.roottools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>