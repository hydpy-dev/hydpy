<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydpy.auxs.ppolytools &#8212; HydPy 6.3dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=127cebf3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    
    <script src="../../../_static/documentation_options.js?v=6fd2034b"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.ppolytools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/HydPy_Logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example_projects.html">Example Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference_manual.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zbibliography.html">Bibliography</a></li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hydpy.auxs.ppolytools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module implements interpolation approaches based on piecewise polynomials</span>
<span class="sd">required for some models implemented in the *HydPy* framework.</span>

<span class="sd">The relevant models perform the interpolation during simulation runs, which is why we</span>
<span class="sd">implement the related methods in the Cython extension module |ppolyutils|.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># import...</span>
<span class="c1"># ...from standard library</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># ...from site-packages</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="c1"># ...from HydPy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">exceptiontools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">objecttools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">propertytools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.core.typingtools</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.auxs</span><span class="w"> </span><span class="kn">import</span> <span class="n">interptools</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolate</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons</span><span class="w"> </span><span class="kn">import</span> <span class="n">ppolyutils</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">special</span> <span class="o">=</span> <span class="n">exceptiontools</span><span class="o">.</span><span class="n">OptionalImport</span><span class="p">(</span><span class="s2">&quot;special&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;scipy.interpolate&quot;</span><span class="p">],</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">hydpy.cythons.autogen</span><span class="w"> </span><span class="kn">import</span> <span class="n">ppolyutils</span>


<div class="viewcode-block" id="Poly">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.Poly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Poly</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parameter handler for a power series representation of a single polynomial</span>
<span class="sd">    function.</span>

<span class="sd">    The following |Poly| object corresponds to the polynomial function</span>
<span class="sd">    :math:`f(x) = 2 + 3 \cdot (x - 1) + 4 \cdot (x - 1)^2`:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Poly</span>
<span class="sd">    &gt;&gt;&gt; p = Poly(x0=1.0, cs=(2.0, 3.0, 4.0))</span>

<span class="sd">    Proper application of the constant and all coefficients for :math:`x = 3` results</span>
<span class="sd">    in 24:</span>

<span class="sd">    &gt;&gt;&gt; x = 3.0</span>
<span class="sd">    &gt;&gt;&gt; p.cs[0] + p.cs[1] * (x - p.x0) + p.cs[2] * (x - p.x0) ** 2</span>
<span class="sd">    24.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constant of the power series.&quot;&quot;&quot;</span>
    <span class="n">cs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Coefficients of the power series.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Poly.assignrepr">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.Poly.assignrepr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assignrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the actual |ppolytools.Poly| object</span>
<span class="sd">        prefixed with the given string.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Poly</span>
<span class="sd">        &gt;&gt;&gt; poly = Poly(x0=1.0/3.0, cs=(2.0, 3.0, 4.0/3.0))</span>
<span class="sd">        &gt;&gt;&gt; poly</span>
<span class="sd">        Poly(x0=0.333333, cs=(2.0, 3.0, 1.333333))</span>
<span class="sd">        &gt;&gt;&gt; print(poly.assignrepr(prefix=&quot;poly = &quot;))</span>
<span class="sd">        poly = Poly(x0=0.333333, cs=(2.0, 3.0, 1.333333))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;x0=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;cs=</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="PPoly">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PPoly</span><span class="p">(</span><span class="n">interptools</span><span class="o">.</span><span class="n">InterpAlgorithm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Piecewise polynomial interpolator.</span>

<span class="sd">    Class |PPoly| supports univariate data interpolation via multiple polynomial</span>
<span class="sd">    functions.  Typical use cases are linear or spline interpolation.  The primary</span>
<span class="sd">    purpose of |PPoly| is to allow for such interpolation within model equations (for</span>
<span class="sd">    example, to represent the relationship between water volume and water stage as in</span>
<span class="sd">    the model |dam_v001|).  Then, the user selects |PPoly| as the interpolation</span>
<span class="sd">    algorithm employed by parameters derived from |SimpleInterpolator| (e.g.</span>
<span class="sd">    |dam_control.WaterVolume2WaterLevel|) or |SeasonalInterpolator| (e.g.</span>
<span class="sd">    |dam_control.WaterLevel2FloodDischarge|).  However, one can apply |PPoly| also</span>
<span class="sd">    directly, as shown in the following examples.</span>

<span class="sd">    You can prepare a |PPoly| object by handing multiple |Poly| objects to its</span>
<span class="sd">    constructor:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import Poly, PPoly</span>
<span class="sd">    &gt;&gt;&gt; ppoly = PPoly(Poly(x0=1.0, cs=(1.0,)),</span>
<span class="sd">    ...         Poly(x0=2.0, cs=(1.0, 1.0)),</span>
<span class="sd">    ...         Poly(x0=3.0, cs=(2.0, 3.0)))</span>

<span class="sd">    Note that each power series constant (|Poly.x0|) also serves as a breakpoint.  Each</span>
<span class="sd">    |Poly.x0| value defines the lower bound of the interval for which the polynomial is</span>
<span class="sd">    valid.  The only exception affects the first |Poly| object.  Here, |Poly.x0| also</span>
<span class="sd">    serves as the power series constant but not as a breakpoint.  Hence, |PPoly| uses</span>
<span class="sd">    the first polynomial for extrapolation into the negative range (as it uses the last</span>
<span class="sd">    polynomial for extrapolating into the positive range).  The following equation,</span>
<span class="sd">    which reflects the configuration of the prepared interpolator, should clarify this</span>
<span class="sd">    definition:</span>

<span class="sd">      .. math::</span>
<span class="sd">        f(x) = \\begin{cases}</span>
<span class="sd">        1</span>
<span class="sd">        &amp;|\\</span>
<span class="sd">        x &lt; 2</span>
<span class="sd">        \\\\</span>
<span class="sd">        1 + x - 2</span>
<span class="sd">        &amp;|\\</span>
<span class="sd">        2 \\leq x &lt; 3</span>
<span class="sd">        \\\\</span>
<span class="sd">        2 + 3 \\cdot (x - 3)</span>
<span class="sd">        &amp;|\\</span>
<span class="sd">        3 \\leq x</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    For applying `ppoly`, we need to set the input value before calling</span>
<span class="sd">    |PPoly.calculate_values|:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.inputs[0] = 2.5</span>
<span class="sd">    &gt;&gt;&gt; ppoly.calculate_values()</span>
<span class="sd">    &gt;&gt;&gt; from hydpy import round_</span>
<span class="sd">    &gt;&gt;&gt; round_(ppoly.outputs[0])</span>
<span class="sd">    1.5</span>

<span class="sd">    The same holds when calling method |PPoly.calculate_derivatives| for calculating</span>
<span class="sd">    first order derivatives:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.calculate_derivatives(0)</span>
<span class="sd">    &gt;&gt;&gt; round_(ppoly.output_derivatives[0])</span>
<span class="sd">    1.0</span>

<span class="sd">    Use method |InterpAlgorithm.print_table| or method |InterpAlgorithm.plot| to</span>
<span class="sd">    inspect the results of `ppoly` within the relevant data range:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.print_table([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5])</span>
<span class="sd">    x    y    dy/dx</span>
<span class="sd">    0.5  1.0  0.0</span>
<span class="sd">    1.0  1.0  0.0</span>
<span class="sd">    1.5  1.0  0.0</span>
<span class="sd">    2.0  1.0  1.0</span>
<span class="sd">    2.5  1.5  1.0</span>
<span class="sd">    3.0  2.0  3.0</span>
<span class="sd">    3.5  3.5  3.0</span>

<span class="sd">    &gt;&gt;&gt; figure = ppoly.plot(xmin=0.0, xmax=4.0)</span>
<span class="sd">    &gt;&gt;&gt; from hydpy.core.testtools import save_autofig</span>
<span class="sd">    &gt;&gt;&gt; save_autofig(&quot;PPoly_base_example.png&quot;, figure=figure)</span>

<span class="sd">        .. image:: PPoly_base_example.png</span>

<span class="sd">    |PPoly| collects all constants and coefficients and provides access to them via</span>
<span class="sd">    properties |PPoly.x0s| and |PPoly.cs| available:</span>

<span class="sd">    &gt;&gt;&gt; from hydpy import print_matrix, print_vector</span>
<span class="sd">    &gt;&gt;&gt; print_vector(ppoly.x0s)</span>
<span class="sd">    1.0, 2.0, 3.0</span>
<span class="sd">    &gt;&gt;&gt; print_matrix(ppoly.cs)</span>
<span class="sd">    | 1.0, 0.0 |</span>
<span class="sd">    | 1.0, 1.0 |</span>
<span class="sd">    | 2.0, 3.0 |</span>


<span class="sd">    Property |PPoly.nmb_ps| reflects the total number of polynomials:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.nmb_ps</span>
<span class="sd">    3</span>

<span class="sd">    Property |PPoly.nmb_cs| informs about the number of relevant coefficients for each</span>
<span class="sd">    polynomial (the last non-negative coefficient is the last relevant one):</span>

<span class="sd">    &gt;&gt;&gt; print_vector(ppoly.nmb_cs)</span>
<span class="sd">    1, 2, 2</span>

<span class="sd">    You are free to manipulate both the breakpoints and the coefficients:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.x0s = 1.0, 2.0, 2.5</span>
<span class="sd">    &gt;&gt;&gt; ppoly.cs[1, 1] = 2.0</span>

<span class="sd">    &gt;&gt;&gt; ppoly.polynomials</span>
<span class="sd">    (Poly(x0=1.0, cs=(1.0,)), Poly(x0=2.0, cs=(1.0, 2.0)), Poly(x0=2.5, cs=(2.0, 3.0)))</span>

<span class="sd">    &gt;&gt;&gt; ppoly.print_table([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5])</span>
<span class="sd">    x    y    dy/dx</span>
<span class="sd">    0.5  1.0  0.0</span>
<span class="sd">    1.0  1.0  0.0</span>
<span class="sd">    1.5  1.0  0.0</span>
<span class="sd">    2.0  1.0  2.0</span>
<span class="sd">    2.5  2.0  3.0</span>
<span class="sd">    3.0  3.5  3.0</span>
<span class="sd">    3.5  5.0  3.0</span>

<span class="sd">    However, be aware that manipulating |PPoly.nmb_ps|, |PPoly.nmb_cs|, |PPoly.x0s|,</span>
<span class="sd">    |PPoly.nmb_cs| can cause severe problems, including program crashes.  Hence, you</span>
<span class="sd">    should always call the |PPoly.verify| method after manipulating these properties,</span>
<span class="sd">    which checks the integrity of the current configuration of |PPoly| objects:</span>

<span class="sd">    &gt;&gt;&gt; ppoly.nmb_ps = 1</span>
<span class="sd">    &gt;&gt;&gt; ppoly.verify()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    RuntimeError: While trying to verify parameter `ppoly` of element `?`, the \</span>
<span class="sd">following error occurred: The number of constants indicated by `nmb_ps` (1) does not \</span>
<span class="sd">agree with the actual number of constants held by vector `x0s` (3).</span>

<span class="sd">    To change an existing |PPoly| object more safely, you can &quot;call&quot; it with different</span>
<span class="sd">    |Poly| objects, which overwrites all current information, as shown by the following</span>
<span class="sd">    example, defining only a single polynomial:</span>

<span class="sd">    &gt;&gt;&gt; ppoly(Poly(x0=-1.0, cs=(0.0, 0.0, 1.0)))</span>
<span class="sd">    &gt;&gt;&gt; ppoly.print_table([-3.0, -2.0, -1.0, 0.0, 1.0])</span>
<span class="sd">    x     y    dy/dx</span>
<span class="sd">    -3.0  4.0  -4.0</span>
<span class="sd">    -2.0  1.0  -2.0</span>
<span class="sd">    -1.0  0.0  0.0</span>
<span class="sd">    0.0   1.0  2.0</span>
<span class="sd">    1.0   4.0  4.0</span>

<span class="sd">    Calling |PPoly| objects without any arguments results in the following error:</span>

<span class="sd">    &gt;&gt;&gt; ppoly()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: When calling an `PPoly` object, you need to define at least one \</span>
<span class="sd">polynomial function by passing at leas one `Poly` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_calgorithm</span><span class="p">:</span> <span class="n">ppolyutils</span><span class="o">.</span><span class="n">PPoly</span>
    <span class="n">_cready</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">polynomials</span><span class="p">:</span> <span class="n">Poly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cready</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">ppolyutils</span><span class="o">.</span><span class="n">PPoly</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span> <span class="o">=</span> <span class="n">ca</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">output_derivatives</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polynomials</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">polynomials</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">polynomials</span><span class="p">:</span> <span class="n">Poly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">polynomials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When calling an `PPoly` object, you need to define at least one &quot;</span>
                <span class="s2">&quot;polynomial function by passing at leas one `Poly` object.&quot;</span>
            <span class="p">)</span>
        <span class="n">nmb_ps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomials</span><span class="p">)</span>
        <span class="n">nmb_cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polynomials</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_INT</span><span class="p">)</span>
        <span class="n">x0s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">x0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polynomials</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmb_ps</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">nmb_cs</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">nmb</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nmb_cs</span><span class="p">,</span> <span class="n">polynomials</span><span class="p">)):</span>
            <span class="n">cs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:</span><span class="n">nmb</span><span class="p">]</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">cs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">nmb_ps</span><span class="p">,</span> <span class="n">nmb_cs</span><span class="p">,</span> <span class="n">x0s</span><span class="p">,</span> <span class="n">cs</span>

<div class="viewcode-block" id="PPoly.from_data">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.from_data">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_data</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
        <span class="n">ys</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">interpolate</span><span class="o">.</span><span class="n">CubicHermiteSpline</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPoly</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a |PPoly| object based on x-y data.</span>

<span class="sd">        As explained in the main documentation on class |PPoly|, you are free to define</span>
<span class="sd">        an arbitrary number of polynomials, each with arbitrary constants and</span>
<span class="sd">        coefficients.  However, one usually prefers functionally similar polynomials</span>
<span class="sd">        that standardised algorithms can compute. Method |PPoly.from_data| is a</span>
<span class="sd">        convenience function for following this route.  So far, it supports linear</span>
<span class="sd">        interpolation and some spline techniques.</span>

<span class="sd">        We start our explanations with a small and smooth x-y data set:</span>

<span class="sd">        &gt;&gt;&gt; xs = [1.0, 2.0, 3.0]</span>
<span class="sd">        &gt;&gt;&gt; ys = [1.0, 2.0, 3.5]</span>

<span class="sd">        By default, method |PPoly.from_data| prepares everything for a piecewise linear</span>
<span class="sd">        interpolation:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly.from_data(xs=xs, ys=ys)</span>
<span class="sd">        &gt;&gt;&gt; ppoly</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=1.0, cs=(1.0, 1.0)),</span>
<span class="sd">            Poly(x0=2.0, cs=(2.0, 1.5)),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ppoly.print_table(xs=[1.9, 2.0, 2.1])</span>
<span class="sd">        x    y     dy/dx</span>
<span class="sd">        1.9  1.9   1.0</span>
<span class="sd">        2.0  2.0   1.5</span>
<span class="sd">        2.1  2.15  1.5</span>
<span class="sd">        &gt;&gt;&gt; figure = ppoly.plot(0.0, 4.0, label=&quot;linear&quot;)</span>

<span class="sd">        Alternatively, |PPoly| can use the following |scipy| classes for determining</span>
<span class="sd">        higher-order polynomials:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import \</span>
<span class="sd">CubicSpline, Akima1DInterpolator, PchipInterpolator</span>

<span class="sd">        For sufficiently smooth data, cubic spline interpolation is often a good choice,</span>
<span class="sd">        as it preserves much smoothness around breakpoints (helpful for reaching</span>
<span class="sd">        required accuracies when applying numerical integration algorithms):</span>

<span class="sd">        &gt;&gt;&gt; ppoly = PPoly.from_data(xs=xs, ys=ys, method=CubicSpline)</span>
<span class="sd">        &gt;&gt;&gt; ppoly</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=1.0, cs=(1.0, 0.75, 0.25)),</span>
<span class="sd">            Poly(x0=2.0, cs=(2.0, 1.25, 0.25)),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ppoly.print_table(xs=[1.9, 2.0, 2.1])</span>
<span class="sd">        x    y       dy/dx</span>
<span class="sd">        1.9  1.8775  1.2</span>
<span class="sd">        2.0  2.0     1.25</span>
<span class="sd">        2.1  2.1275  1.3</span>
<span class="sd">        &gt;&gt;&gt; figure = ppoly.plot(0.0, 4.0, label=&quot;Cubic&quot;)</span>

<span class="sd">        For the given data, the Akima spline results in the same coefficients as the</span>
<span class="sd">        cubic spline:</span>

<span class="sd">        &gt;&gt;&gt; ppoly = PPoly.from_data(xs=xs, ys=ys, method=Akima1DInterpolator)</span>
<span class="sd">        &gt;&gt;&gt; ppoly</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=1.0, cs=(1.0, 0.75, 0.25)),</span>
<span class="sd">            Poly(x0=2.0, cs=(2.0, 1.25, 0.25)),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; figure = ppoly.plot(0.0, 4.0, label=&quot;Akima&quot;)</span>

<span class="sd">        The PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) algorithm</span>
<span class="sd">        generally tends to less smooth interpolations:</span>

<span class="sd">        &gt;&gt;&gt; ppoly = PPoly.from_data(xs=xs, ys=ys, method=PchipInterpolator)</span>
<span class="sd">        &gt;&gt;&gt; ppoly</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=1.0, cs=(1.0, 0.75, 0.3, -0.05)),</span>
<span class="sd">            Poly(x0=2.0, cs=(2.0, 1.2, 0.35, -0.05)),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; ppoly.print_table(xs=[1.9, 2.0, 2.1])</span>
<span class="sd">        x    y        dy/dx</span>
<span class="sd">        1.9  1.88155  1.1685</span>
<span class="sd">        2.0  2.0      1.2</span>
<span class="sd">        2.1  2.12345  1.2685</span>
<span class="sd">        &gt;&gt;&gt; figure = ppoly.plot(0.0, 4.0, label=&quot;Pchip&quot;)</span>

<span class="sd">        The following figure compares the linear and all spline interpolation results.</span>
<span class="sd">        As to be expected, the most sensible differences show in the interpolation</span>
<span class="sd">        ranges:</span>

<span class="sd">        &gt;&gt;&gt; _ = figure.gca().legend()</span>
<span class="sd">        &gt;&gt;&gt; from hydpy.core.testtools import save_autofig</span>
<span class="sd">        &gt;&gt;&gt; save_autofig(&quot;PPoly_data_smooth.png&quot;)</span>

<span class="sd">        .. image:: PPoly_data_smooth.png</span>

<span class="sd">        Next, we apply all four interpolation approaches on a non-smooth data set.</span>
<span class="sd">        Cubic interpolation is again the smoothest one but tends to overshoot, which</span>
<span class="sd">        can be problematic when violating physical constraints.  Besides the linear</span>
<span class="sd">        approach, only the PCHIP interpolation always preserves monotonicity in the</span>
<span class="sd">        original data. The Akima interpolation appears as a good compromise between</span>
<span class="sd">        these two approaches:</span>

<span class="sd">        &gt;&gt;&gt; for method, label in ((&quot;linear&quot;, &quot;linear&quot;),</span>
<span class="sd">        ...                       (CubicSpline, &quot;Cubic&quot;),</span>
<span class="sd">        ...                       (Akima1DInterpolator, &quot;Akima&quot;),</span>
<span class="sd">        ...                       (PchipInterpolator, &quot;Pchip&quot;)):</span>
<span class="sd">        ...     figure = PPoly.from_data(</span>
<span class="sd">        ...         xs=[1.0, 2.0, 3.0, 4.0], ys=[1.0, 1.0, 2.0, 2.0], method=method</span>
<span class="sd">        ...     ).plot(0.0, 5.0, label=label)</span>
<span class="sd">        &gt;&gt;&gt; _ = figure.gca().legend()</span>
<span class="sd">        &gt;&gt;&gt; _ = figure.gca().set_ylim((0.5, 2.5))</span>
<span class="sd">        &gt;&gt;&gt; save_autofig(&quot;PPoly_data_not_smooth.png&quot;)</span>

<span class="sd">        .. image:: PPoly_data_not_smooth.png</span>

<span class="sd">        Passing data sets with one or two x-y pairs works fine:</span>

<span class="sd">        &gt;&gt;&gt; PPoly.from_data(xs=[0.0], ys=[1.0])</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=0.0, cs=(1.0,)),</span>
<span class="sd">        )</span>

<span class="sd">        &gt;&gt;&gt; PPoly.from_data(xs=[0.0, 1.0], ys=[2.0, 5.0])</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=0.0, cs=(2.0, 3.0)),</span>
<span class="sd">        )</span>

<span class="sd">        Empty data sets or data sets of different lengths result in the following</span>
<span class="sd">        error messages:</span>

<span class="sd">        &gt;&gt;&gt; PPoly.from_data(xs=[], ys=[])</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: While trying to derive polynomials from the vectors `x` ([]) and \</span>
<span class="sd">`y` ([]), the following error occurred: Vectors `x` and `y` must not be empty.</span>

<span class="sd">        &gt;&gt;&gt; PPoly.from_data(xs=[0.0, 1.0], ys=[1.0, 2.0, 3.0])</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: While trying to derive polynomials from the vectors `x` ([0.0 and \</span>
<span class="sd">1.0]) and `y` ([1.0, 2.0, and 3.0]), the following error occurred: The lenghts of \</span>
<span class="sd">vectors `x` (2) and `y` (3) must be identical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The lenghts of vectors `x` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="si">}</span><span class="s2">) and `y` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="si">}</span><span class="s2">) must &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;be identical.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vectors `x` and `y` must not be empty.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cs</span><span class="o">=</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))</span>
            <span class="n">ppoly</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">):</span>
                <span class="n">nmb_ps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">nmb_cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nmb_ps</span><span class="p">,),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_INT</span><span class="p">)</span>
                <span class="n">x0s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmb_ps</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nmb_cs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>
                <span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interpolator</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xs</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ys</span><span class="p">)</span>
                <span class="n">x0s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cs</span> <span class="o">=</span> <span class="n">interpolator</span><span class="o">.</span><span class="n">c</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">nmb_ps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0s</span><span class="p">)</span>
                <span class="n">nmb_cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">cs_</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">cs_</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">],</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_INT</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">ppoly</span><span class="o">.</span><span class="n">nmb_ps</span><span class="p">,</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">,</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">x0s</span><span class="p">,</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">nmb_ps</span><span class="p">,</span> <span class="n">nmb_cs</span><span class="p">,</span> <span class="n">x0s</span><span class="p">,</span> <span class="n">cs</span>
            <span class="k">return</span> <span class="n">ppoly</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to derive polynomials from the vectors `x` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;([</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">)</span><span class="si">}</span><span class="s2">]) and `y` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;([</span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">enumeration</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">objecttools</span><span class="o">.</span><span class="n">repr_</span><span class="p">)</span><span class="si">}</span><span class="s2">])&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_nmb_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of input values.</span>

<span class="sd">        |PPoly| is a univariate interpolator.  Hence, |PPoly.nmb_inputs| is always one:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly</span>
<span class="sd">        &gt;&gt;&gt; PPoly().nmb_inputs</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">nmb_inputs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">Never</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_nmb_inputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The current input value.</span>

<span class="sd">        |PPoly| is a univariate interpolator.  Hence, |PPoly.inputs| always returns a</span>
<span class="sd">        vector with a single entry:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_vector</span>
<span class="sd">        &gt;&gt;&gt; print_vector(PPoly().inputs)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">Never</span><span class="p">,</span> <span class="n">VectorFloat</span><span class="p">](</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_inputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_nmb_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of output values.</span>

<span class="sd">        |PPoly| is a univariate interpolator.  Hence, |PPoly.nmb_outputs| is always</span>
<span class="sd">        one:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly</span>
<span class="sd">        &gt;&gt;&gt; PPoly().nmb_inputs</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">nmb_outputs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">Never</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_nmb_outputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The lastly calculated output value.</span>

<span class="sd">        |PPoly| is a univariate interpolator.  Hence, |PPoly.outputs| always returns a</span>
<span class="sd">        vector with a single entry:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_vector</span>
<span class="sd">        &gt;&gt;&gt; print_vector(PPoly().outputs)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">Never</span><span class="p">,</span> <span class="n">VectorFloat</span><span class="p">](</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_outputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_output_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The lastly calculated first-order derivative.</span>

<span class="sd">        |PPoly| is a univariate interpolator.  Hence, |PPoly.output_derivatives|</span>
<span class="sd">        always returns a vector with a single entry:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_vector</span>
<span class="sd">        &gt;&gt;&gt; print_vector(PPoly().output_derivatives)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">output_derivatives</span><span class="p">)</span>

    <span class="n">output_derivatives</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">Property</span><span class="p">[</span><span class="n">Never</span><span class="p">,</span> <span class="n">VectorFloat</span><span class="p">](</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">_get_output_derivatives</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_nmb_ps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of polynomials.</span>

<span class="sd">        |PPoly.nmb_ps| is &quot;protected&quot; (implemented by |ProtectedProperty|) for the sake</span>
<span class="sd">        of preventing segmentation faults when trying to access the related data from</span>
<span class="sd">        the underlying Cython extension class before allocation:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.nmb_ps = 1</span>
<span class="sd">        &gt;&gt;&gt; ppoly.nmb_ps</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; del ppoly.nmb_ps</span>
<span class="sd">        &gt;&gt;&gt; ppoly.nmb_ps</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `nmb_ps` of object \</span>
<span class="sd">`ppoly` has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">nmb_ps</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_nmb_ps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">nmb_ps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_del_nmb_ps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">nmb_ps</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">](</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">_get_nmb_ps</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_nmb_ps</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="n">_del_nmb_ps</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_nmb_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorInt</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of relevant coefficients for each polynomial.</span>

<span class="sd">        |PPoly.nmb_cs| is &quot;protected&quot; (implemented by |ProtectedProperty|) for the sake</span>
<span class="sd">        of preventing segmentation faults when trying to access the related data from</span>
<span class="sd">        the underlying Cython extension class before allocation:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_vector</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.nmb_cs = 1, 2</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.nmb_cs)</span>
<span class="sd">        1, 2</span>
<span class="sd">        &gt;&gt;&gt; del ppoly.nmb_cs</span>
<span class="sd">        &gt;&gt;&gt; ppoly.nmb_cs</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `nmb_cs` of object \</span>
<span class="sd">`ppoly` has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_nmb_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">VectorInputInt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">nmb_cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_INT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_del_nmb_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">nmb_cs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span><span class="p">[</span><span class="n">VectorInputInt</span><span class="p">,</span> <span class="n">VectorInt</span><span class="p">](</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">_get_nmb_cs</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_nmb_cs</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="n">_del_nmb_cs</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_x0s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The power series constants of all polynomials.</span>

<span class="sd">        |PPoly.x0s| is &quot;protected&quot; (implemented by |ProtectedProperty|) for the sake of</span>
<span class="sd">        preventing segmentation faults when trying to access the related data from the</span>
<span class="sd">        underlying Cython extension class before allocation:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_vector</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.x0s = 1.0, 2.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.x0s)</span>
<span class="sd">        1.0, 2.0</span>
<span class="sd">        &gt;&gt;&gt; del ppoly.x0s</span>
<span class="sd">        &gt;&gt;&gt; ppoly.x0s</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `x0s` of object \</span>
<span class="sd">`ppoly` has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">x0s</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_x0s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">VectorInputFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">x0s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_del_x0s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">x0s</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span><span class="p">[</span><span class="n">VectorInputFloat</span><span class="p">,</span> <span class="n">VectorFloat</span><span class="p">](</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">_get_x0s</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_x0s</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="n">_del_x0s</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MatrixFloat</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The power series coefficients of all polynomials.</span>

<span class="sd">        |PPoly.cs| is &quot;protected&quot; (implemented by |ProtectedProperty|) for the sake of</span>
<span class="sd">        preventing segmentation faults when trying to access the related data from the</span>
<span class="sd">        underlying Cython extension class before allocation:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly, print_matrix</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.cs = [[1.0, 2.0], [3.0, 4.0]]</span>
<span class="sd">        &gt;&gt;&gt; print_matrix(ppoly.cs)</span>
<span class="sd">        | 1.0, 2.0 |</span>
<span class="sd">        | 3.0, 4.0 |</span>
<span class="sd">        &gt;&gt;&gt; del ppoly.cs</span>
<span class="sd">        &gt;&gt;&gt; ppoly.cs</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        hydpy.core.exceptiontools.AttributeNotReady: Attribute `cs` of object `ppoly` \</span>
<span class="sd">has not been prepared so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">MatrixInputFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">NP_FLOAT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_del_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">cs</span> <span class="o">=</span> <span class="n">propertytools</span><span class="o">.</span><span class="n">ProtectedProperty</span><span class="p">[</span><span class="n">MatrixInputFloat</span><span class="p">,</span> <span class="n">MatrixFloat</span><span class="p">](</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">_get_cs</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_cs</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="n">_del_cs</span>
    <span class="p">)</span>

<div class="viewcode-block" id="PPoly.calculate_values">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.calculate_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the output value based on the input values defined previously.</span>

<span class="sd">        For more information, see the documentation on class |ppolytools.PPoly|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">calculate_values</span><span class="p">()</span></div>


<div class="viewcode-block" id="PPoly.calculate_derivatives">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.calculate_derivatives">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the derivative of the output value with respect to the input value.</span>

<span class="sd">        For more information, see the documentation on class |ppolytools.PPoly|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calgorithm</span><span class="o">.</span><span class="n">calculate_derivatives</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">polynomials</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Poly</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The configuration of the current |ppolytools.PPoly| object, represented by a</span>
<span class="sd">        tuple of |Poly| objects.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Poly, PPoly</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly(Poly(x0=1.0, cs=(1.0,)), Poly(x0=2.0, cs=(1.0, 1.0)))</span>
<span class="sd">        &gt;&gt;&gt; ppoly.polynomials</span>
<span class="sd">        (Poly(x0=1.0, cs=(1.0,)), Poly(x0=2.0, cs=(1.0, 1.0)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">Poly</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cs</span><span class="p">[:</span><span class="n">n</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">x0</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PPoly.sort">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort the currently handled polynomials.</span>

<span class="sd">        The power series constants held by array |ppolytools.PPoly.x0s| also</span>
<span class="sd">        serve as breakpoints, defining the lower bounds of the intervals for which the</span>
<span class="sd">        available polynomials are valid. The algorithm underlying |PPoly| expects them</span>
<span class="sd">        in sorted order.</span>

<span class="sd">        In the following example, we hand over two wrongly-ordered |Poly| objects:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Poly, PPoly, print_matrix, print_vector</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly(Poly(x0=2.0, cs=(1.0, 1.0)), Poly(x0=1.0, cs=(1.0,)))</span>
<span class="sd">        &gt;&gt;&gt; ppoly.polynomials</span>
<span class="sd">        (Poly(x0=2.0, cs=(1.0, 1.0)), Poly(x0=1.0, cs=(1.0,)))</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.x0s)</span>
<span class="sd">        2.0, 1.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.nmb_cs)</span>
<span class="sd">        2, 1</span>
<span class="sd">        &gt;&gt;&gt; print_matrix(ppoly.cs)</span>
<span class="sd">        | 1.0, 1.0 |</span>
<span class="sd">        | 1.0, 0.0 |</span>

<span class="sd">        Method |ppolytools.PPoly.sort| sorts |ppolytools.PPoly.x0s| and the related</span>
<span class="sd">        arrays |ppolytools.PPoly.nmb_cs| and |ppolytools.PPoly.cs|:</span>

<span class="sd">        &gt;&gt;&gt; ppoly.sort()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.polynomials</span>
<span class="sd">        (Poly(x0=1.0, cs=(1.0,)), Poly(x0=2.0, cs=(1.0, 1.0)))</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.x0s)</span>
<span class="sd">        1.0, 2.0</span>
<span class="sd">        &gt;&gt;&gt; print_vector(ppoly.nmb_cs)</span>
<span class="sd">        1, 2</span>
<span class="sd">        &gt;&gt;&gt; print_matrix(ppoly.cs)</span>
<span class="sd">        | 1.0, 0.0 |</span>
<span class="sd">        | 1.0, 1.0 |</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxs</span><span class="p">:</span> <span class="n">VectorInt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="PPoly.verify">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.verify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a |RuntimeError| if the current |ppolytools.PPoly| object shows</span>
<span class="sd">        inconsistencies.</span>

<span class="sd">        Note that |ppolytools.PPoly| never calls |ppolytools.PPoly.verify|</span>
<span class="sd">        automatically.  Hence, we strongly advise applying it manually before using a</span>
<span class="sd">        new |ppolytools.PPoly| configuration the first time.</span>

<span class="sd">        So far, method |ppolytools.PPoly.verify| reports the following problems:</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import PPoly</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly(Poly(x0=2.0, cs=(1.0, 1.0)), Poly(x0=1.0, cs=(1.0,)))</span>
<span class="sd">        &gt;&gt;&gt; ppoly.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to verify parameter `ppoly` of element `?`, the \</span>
<span class="sd">following error occurred: The constants held in vector `x0s` are not strictly \</span>
<span class="sd">increasing, which is necessary as they also serve as breakpoints for selecting the \</span>
<span class="sd">relevant polynomials.</span>

<span class="sd">        &gt;&gt;&gt; ppoly.sort()</span>
<span class="sd">        &gt;&gt;&gt; ppoly.verify()</span>

<span class="sd">        &gt;&gt;&gt; ppoly.nmb_cs[1] = 3</span>
<span class="sd">        &gt;&gt;&gt; ppoly.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to verify parameter `ppoly` of element `?`, the \</span>
<span class="sd">following error occurred: The highest number of coefficients indicated by `nmb_cs` \</span>
<span class="sd">(3) is larger than the possible number of coefficients storable in the coefficient \</span>
<span class="sd">matrix `cs` (2).</span>

<span class="sd">        &gt;&gt;&gt; ppoly.cs = ppoly.cs[:1, :]</span>
<span class="sd">        &gt;&gt;&gt; ppoly.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to verify parameter `ppoly` of element `?`, the \</span>
<span class="sd">following error occurred: The number of polynomials indicated by `nmb_ps` (2) does \</span>
<span class="sd">not agree with the actual number of coefficient arrays held by matrix `cs` (1).</span>

<span class="sd">        &gt;&gt;&gt; ppoly.x0s = ppoly.x0s[:1]</span>
<span class="sd">        &gt;&gt;&gt; ppoly.verify()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        RuntimeError: While trying to verify parameter `ppoly` of element `?`, the \</span>
<span class="sd">following error occurred: The number of constants indicated by `nmb_ps` (2) does not \</span>
<span class="sd">agree with the actual number of constants held by vector `x0s` (1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The number of constants indicated by `nmb_ps` (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;does not agree with the actual number of constants held by &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;vector `x0s` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The number of polynomials indicated by `nmb_ps` (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;does not agree with the actual number of coefficient arrays held &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;by matrix `cs` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The highest number of coefficients indicated by `nmb_cs` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_cs</span><span class="p">)</span><span class="si">}</span><span class="s2">) is larger than the possible number of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;coefficients storable in the coefficient matrix `cs` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmb_ps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;The constants held in vector `x0s` are not strictly increasing, &quot;</span>
                    <span class="s2">&quot;which is necessary as they also serve as breakpoints for &quot;</span>
                    <span class="s2">&quot;selecting the relevant polynomials.&quot;</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">objecttools</span><span class="o">.</span><span class="n">augment_excmessage</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While trying to verify parameter </span><span class="si">{</span><span class="n">objecttools</span><span class="o">.</span><span class="n">elementphrase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="PPoly.assignrepr">
<a class="viewcode-back" href="../../../ppolytools.html#hydpy.auxs.ppolytools.PPoly.assignrepr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assignrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the actual |ppolytools.PPoly| object</span>
<span class="sd">        prefixed with the given string.</span>

<span class="sd">        &gt;&gt;&gt; from hydpy import Poly, PPoly</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly(Poly(x0=1.0, cs=(1.0,)), Poly(x0=2.0, cs=(1.0, 1.0)))</span>
<span class="sd">        &gt;&gt;&gt; ppoly</span>
<span class="sd">        PPoly(</span>
<span class="sd">            Poly(x0=1.0, cs=(1.0,)),</span>
<span class="sd">            Poly(x0=2.0, cs=(1.0, 1.0)),</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; print(ppoly.assignrepr(prefix=&quot;    ppoly = &quot;, indent=4))</span>
<span class="sd">            ppoly = PPoly(</span>
<span class="sd">                Poly(x0=1.0, cs=(1.0,)),</span>
<span class="sd">                Poly(x0=2.0, cs=(1.0, 1.0)),</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blanks</span> <span class="o">=</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(&quot;</span><span class="p">]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">blanks</span><span class="si">}{</span><span class="n">poly</span><span class="si">}</span><span class="s2">,&quot;</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polynomials</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">indent</span><span class="o">*</span><span class="s2">&quot; &quot;</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignrepr</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">HydPy 6.3dev0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hydpy.auxs.ppolytools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2026, HydPy Developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>